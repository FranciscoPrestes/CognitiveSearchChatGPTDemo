{"version":3,"file":"@microsoft-31b40247.js","sources":["../../../frontend/node_modules/@microsoft/load-themed-styles/lib-es6/index.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\nvar __assign = (this && this.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n// Store the theming state in __themeState__ global scope for reuse in the case of duplicate\r\n// load-themed-styles hosted on the page.\r\nvar _root = typeof window === 'undefined' ? global : window; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n// Nonce string to inject into script tag if one provided. This is used in CSP (Content Security Policy).\r\nvar _styleNonce = _root && _root.CSPSettings && _root.CSPSettings.nonce;\r\nvar _themeState = initializeThemeState();\r\n/**\r\n * Matches theming tokens. For example, \"[theme: themeSlotName, default: #FFF]\" (including the quotes).\r\n */\r\nvar _themeTokenRegex = /[\\'\\\"]\\[theme:\\s*(\\w+)\\s*(?:\\,\\s*default:\\s*([\\\\\"\\']?[\\.\\,\\(\\)\\#\\-\\s\\w]*[\\.\\,\\(\\)\\#\\-\\w][\\\"\\']?))?\\s*\\][\\'\\\"]/g;\r\nvar now = function () {\r\n    return typeof performance !== 'undefined' && !!performance.now ? performance.now() : Date.now();\r\n};\r\nfunction measure(func) {\r\n    var start = now();\r\n    func();\r\n    var end = now();\r\n    _themeState.perf.duration += end - start;\r\n}\r\n/**\r\n * initialize global state object\r\n */\r\nfunction initializeThemeState() {\r\n    var state = _root.__themeState__ || {\r\n        theme: undefined,\r\n        lastStyleElement: undefined,\r\n        registeredStyles: []\r\n    };\r\n    if (!state.runState) {\r\n        state = __assign(__assign({}, state), { perf: {\r\n                count: 0,\r\n                duration: 0\r\n            }, runState: {\r\n                flushTimer: 0,\r\n                mode: 0 /* Mode.sync */,\r\n                buffer: []\r\n            } });\r\n    }\r\n    if (!state.registeredThemableStyles) {\r\n        state = __assign(__assign({}, state), { registeredThemableStyles: [] });\r\n    }\r\n    _root.__themeState__ = state;\r\n    return state;\r\n}\r\n/**\r\n * Loads a set of style text. If it is registered too early, we will register it when the window.load\r\n * event is fired.\r\n * @param {string | ThemableArray} styles Themable style text to register.\r\n * @param {boolean} loadAsync When true, always load styles in async mode, irrespective of current sync mode.\r\n */\r\nexport function loadStyles(styles, loadAsync) {\r\n    if (loadAsync === void 0) { loadAsync = false; }\r\n    measure(function () {\r\n        var styleParts = Array.isArray(styles) ? styles : splitStyles(styles);\r\n        var _a = _themeState.runState, mode = _a.mode, buffer = _a.buffer, flushTimer = _a.flushTimer;\r\n        if (loadAsync || mode === 1 /* Mode.async */) {\r\n            buffer.push(styleParts);\r\n            if (!flushTimer) {\r\n                _themeState.runState.flushTimer = asyncLoadStyles();\r\n            }\r\n        }\r\n        else {\r\n            applyThemableStyles(styleParts);\r\n        }\r\n    });\r\n}\r\n/**\r\n * Allows for customizable loadStyles logic. e.g. for server side rendering application\r\n * @param {(processedStyles: string, rawStyles?: string | ThemableArray) => void}\r\n * a loadStyles callback that gets called when styles are loaded or reloaded\r\n */\r\nexport function configureLoadStyles(loadStylesFn) {\r\n    _themeState.loadStyles = loadStylesFn;\r\n}\r\n/**\r\n * Configure run mode of load-themable-styles\r\n * @param mode load-themable-styles run mode, async or sync\r\n */\r\nexport function configureRunMode(mode) {\r\n    _themeState.runState.mode = mode;\r\n}\r\n/**\r\n * external code can call flush to synchronously force processing of currently buffered styles\r\n */\r\nexport function flush() {\r\n    measure(function () {\r\n        var styleArrays = _themeState.runState.buffer.slice();\r\n        _themeState.runState.buffer = [];\r\n        var mergedStyleArray = [].concat.apply([], styleArrays);\r\n        if (mergedStyleArray.length > 0) {\r\n            applyThemableStyles(mergedStyleArray);\r\n        }\r\n    });\r\n}\r\n/**\r\n * register async loadStyles\r\n */\r\nfunction asyncLoadStyles() {\r\n    return setTimeout(function () {\r\n        _themeState.runState.flushTimer = 0;\r\n        flush();\r\n    }, 0);\r\n}\r\n/**\r\n * Loads a set of style text. If it is registered too early, we will register it when the window.load event\r\n * is fired.\r\n * @param {string} styleText Style to register.\r\n * @param {IStyleRecord} styleRecord Existing style record to re-apply.\r\n */\r\nfunction applyThemableStyles(stylesArray, styleRecord) {\r\n    if (_themeState.loadStyles) {\r\n        _themeState.loadStyles(resolveThemableArray(stylesArray).styleString, stylesArray);\r\n    }\r\n    else {\r\n        registerStyles(stylesArray);\r\n    }\r\n}\r\n/**\r\n * Registers a set theme tokens to find and replace. If styles were already registered, they will be\r\n * replaced.\r\n * @param {theme} theme JSON object of theme tokens to values.\r\n */\r\nexport function loadTheme(theme) {\r\n    _themeState.theme = theme;\r\n    // reload styles.\r\n    reloadStyles();\r\n}\r\n/**\r\n * Clear already registered style elements and style records in theme_State object\r\n * @param option - specify which group of registered styles should be cleared.\r\n * Default to be both themable and non-themable styles will be cleared\r\n */\r\nexport function clearStyles(option) {\r\n    if (option === void 0) { option = 3 /* ClearStyleOptions.all */; }\r\n    if (option === 3 /* ClearStyleOptions.all */ || option === 2 /* ClearStyleOptions.onlyNonThemable */) {\r\n        clearStylesInternal(_themeState.registeredStyles);\r\n        _themeState.registeredStyles = [];\r\n    }\r\n    if (option === 3 /* ClearStyleOptions.all */ || option === 1 /* ClearStyleOptions.onlyThemable */) {\r\n        clearStylesInternal(_themeState.registeredThemableStyles);\r\n        _themeState.registeredThemableStyles = [];\r\n    }\r\n}\r\nfunction clearStylesInternal(records) {\r\n    records.forEach(function (styleRecord) {\r\n        var styleElement = styleRecord && styleRecord.styleElement;\r\n        if (styleElement && styleElement.parentElement) {\r\n            styleElement.parentElement.removeChild(styleElement);\r\n        }\r\n    });\r\n}\r\n/**\r\n * Reloads styles.\r\n */\r\nfunction reloadStyles() {\r\n    if (_themeState.theme) {\r\n        var themableStyles = [];\r\n        for (var _i = 0, _a = _themeState.registeredThemableStyles; _i < _a.length; _i++) {\r\n            var styleRecord = _a[_i];\r\n            themableStyles.push(styleRecord.themableStyle);\r\n        }\r\n        if (themableStyles.length > 0) {\r\n            clearStyles(1 /* ClearStyleOptions.onlyThemable */);\r\n            applyThemableStyles([].concat.apply([], themableStyles));\r\n        }\r\n    }\r\n}\r\n/**\r\n * Find theme tokens and replaces them with provided theme values.\r\n * @param {string} styles Tokenized styles to fix.\r\n */\r\nexport function detokenize(styles) {\r\n    if (styles) {\r\n        styles = resolveThemableArray(splitStyles(styles)).styleString;\r\n    }\r\n    return styles;\r\n}\r\n/**\r\n * Resolves ThemingInstruction objects in an array and joins the result into a string.\r\n * @param {ThemableArray} splitStyleArray ThemableArray to resolve and join.\r\n */\r\nfunction resolveThemableArray(splitStyleArray) {\r\n    var theme = _themeState.theme;\r\n    var themable = false;\r\n    // Resolve the array of theming instructions to an array of strings.\r\n    // Then join the array to produce the final CSS string.\r\n    var resolvedArray = (splitStyleArray || []).map(function (currentValue) {\r\n        var themeSlot = currentValue.theme;\r\n        if (themeSlot) {\r\n            themable = true;\r\n            // A theming annotation. Resolve it.\r\n            var themedValue = theme ? theme[themeSlot] : undefined;\r\n            var defaultValue = currentValue.defaultValue || 'inherit';\r\n            // Warn to console if we hit an unthemed value even when themes are provided, but only if \"DEBUG\" is true.\r\n            // Allow the themedValue to be undefined to explicitly request the default value.\r\n            if (theme &&\r\n                !themedValue &&\r\n                console &&\r\n                !(themeSlot in theme) &&\r\n                typeof DEBUG !== 'undefined' &&\r\n                DEBUG) {\r\n                console.warn(\"Theming value not provided for \\\"\".concat(themeSlot, \"\\\". Falling back to \\\"\").concat(defaultValue, \"\\\".\"));\r\n            }\r\n            return themedValue || defaultValue;\r\n        }\r\n        else {\r\n            // A non-themable string. Preserve it.\r\n            return currentValue.rawString;\r\n        }\r\n    });\r\n    return {\r\n        styleString: resolvedArray.join(''),\r\n        themable: themable\r\n    };\r\n}\r\n/**\r\n * Split tokenized CSS into an array of strings and theme specification objects\r\n * @param {string} styles Tokenized styles to split.\r\n */\r\nexport function splitStyles(styles) {\r\n    var result = [];\r\n    if (styles) {\r\n        var pos = 0; // Current position in styles.\r\n        var tokenMatch = void 0;\r\n        while ((tokenMatch = _themeTokenRegex.exec(styles))) {\r\n            var matchIndex = tokenMatch.index;\r\n            if (matchIndex > pos) {\r\n                result.push({\r\n                    rawString: styles.substring(pos, matchIndex)\r\n                });\r\n            }\r\n            result.push({\r\n                theme: tokenMatch[1],\r\n                defaultValue: tokenMatch[2] // May be undefined\r\n            });\r\n            // index of the first character after the current match\r\n            pos = _themeTokenRegex.lastIndex;\r\n        }\r\n        // Push the rest of the string after the last match.\r\n        result.push({\r\n            rawString: styles.substring(pos)\r\n        });\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Registers a set of style text. If it is registered too early, we will register it when the\r\n * window.load event is fired.\r\n * @param {ThemableArray} styleArray Array of IThemingInstruction objects to register.\r\n * @param {IStyleRecord} styleRecord May specify a style Element to update.\r\n */\r\nfunction registerStyles(styleArray) {\r\n    if (typeof document === 'undefined') {\r\n        return;\r\n    }\r\n    var head = document.getElementsByTagName('head')[0];\r\n    var styleElement = document.createElement('style');\r\n    var _a = resolveThemableArray(styleArray), styleString = _a.styleString, themable = _a.themable;\r\n    styleElement.setAttribute('data-load-themed-styles', 'true');\r\n    if (_styleNonce) {\r\n        styleElement.setAttribute('nonce', _styleNonce);\r\n    }\r\n    styleElement.appendChild(document.createTextNode(styleString));\r\n    _themeState.perf.count++;\r\n    head.appendChild(styleElement);\r\n    var ev = document.createEvent('HTMLEvents');\r\n    ev.initEvent('styleinsert', true /* bubbleEvent */, false /* cancelable */);\r\n    ev.args = {\r\n        newStyle: styleElement\r\n    };\r\n    document.dispatchEvent(ev);\r\n    var record = {\r\n        styleElement: styleElement,\r\n        themableStyle: styleArray\r\n    };\r\n    if (themable) {\r\n        _themeState.registeredThemableStyles.push(record);\r\n    }\r\n    else {\r\n        _themeState.registeredStyles.push(record);\r\n    }\r\n}\r\n//# sourceMappingURL=index.js.map"],"names":["__assign","this","t","s","i","n","p","_root","_styleNonce","_themeState","initializeThemeState","state","applyThemableStyles","stylesArray","styleRecord","resolveThemableArray","registerStyles","loadTheme","theme","reloadStyles","clearStyles","option","clearStylesInternal","records","styleElement","themableStyles","_i","_a","splitStyleArray","themable","resolvedArray","currentValue","themeSlot","themedValue","defaultValue","styleArray","head","styleString","ev","record"],"mappings":"AAEA,IAAIA,EAAYC,YAAQA,WAAK,UAAa,UAAY,CAClD,OAAAD,EAAW,OAAO,QAAU,SAASE,EAAG,CACpC,QAASC,EAAGC,EAAI,EAAGC,EAAI,UAAU,OAAQD,EAAIC,EAAGD,IAAK,CACjDD,EAAI,UAAUC,CAAC,EACf,QAASE,KAAKH,EAAO,OAAO,UAAU,eAAe,KAAKA,EAAGG,CAAC,IAC1DJ,EAAEI,CAAC,EAAIH,EAAEG,CAAC,EACjB,CACD,OAAOJ,CACf,EACWF,EAAS,MAAM,KAAM,SAAS,CACzC,EAGIO,EAAQ,OAAO,OAAW,IAAc,OAAS,OAEjDC,EAAcD,GAASA,EAAM,aAAeA,EAAM,YAAY,MAC9DE,EAAcC,EAAoB,EAiBtC,SAASA,GAAuB,CAC5B,IAAIC,EAAQJ,EAAM,gBAAkB,CAChC,MAAO,OACP,iBAAkB,OAClB,iBAAkB,CAAE,CAC5B,EACI,OAAKI,EAAM,WACPA,EAAQX,EAASA,EAAS,CAAE,EAAEW,CAAK,EAAG,CAAE,KAAM,CACtC,MAAO,EACP,SAAU,CACb,EAAE,SAAU,CACT,WAAY,EACZ,KAAM,EACN,OAAQ,CAAE,CACb,CAAA,CAAE,GAENA,EAAM,2BACPA,EAAQX,EAASA,EAAS,CAAE,EAAEW,CAAK,EAAG,CAAE,yBAA0B,CAAE,CAAA,CAAE,GAE1EJ,EAAM,eAAiBI,EAChBA,CACX,CAkEA,SAASC,EAAoBC,EAAaC,EAAa,CAC/CL,EAAY,WACZA,EAAY,WAAWM,EAAqBF,CAAW,EAAE,YAAaA,CAAW,EAGjFG,EAAeH,CAAW,CAElC,CAMO,SAASI,EAAUC,EAAO,CAC7BT,EAAY,MAAQS,EAEpBC,GACJ,CAMO,SAASC,EAAYC,EAAQ,CAC5BA,IAAW,SAAUA,EAAS,IAC9BA,IAAW,GAAiCA,IAAW,KACvDC,EAAoBb,EAAY,gBAAgB,EAChDA,EAAY,iBAAmB,KAE/BY,IAAW,GAAiCA,IAAW,KACvDC,EAAoBb,EAAY,wBAAwB,EACxDA,EAAY,yBAA2B,GAE/C,CACA,SAASa,EAAoBC,EAAS,CAClCA,EAAQ,QAAQ,SAAUT,EAAa,CACnC,IAAIU,EAAeV,GAAeA,EAAY,aAC1CU,GAAgBA,EAAa,eAC7BA,EAAa,cAAc,YAAYA,CAAY,CAE/D,CAAK,CACL,CAIA,SAASL,GAAe,CACpB,GAAIV,EAAY,MAAO,CAEnB,QADIgB,EAAiB,CAAA,EACZC,EAAK,EAAGC,EAAKlB,EAAY,yBAA0BiB,EAAKC,EAAG,OAAQD,IAAM,CAC9E,IAAIZ,EAAca,EAAGD,CAAE,EACvBD,EAAe,KAAKX,EAAY,aAAa,CAChD,CACGW,EAAe,OAAS,IACxBL,EAAY,CAAC,EACbR,EAAoB,CAAE,EAAC,OAAO,MAAM,CAAE,EAAEa,CAAc,CAAC,EAE9D,CACL,CAeA,SAASV,EAAqBa,EAAiB,CAC3C,IAAIV,EAAQT,EAAY,MACpBoB,EAAW,GAGXC,GAAiBF,GAAmB,CAAE,GAAE,IAAI,SAAUG,EAAc,CACpE,IAAIC,EAAYD,EAAa,MAC7B,GAAIC,EAAW,CACXH,EAAW,GAEX,IAAII,EAAcf,EAAQA,EAAMc,CAAS,EAAI,OACzCE,EAAeH,EAAa,cAAgB,UAGhD,OAAIb,GACA,CAACe,GACD,SACA,EAAED,KAAad,IACf,OAAO,MAAU,KACjB,OACA,QAAQ,KAAK,mCAAoC,OAAOc,EAAW,sBAAwB,EAAE,OAAOE,EAAc,IAAK,CAAC,EAErHD,GAAeC,CACzB,KAGG,QAAOH,EAAa,SAEhC,CAAK,EACD,MAAO,CACH,YAAaD,EAAc,KAAK,EAAE,EAClC,SAAUD,CAClB,CACA,CAqCA,SAASb,EAAemB,EAAY,CAChC,GAAI,SAAO,SAAa,KAGxB,KAAIC,EAAO,SAAS,qBAAqB,MAAM,EAAE,CAAC,EAC9CZ,EAAe,SAAS,cAAc,OAAO,EAC7CG,EAAKZ,EAAqBoB,CAAU,EAAGE,EAAcV,EAAG,YAAaE,EAAWF,EAAG,SACvFH,EAAa,aAAa,0BAA2B,MAAM,EACvDhB,GACAgB,EAAa,aAAa,QAAShB,CAAW,EAElDgB,EAAa,YAAY,SAAS,eAAea,CAAW,CAAC,EAC7D5B,EAAY,KAAK,QACjB2B,EAAK,YAAYZ,CAAY,EAC7B,IAAIc,EAAK,SAAS,YAAY,YAAY,EAC1CA,EAAG,UAAU,cAAe,GAAwB,EAAK,EACzDA,EAAG,KAAO,CACN,SAAUd,CAClB,EACI,SAAS,cAAcc,CAAE,EACzB,IAAIC,EAAS,CACT,aAAcf,EACd,cAAeW,CACvB,EACQN,EACApB,EAAY,yBAAyB,KAAK8B,CAAM,EAGhD9B,EAAY,iBAAiB,KAAK8B,CAAM,EAEhD"}
{"version":3,"file":"@remix-run-88f74c5a.js","sources":["../../../frontend/node_modules/@remix-run/router/dist/router.js"],"sourcesContent":["/**\r\n * @remix-run/router v1.3.2\r\n *\r\n * Copyright (c) Remix Software Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE.md file in the root directory of this source tree.\r\n *\r\n * @license MIT\r\n */\r\nfunction _extends() {\r\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      var source = arguments[i];\r\n\r\n      for (var key in source) {\r\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n          target[key] = source[key];\r\n        }\r\n      }\r\n    }\r\n\r\n    return target;\r\n  };\r\n  return _extends.apply(this, arguments);\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n//#region Types and Constants\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n/**\r\n * Actions represent the type of change to a location value.\r\n */\r\nvar Action;\r\n\r\n(function (Action) {\r\n  /**\r\n   * A POP indicates a change to an arbitrary index in the history stack, such\r\n   * as a back or forward navigation. It does not describe the direction of the\r\n   * navigation, only that the current index changed.\r\n   *\r\n   * Note: This is the default action for newly created history objects.\r\n   */\r\n  Action[\"Pop\"] = \"POP\";\r\n  /**\r\n   * A PUSH indicates a new entry being added to the history stack, such as when\r\n   * a link is clicked and a new page loads. When this happens, all subsequent\r\n   * entries in the stack are lost.\r\n   */\r\n\r\n  Action[\"Push\"] = \"PUSH\";\r\n  /**\r\n   * A REPLACE indicates the entry at the current index in the history stack\r\n   * being replaced by a new one.\r\n   */\r\n\r\n  Action[\"Replace\"] = \"REPLACE\";\r\n})(Action || (Action = {}));\r\n\r\nconst PopStateEventType = \"popstate\";\r\n/**\r\n * Memory history stores the current location in memory. It is designed for use\r\n * in stateful non-browser environments like tests and React Native.\r\n */\r\n\r\nfunction createMemoryHistory(options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n\r\n  let {\r\n    initialEntries = [\"/\"],\r\n    initialIndex,\r\n    v5Compat = false\r\n  } = options;\r\n  let entries; // Declare so we can access from createMemoryLocation\r\n\r\n  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index === 0 ? \"default\" : undefined));\r\n  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\r\n  let action = Action.Pop;\r\n  let listener = null;\r\n\r\n  function clampIndex(n) {\r\n    return Math.min(Math.max(n, 0), entries.length - 1);\r\n  }\r\n\r\n  function getCurrentLocation() {\r\n    return entries[index];\r\n  }\r\n\r\n  function createMemoryLocation(to, state, key) {\r\n    if (state === void 0) {\r\n      state = null;\r\n    }\r\n\r\n    let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\r\n    warning$1(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\r\n    return location;\r\n  }\r\n\r\n  function createHref(to) {\r\n    return typeof to === \"string\" ? to : createPath(to);\r\n  }\r\n\r\n  let history = {\r\n    get index() {\r\n      return index;\r\n    },\r\n\r\n    get action() {\r\n      return action;\r\n    },\r\n\r\n    get location() {\r\n      return getCurrentLocation();\r\n    },\r\n\r\n    createHref,\r\n\r\n    createURL(to) {\r\n      return new URL(createHref(to), \"http://localhost\");\r\n    },\r\n\r\n    encodeLocation(to) {\r\n      let path = typeof to === \"string\" ? parsePath(to) : to;\r\n      return {\r\n        pathname: path.pathname || \"\",\r\n        search: path.search || \"\",\r\n        hash: path.hash || \"\"\r\n      };\r\n    },\r\n\r\n    push(to, state) {\r\n      action = Action.Push;\r\n      let nextLocation = createMemoryLocation(to, state);\r\n      index += 1;\r\n      entries.splice(index, entries.length, nextLocation);\r\n\r\n      if (v5Compat && listener) {\r\n        listener({\r\n          action,\r\n          location: nextLocation,\r\n          delta: 1\r\n        });\r\n      }\r\n    },\r\n\r\n    replace(to, state) {\r\n      action = Action.Replace;\r\n      let nextLocation = createMemoryLocation(to, state);\r\n      entries[index] = nextLocation;\r\n\r\n      if (v5Compat && listener) {\r\n        listener({\r\n          action,\r\n          location: nextLocation,\r\n          delta: 0\r\n        });\r\n      }\r\n    },\r\n\r\n    go(delta) {\r\n      action = Action.Pop;\r\n      let nextIndex = clampIndex(index + delta);\r\n      let nextLocation = entries[nextIndex];\r\n      index = nextIndex;\r\n\r\n      if (listener) {\r\n        listener({\r\n          action,\r\n          location: nextLocation,\r\n          delta\r\n        });\r\n      }\r\n    },\r\n\r\n    listen(fn) {\r\n      listener = fn;\r\n      return () => {\r\n        listener = null;\r\n      };\r\n    }\r\n\r\n  };\r\n  return history;\r\n}\r\n/**\r\n * Browser history stores the location in regular URLs. This is the standard for\r\n * most web apps, but it requires some configuration on the server to ensure you\r\n * serve the same app at multiple URLs.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\r\n */\r\n\r\nfunction createBrowserHistory(options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n\r\n  function createBrowserLocation(window, globalHistory) {\r\n    let {\r\n      pathname,\r\n      search,\r\n      hash\r\n    } = window.location;\r\n    return createLocation(\"\", {\r\n      pathname,\r\n      search,\r\n      hash\r\n    }, // state defaults to `null` because `window.history.state` does\r\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\r\n  }\r\n\r\n  function createBrowserHref(window, to) {\r\n    return typeof to === \"string\" ? to : createPath(to);\r\n  }\r\n\r\n  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\r\n}\r\n/**\r\n * Hash history stores the location in window.location.hash. This makes it ideal\r\n * for situations where you don't want to send the location to the server for\r\n * some reason, either because you do cannot configure it or the URL space is\r\n * reserved for something else.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\r\n */\r\n\r\nfunction createHashHistory(options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n\r\n  function createHashLocation(window, globalHistory) {\r\n    let {\r\n      pathname = \"/\",\r\n      search = \"\",\r\n      hash = \"\"\r\n    } = parsePath(window.location.hash.substr(1));\r\n    return createLocation(\"\", {\r\n      pathname,\r\n      search,\r\n      hash\r\n    }, // state defaults to `null` because `window.history.state` does\r\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\r\n  }\r\n\r\n  function createHashHref(window, to) {\r\n    let base = window.document.querySelector(\"base\");\r\n    let href = \"\";\r\n\r\n    if (base && base.getAttribute(\"href\")) {\r\n      let url = window.location.href;\r\n      let hashIndex = url.indexOf(\"#\");\r\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\r\n    }\r\n\r\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\r\n  }\r\n\r\n  function validateHashLocation(location, to) {\r\n    warning$1(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\r\n  }\r\n\r\n  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\r\n}\r\nfunction invariant(value, message) {\r\n  if (value === false || value === null || typeof value === \"undefined\") {\r\n    throw new Error(message);\r\n  }\r\n}\r\n\r\nfunction warning$1(cond, message) {\r\n  if (!cond) {\r\n    // eslint-disable-next-line no-console\r\n    if (typeof console !== \"undefined\") console.warn(message);\r\n\r\n    try {\r\n      // Welcome to debugging history!\r\n      //\r\n      // This error is thrown as a convenience so you can more easily\r\n      // find the source for a warning that appears in the console by\r\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\r\n      throw new Error(message); // eslint-disable-next-line no-empty\r\n    } catch (e) {}\r\n  }\r\n}\r\n\r\nfunction createKey() {\r\n  return Math.random().toString(36).substr(2, 8);\r\n}\r\n/**\r\n * For browser-based histories, we combine the state and key into an object\r\n */\r\n\r\n\r\nfunction getHistoryState(location, index) {\r\n  return {\r\n    usr: location.state,\r\n    key: location.key,\r\n    idx: index\r\n  };\r\n}\r\n/**\r\n * Creates a Location object with a unique key from the given Path\r\n */\r\n\r\n\r\nfunction createLocation(current, to, state, key) {\r\n  if (state === void 0) {\r\n    state = null;\r\n  }\r\n\r\n  let location = _extends({\r\n    pathname: typeof current === \"string\" ? current : current.pathname,\r\n    search: \"\",\r\n    hash: \"\"\r\n  }, typeof to === \"string\" ? parsePath(to) : to, {\r\n    state,\r\n    // TODO: This could be cleaned up.  push/replace should probably just take\r\n    // full Locations now and avoid the need to run through this flow at all\r\n    // But that's a pretty big refactor to the current test suite so going to\r\n    // keep as is for the time being and just let any incoming keys take precedence\r\n    key: to && to.key || key || createKey()\r\n  });\r\n\r\n  return location;\r\n}\r\n/**\r\n * Creates a string URL path from the given pathname, search, and hash components.\r\n */\r\n\r\nfunction createPath(_ref) {\r\n  let {\r\n    pathname = \"/\",\r\n    search = \"\",\r\n    hash = \"\"\r\n  } = _ref;\r\n  if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\r\n  if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\r\n  return pathname;\r\n}\r\n/**\r\n * Parses a string URL path into its separate pathname, search, and hash components.\r\n */\r\n\r\nfunction parsePath(path) {\r\n  let parsedPath = {};\r\n\r\n  if (path) {\r\n    let hashIndex = path.indexOf(\"#\");\r\n\r\n    if (hashIndex >= 0) {\r\n      parsedPath.hash = path.substr(hashIndex);\r\n      path = path.substr(0, hashIndex);\r\n    }\r\n\r\n    let searchIndex = path.indexOf(\"?\");\r\n\r\n    if (searchIndex >= 0) {\r\n      parsedPath.search = path.substr(searchIndex);\r\n      path = path.substr(0, searchIndex);\r\n    }\r\n\r\n    if (path) {\r\n      parsedPath.pathname = path;\r\n    }\r\n  }\r\n\r\n  return parsedPath;\r\n}\r\n\r\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\r\n  if (options === void 0) {\r\n    options = {};\r\n  }\r\n\r\n  let {\r\n    window = document.defaultView,\r\n    v5Compat = false\r\n  } = options;\r\n  let globalHistory = window.history;\r\n  let action = Action.Pop;\r\n  let listener = null;\r\n  let index = getIndex(); // Index should only be null when we initialize. If not, it's because the\r\n  // user called history.pushState or history.replaceState directly, in which\r\n  // case we should log a warning as it will result in bugs.\r\n\r\n  if (index == null) {\r\n    index = 0;\r\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\r\n      idx: index\r\n    }), \"\");\r\n  }\r\n\r\n  function getIndex() {\r\n    let state = globalHistory.state || {\r\n      idx: null\r\n    };\r\n    return state.idx;\r\n  }\r\n\r\n  function handlePop() {\r\n    action = Action.Pop;\r\n    let nextIndex = getIndex();\r\n    let delta = nextIndex == null ? null : nextIndex - index;\r\n    index = nextIndex;\r\n\r\n    if (listener) {\r\n      listener({\r\n        action,\r\n        location: history.location,\r\n        delta\r\n      });\r\n    }\r\n  }\r\n\r\n  function push(to, state) {\r\n    action = Action.Push;\r\n    let location = createLocation(history.location, to, state);\r\n    if (validateLocation) validateLocation(location, to);\r\n    index = getIndex() + 1;\r\n    let historyState = getHistoryState(location, index);\r\n    let url = history.createHref(location); // try...catch because iOS limits us to 100 pushState calls :/\r\n\r\n    try {\r\n      globalHistory.pushState(historyState, \"\", url);\r\n    } catch (error) {\r\n      // They are going to lose state here, but there is no real\r\n      // way to warn them about it since the page will refresh...\r\n      window.location.assign(url);\r\n    }\r\n\r\n    if (v5Compat && listener) {\r\n      listener({\r\n        action,\r\n        location: history.location,\r\n        delta: 1\r\n      });\r\n    }\r\n  }\r\n\r\n  function replace(to, state) {\r\n    action = Action.Replace;\r\n    let location = createLocation(history.location, to, state);\r\n    if (validateLocation) validateLocation(location, to);\r\n    index = getIndex();\r\n    let historyState = getHistoryState(location, index);\r\n    let url = history.createHref(location);\r\n    globalHistory.replaceState(historyState, \"\", url);\r\n\r\n    if (v5Compat && listener) {\r\n      listener({\r\n        action,\r\n        location: history.location,\r\n        delta: 0\r\n      });\r\n    }\r\n  }\r\n\r\n  function createURL(to) {\r\n    // window.location.origin is \"null\" (the literal string value) in Firefox\r\n    // under certain conditions, notably when serving from a local HTML file\r\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\r\n    let base = window.location.origin !== \"null\" ? window.location.origin : window.location.href;\r\n    let href = typeof to === \"string\" ? to : createPath(to);\r\n    invariant(base, \"No window.location.(origin|href) available to create URL for href: \" + href);\r\n    return new URL(href, base);\r\n  }\r\n\r\n  let history = {\r\n    get action() {\r\n      return action;\r\n    },\r\n\r\n    get location() {\r\n      return getLocation(window, globalHistory);\r\n    },\r\n\r\n    listen(fn) {\r\n      if (listener) {\r\n        throw new Error(\"A history only accepts one active listener\");\r\n      }\r\n\r\n      window.addEventListener(PopStateEventType, handlePop);\r\n      listener = fn;\r\n      return () => {\r\n        window.removeEventListener(PopStateEventType, handlePop);\r\n        listener = null;\r\n      };\r\n    },\r\n\r\n    createHref(to) {\r\n      return createHref(window, to);\r\n    },\r\n\r\n    createURL,\r\n\r\n    encodeLocation(to) {\r\n      // Encode a Location the same way window.location would\r\n      let url = createURL(to);\r\n      return {\r\n        pathname: url.pathname,\r\n        search: url.search,\r\n        hash: url.hash\r\n      };\r\n    },\r\n\r\n    push,\r\n    replace,\r\n\r\n    go(n) {\r\n      return globalHistory.go(n);\r\n    }\r\n\r\n  };\r\n  return history;\r\n} //#endregion\r\n\r\nvar ResultType;\r\n\r\n(function (ResultType) {\r\n  ResultType[\"data\"] = \"data\";\r\n  ResultType[\"deferred\"] = \"deferred\";\r\n  ResultType[\"redirect\"] = \"redirect\";\r\n  ResultType[\"error\"] = \"error\";\r\n})(ResultType || (ResultType = {}));\r\n\r\nfunction isIndexRoute(route) {\r\n  return route.index === true;\r\n} // Walk the route tree generating unique IDs where necessary so we are working\r\n// solely with AgnosticDataRouteObject's within the Router\r\n\r\n\r\nfunction convertRoutesToDataRoutes(routes, parentPath, allIds) {\r\n  if (parentPath === void 0) {\r\n    parentPath = [];\r\n  }\r\n\r\n  if (allIds === void 0) {\r\n    allIds = new Set();\r\n  }\r\n\r\n  return routes.map((route, index) => {\r\n    let treePath = [...parentPath, index];\r\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\r\n    invariant(route.index !== true || !route.children, \"Cannot specify children on an index route\");\r\n    invariant(!allIds.has(id), \"Found a route id collision on id \\\"\" + id + \"\\\".  Route \" + \"id's must be globally unique within Data Router usages\");\r\n    allIds.add(id);\r\n\r\n    if (isIndexRoute(route)) {\r\n      let indexRoute = _extends({}, route, {\r\n        id\r\n      });\r\n\r\n      return indexRoute;\r\n    } else {\r\n      let pathOrLayoutRoute = _extends({}, route, {\r\n        id,\r\n        children: route.children ? convertRoutesToDataRoutes(route.children, treePath, allIds) : undefined\r\n      });\r\n\r\n      return pathOrLayoutRoute;\r\n    }\r\n  });\r\n}\r\n/**\r\n * Matches the given routes to a location and returns the match data.\r\n *\r\n * @see https://reactrouter.com/utils/match-routes\r\n */\r\n\r\nfunction matchRoutes(routes, locationArg, basename) {\r\n  if (basename === void 0) {\r\n    basename = \"/\";\r\n  }\r\n\r\n  let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\r\n  let pathname = stripBasename(location.pathname || \"/\", basename);\r\n\r\n  if (pathname == null) {\r\n    return null;\r\n  }\r\n\r\n  let branches = flattenRoutes(routes);\r\n  rankRouteBranches(branches);\r\n  let matches = null;\r\n\r\n  for (let i = 0; matches == null && i < branches.length; ++i) {\r\n    matches = matchRouteBranch(branches[i], // Incoming pathnames are generally encoded from either window.location\r\n    // or from router.navigate, but we want to match against the unencoded\r\n    // paths in the route definitions.  Memory router locations won't be\r\n    // encoded here but there also shouldn't be anything to decode so this\r\n    // should be a safe operation.  This avoids needing matchRoutes to be\r\n    // history-aware.\r\n    safelyDecodeURI(pathname));\r\n  }\r\n\r\n  return matches;\r\n}\r\n\r\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\r\n  if (branches === void 0) {\r\n    branches = [];\r\n  }\r\n\r\n  if (parentsMeta === void 0) {\r\n    parentsMeta = [];\r\n  }\r\n\r\n  if (parentPath === void 0) {\r\n    parentPath = \"\";\r\n  }\r\n\r\n  let flattenRoute = (route, index, relativePath) => {\r\n    let meta = {\r\n      relativePath: relativePath === undefined ? route.path || \"\" : relativePath,\r\n      caseSensitive: route.caseSensitive === true,\r\n      childrenIndex: index,\r\n      route\r\n    };\r\n\r\n    if (meta.relativePath.startsWith(\"/\")) {\r\n      invariant(meta.relativePath.startsWith(parentPath), \"Absolute route path \\\"\" + meta.relativePath + \"\\\" nested under path \" + (\"\\\"\" + parentPath + \"\\\" is not valid. An absolute child route path \") + \"must start with the combined path of all its parent routes.\");\r\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\r\n    }\r\n\r\n    let path = joinPaths([parentPath, meta.relativePath]);\r\n    let routesMeta = parentsMeta.concat(meta); // Add the children before adding this route to the array so we traverse the\r\n    // route tree depth-first and child routes appear before their parents in\r\n    // the \"flattened\" version.\r\n\r\n    if (route.children && route.children.length > 0) {\r\n      invariant( // Our types know better, but runtime JS may not!\r\n      // @ts-expect-error\r\n      route.index !== true, \"Index routes must not have child routes. Please remove \" + (\"all child routes from route path \\\"\" + path + \"\\\".\"));\r\n      flattenRoutes(route.children, branches, routesMeta, path);\r\n    } // Routes without a path shouldn't ever match by themselves unless they are\r\n    // index routes, so don't add them to the list of possible branches.\r\n\r\n\r\n    if (route.path == null && !route.index) {\r\n      return;\r\n    }\r\n\r\n    branches.push({\r\n      path,\r\n      score: computeScore(path, route.index),\r\n      routesMeta\r\n    });\r\n  };\r\n\r\n  routes.forEach((route, index) => {\r\n    var _route$path;\r\n\r\n    // coarse-grain check for optional params\r\n    if (route.path === \"\" || !((_route$path = route.path) != null && _route$path.includes(\"?\"))) {\r\n      flattenRoute(route, index);\r\n    } else {\r\n      for (let exploded of explodeOptionalSegments(route.path)) {\r\n        flattenRoute(route, index, exploded);\r\n      }\r\n    }\r\n  });\r\n  return branches;\r\n}\r\n/**\r\n * Computes all combinations of optional path segments for a given path,\r\n * excluding combinations that are ambiguous and of lower priority.\r\n *\r\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\r\n * - `/one/three`\r\n * - `/one/:two/three`\r\n * - `/one/three/:four`\r\n * - `/one/three/:five`\r\n * - `/one/:two/three/:four`\r\n * - `/one/:two/three/:five`\r\n * - `/one/three/:four/:five`\r\n * - `/one/:two/three/:four/:five`\r\n */\r\n\r\n\r\nfunction explodeOptionalSegments(path) {\r\n  let segments = path.split(\"/\");\r\n  if (segments.length === 0) return [];\r\n  let [first, ...rest] = segments; // Optional path segments are denoted by a trailing `?`\r\n\r\n  let isOptional = first.endsWith(\"?\"); // Compute the corresponding required segment: `foo?` -> `foo`\r\n\r\n  let required = first.replace(/\\?$/, \"\");\r\n\r\n  if (rest.length === 0) {\r\n    // Intepret empty string as omitting an optional segment\r\n    // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\r\n    return isOptional ? [required, \"\"] : [required];\r\n  }\r\n\r\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\r\n  let result = []; // All child paths with the prefix.  Do this for all children before the\r\n  // optional version for all children so we get consistent ordering where the\r\n  // parent optional aspect is preferred as required.  Otherwise, we can get\r\n  // child sections interspersed where deeper optional segments are higher than\r\n  // parent optional segments, where for example, /:two would explodes _earlier_\r\n  // then /:one.  By always including the parent as required _for all children_\r\n  // first, we avoid this issue\r\n\r\n  result.push(...restExploded.map(subpath => subpath === \"\" ? required : [required, subpath].join(\"/\"))); // Then if this is an optional value, add all child versions without\r\n\r\n  if (isOptional) {\r\n    result.push(...restExploded);\r\n  } // for absolute paths, ensure `/` instead of empty segment\r\n\r\n\r\n  return result.map(exploded => path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\r\n}\r\n\r\nfunction rankRouteBranches(branches) {\r\n  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first\r\n  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));\r\n}\r\n\r\nconst paramRe = /^:\\w+$/;\r\nconst dynamicSegmentValue = 3;\r\nconst indexRouteValue = 2;\r\nconst emptySegmentValue = 1;\r\nconst staticSegmentValue = 10;\r\nconst splatPenalty = -2;\r\n\r\nconst isSplat = s => s === \"*\";\r\n\r\nfunction computeScore(path, index) {\r\n  let segments = path.split(\"/\");\r\n  let initialScore = segments.length;\r\n\r\n  if (segments.some(isSplat)) {\r\n    initialScore += splatPenalty;\r\n  }\r\n\r\n  if (index) {\r\n    initialScore += indexRouteValue;\r\n  }\r\n\r\n  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\r\n}\r\n\r\nfunction compareIndexes(a, b) {\r\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\r\n  return siblings ? // If two routes are siblings, we should try to match the earlier sibling\r\n  // first. This allows people to have fine-grained control over the matching\r\n  // behavior by simply putting routes with identical paths in the order they\r\n  // want them tried.\r\n  a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,\r\n  // so they sort equally.\r\n  0;\r\n}\r\n\r\nfunction matchRouteBranch(branch, pathname) {\r\n  let {\r\n    routesMeta\r\n  } = branch;\r\n  let matchedParams = {};\r\n  let matchedPathname = \"/\";\r\n  let matches = [];\r\n\r\n  for (let i = 0; i < routesMeta.length; ++i) {\r\n    let meta = routesMeta[i];\r\n    let end = i === routesMeta.length - 1;\r\n    let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\r\n    let match = matchPath({\r\n      path: meta.relativePath,\r\n      caseSensitive: meta.caseSensitive,\r\n      end\r\n    }, remainingPathname);\r\n    if (!match) return null;\r\n    Object.assign(matchedParams, match.params);\r\n    let route = meta.route;\r\n    matches.push({\r\n      // TODO: Can this as be avoided?\r\n      params: matchedParams,\r\n      pathname: joinPaths([matchedPathname, match.pathname]),\r\n      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),\r\n      route\r\n    });\r\n\r\n    if (match.pathnameBase !== \"/\") {\r\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\r\n    }\r\n  }\r\n\r\n  return matches;\r\n}\r\n/**\r\n * Returns a path with params interpolated.\r\n *\r\n * @see https://reactrouter.com/utils/generate-path\r\n */\r\n\r\n\r\nfunction generatePath(originalPath, params) {\r\n  if (params === void 0) {\r\n    params = {};\r\n  }\r\n\r\n  let path = originalPath;\r\n\r\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\r\n    warning(false, \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\r\n    path = path.replace(/\\*$/, \"/*\");\r\n  }\r\n\r\n  return path.replace(/^:(\\w+)(\\??)/g, (_, key, optional) => {\r\n    let param = params[key];\r\n\r\n    if (optional === \"?\") {\r\n      return param == null ? \"\" : param;\r\n    }\r\n\r\n    if (param == null) {\r\n      invariant(false, \"Missing \\\":\" + key + \"\\\" param\");\r\n    }\r\n\r\n    return param;\r\n  }).replace(/\\/:(\\w+)(\\??)/g, (_, key, optional) => {\r\n    let param = params[key];\r\n\r\n    if (optional === \"?\") {\r\n      return param == null ? \"\" : \"/\" + param;\r\n    }\r\n\r\n    if (param == null) {\r\n      invariant(false, \"Missing \\\":\" + key + \"\\\" param\");\r\n    }\r\n\r\n    return \"/\" + param;\r\n  }) // Remove any optional markers from optional static segments\r\n  .replace(/\\?/g, \"\").replace(/(\\/?)\\*/, (_, prefix, __, str) => {\r\n    const star = \"*\";\r\n\r\n    if (params[star] == null) {\r\n      // If no splat was provided, trim the trailing slash _unless_ it's\r\n      // the entire path\r\n      return str === \"/*\" ? \"/\" : \"\";\r\n    } // Apply the splat\r\n\r\n\r\n    return \"\" + prefix + params[star];\r\n  });\r\n}\r\n/**\r\n * Performs pattern matching on a URL pathname and returns information about\r\n * the match.\r\n *\r\n * @see https://reactrouter.com/utils/match-path\r\n */\r\n\r\nfunction matchPath(pattern, pathname) {\r\n  if (typeof pattern === \"string\") {\r\n    pattern = {\r\n      path: pattern,\r\n      caseSensitive: false,\r\n      end: true\r\n    };\r\n  }\r\n\r\n  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\r\n  let match = pathname.match(matcher);\r\n  if (!match) return null;\r\n  let matchedPathname = match[0];\r\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\r\n  let captureGroups = match.slice(1);\r\n  let params = paramNames.reduce((memo, paramName, index) => {\r\n    // We need to compute the pathnameBase here using the raw splat value\r\n    // instead of using params[\"*\"] later because it will be decoded then\r\n    if (paramName === \"*\") {\r\n      let splatValue = captureGroups[index] || \"\";\r\n      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\r\n    }\r\n\r\n    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || \"\", paramName);\r\n    return memo;\r\n  }, {});\r\n  return {\r\n    params,\r\n    pathname: matchedPathname,\r\n    pathnameBase,\r\n    pattern\r\n  };\r\n}\r\n\r\nfunction compilePath(path, caseSensitive, end) {\r\n  if (caseSensitive === void 0) {\r\n    caseSensitive = false;\r\n  }\r\n\r\n  if (end === void 0) {\r\n    end = true;\r\n  }\r\n\r\n  warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\r\n  let paramNames = [];\r\n  let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\r\n  .replace(/^\\/*/, \"/\") // Make sure it has a leading /\r\n  .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\r\n  .replace(/\\/:(\\w+)/g, (_, paramName) => {\r\n    paramNames.push(paramName);\r\n    return \"/([^\\\\/]+)\";\r\n  });\r\n\r\n  if (path.endsWith(\"*\")) {\r\n    paramNames.push(\"*\");\r\n    regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" // Already matched the initial /, just match the rest\r\n    : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\r\n  } else if (end) {\r\n    // When matching to the end, ignore trailing slashes\r\n    regexpSource += \"\\\\/*$\";\r\n  } else if (path !== \"\" && path !== \"/\") {\r\n    // If our path is non-empty and contains anything beyond an initial slash,\r\n    // then we have _some_ form of path in our regex so we should expect to\r\n    // match only if we find the end of this path segment.  Look for an optional\r\n    // non-captured trailing slash (to match a portion of the URL) or the end\r\n    // of the path (if we've matched to the end).  We used to do this with a\r\n    // word boundary but that gives false positives on routes like\r\n    // /user-preferences since `-` counts as a word boundary.\r\n    regexpSource += \"(?:(?=\\\\/|$))\";\r\n  } else ;\r\n\r\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\r\n  return [matcher, paramNames];\r\n}\r\n\r\nfunction safelyDecodeURI(value) {\r\n  try {\r\n    return decodeURI(value);\r\n  } catch (error) {\r\n    warning(false, \"The URL path \\\"\" + value + \"\\\" could not be decoded because it is is a \" + \"malformed URL segment. This is probably due to a bad percent \" + (\"encoding (\" + error + \").\"));\r\n    return value;\r\n  }\r\n}\r\n\r\nfunction safelyDecodeURIComponent(value, paramName) {\r\n  try {\r\n    return decodeURIComponent(value);\r\n  } catch (error) {\r\n    warning(false, \"The value for the URL param \\\"\" + paramName + \"\\\" will not be decoded because\" + (\" the string \\\"\" + value + \"\\\" is a malformed URL segment. This is probably\") + (\" due to a bad percent encoding (\" + error + \").\"));\r\n    return value;\r\n  }\r\n}\r\n/**\r\n * @private\r\n */\r\n\r\n\r\nfunction stripBasename(pathname, basename) {\r\n  if (basename === \"/\") return pathname;\r\n\r\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\r\n    return null;\r\n  } // We want to leave trailing slash behavior in the user's control, so if they\r\n  // specify a basename with a trailing slash, we should support it\r\n\r\n\r\n  let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\r\n  let nextChar = pathname.charAt(startIndex);\r\n\r\n  if (nextChar && nextChar !== \"/\") {\r\n    // pathname does not start with basename/\r\n    return null;\r\n  }\r\n\r\n  return pathname.slice(startIndex) || \"/\";\r\n}\r\n/**\r\n * @private\r\n */\r\n\r\nfunction warning(cond, message) {\r\n  if (!cond) {\r\n    // eslint-disable-next-line no-console\r\n    if (typeof console !== \"undefined\") console.warn(message);\r\n\r\n    try {\r\n      // Welcome to debugging @remix-run/router!\r\n      //\r\n      // This error is thrown as a convenience so you can more easily\r\n      // find the source for a warning that appears in the console by\r\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\r\n      throw new Error(message); // eslint-disable-next-line no-empty\r\n    } catch (e) {}\r\n  }\r\n}\r\n/**\r\n * Returns a resolved path object relative to the given pathname.\r\n *\r\n * @see https://reactrouter.com/utils/resolve-path\r\n */\r\n\r\nfunction resolvePath(to, fromPathname) {\r\n  if (fromPathname === void 0) {\r\n    fromPathname = \"/\";\r\n  }\r\n\r\n  let {\r\n    pathname: toPathname,\r\n    search = \"\",\r\n    hash = \"\"\r\n  } = typeof to === \"string\" ? parsePath(to) : to;\r\n  let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\r\n  return {\r\n    pathname,\r\n    search: normalizeSearch(search),\r\n    hash: normalizeHash(hash)\r\n  };\r\n}\r\n\r\nfunction resolvePathname(relativePath, fromPathname) {\r\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\r\n  let relativeSegments = relativePath.split(\"/\");\r\n  relativeSegments.forEach(segment => {\r\n    if (segment === \"..\") {\r\n      // Keep the root \"\" segment so the pathname starts at /\r\n      if (segments.length > 1) segments.pop();\r\n    } else if (segment !== \".\") {\r\n      segments.push(segment);\r\n    }\r\n  });\r\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\r\n}\r\n\r\nfunction getInvalidPathError(char, field, dest, path) {\r\n  return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + \"a string in <Link to=\\\"...\\\"> and the router will parse it for you.\";\r\n}\r\n/**\r\n * @private\r\n *\r\n * When processing relative navigation we want to ignore ancestor routes that\r\n * do not contribute to the path, such that index/pathless layout routes don't\r\n * interfere.\r\n *\r\n * For example, when moving a route element into an index route and/or a\r\n * pathless layout route, relative link behavior contained within should stay\r\n * the same.  Both of the following examples should link back to the root:\r\n *\r\n *   <Route path=\"/\">\r\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\r\n *   </Route>\r\n *\r\n *   <Route path=\"/\">\r\n *     <Route path=\"accounts\">\r\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\r\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\r\n *       </Route\r\n *     </Route>\r\n *   </Route>\r\n */\r\n\r\n\r\nfunction getPathContributingMatches(matches) {\r\n  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);\r\n}\r\n/**\r\n * @private\r\n */\r\n\r\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\r\n  if (isPathRelative === void 0) {\r\n    isPathRelative = false;\r\n  }\r\n\r\n  let to;\r\n\r\n  if (typeof toArg === \"string\") {\r\n    to = parsePath(toArg);\r\n  } else {\r\n    to = _extends({}, toArg);\r\n    invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\r\n    invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\r\n    invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\r\n  }\r\n\r\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\r\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\r\n  let from; // Routing is relative to the current pathname if explicitly requested.\r\n  //\r\n  // If a pathname is explicitly provided in `to`, it should be relative to the\r\n  // route context. This is explained in `Note on `<Link to>` values` in our\r\n  // migration guide from v5 as a means of disambiguation between `to` values\r\n  // that begin with `/` and those that do not. However, this is problematic for\r\n  // `to` values that do not provide a pathname. `to` can simply be a search or\r\n  // hash string, in which case we should assume that the navigation is relative\r\n  // to the current location's pathname and *not* the route pathname.\r\n\r\n  if (isPathRelative || toPathname == null) {\r\n    from = locationPathname;\r\n  } else {\r\n    let routePathnameIndex = routePathnames.length - 1;\r\n\r\n    if (toPathname.startsWith(\"..\")) {\r\n      let toSegments = toPathname.split(\"/\"); // Each leading .. segment means \"go up one route\" instead of \"go up one\r\n      // URL segment\".  This is a key difference from how <a href> works and a\r\n      // major reason we call this a \"to\" value instead of a \"href\".\r\n\r\n      while (toSegments[0] === \"..\") {\r\n        toSegments.shift();\r\n        routePathnameIndex -= 1;\r\n      }\r\n\r\n      to.pathname = toSegments.join(\"/\");\r\n    } // If there are more \"..\" segments than parent routes, resolve relative to\r\n    // the root / URL.\r\n\r\n\r\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\r\n  }\r\n\r\n  let path = resolvePath(to, from); // Ensure the pathname has a trailing slash if the original \"to\" had one\r\n\r\n  let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\"); // Or if this was a link to the current path which has a trailing slash\r\n\r\n  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\r\n\r\n  if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\r\n    path.pathname += \"/\";\r\n  }\r\n\r\n  return path;\r\n}\r\n/**\r\n * @private\r\n */\r\n\r\nfunction getToPathname(to) {\r\n  // Empty strings should be treated the same as / paths\r\n  return to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? parsePath(to).pathname : to.pathname;\r\n}\r\n/**\r\n * @private\r\n */\r\n\r\nconst joinPaths = paths => paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\r\n/**\r\n * @private\r\n */\r\n\r\nconst normalizePathname = pathname => pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\r\n/**\r\n * @private\r\n */\r\n\r\nconst normalizeSearch = search => !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\r\n/**\r\n * @private\r\n */\r\n\r\nconst normalizeHash = hash => !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\r\n/**\r\n * This is a shortcut for creating `application/json` responses. Converts `data`\r\n * to JSON and sets the `Content-Type` header.\r\n */\r\n\r\nconst json = function json(data, init) {\r\n  if (init === void 0) {\r\n    init = {};\r\n  }\r\n\r\n  let responseInit = typeof init === \"number\" ? {\r\n    status: init\r\n  } : init;\r\n  let headers = new Headers(responseInit.headers);\r\n\r\n  if (!headers.has(\"Content-Type\")) {\r\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\r\n  }\r\n\r\n  return new Response(JSON.stringify(data), _extends({}, responseInit, {\r\n    headers\r\n  }));\r\n};\r\nclass AbortedDeferredError extends Error {}\r\nclass DeferredData {\r\n  constructor(data, responseInit) {\r\n    this.pendingKeysSet = new Set();\r\n    this.subscribers = new Set();\r\n    this.deferredKeys = [];\r\n    invariant(data && typeof data === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\"); // Set up an AbortController + Promise we can race against to exit early\r\n    // cancellation\r\n\r\n    let reject;\r\n    this.abortPromise = new Promise((_, r) => reject = r);\r\n    this.controller = new AbortController();\r\n\r\n    let onAbort = () => reject(new AbortedDeferredError(\"Deferred data aborted\"));\r\n\r\n    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener(\"abort\", onAbort);\r\n\r\n    this.controller.signal.addEventListener(\"abort\", onAbort);\r\n    this.data = Object.entries(data).reduce((acc, _ref) => {\r\n      let [key, value] = _ref;\r\n      return Object.assign(acc, {\r\n        [key]: this.trackPromise(key, value)\r\n      });\r\n    }, {});\r\n\r\n    if (this.done) {\r\n      // All incoming values were resolved\r\n      this.unlistenAbortSignal();\r\n    }\r\n\r\n    this.init = responseInit;\r\n  }\r\n\r\n  trackPromise(key, value) {\r\n    if (!(value instanceof Promise)) {\r\n      return value;\r\n    }\r\n\r\n    this.deferredKeys.push(key);\r\n    this.pendingKeysSet.add(key); // We store a little wrapper promise that will be extended with\r\n    // _data/_error props upon resolve/reject\r\n\r\n    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, null, data), error => this.onSettle(promise, key, error)); // Register rejection listeners to avoid uncaught promise rejections on\r\n    // errors or aborted deferred values\r\n\r\n    promise.catch(() => {});\r\n    Object.defineProperty(promise, \"_tracked\", {\r\n      get: () => true\r\n    });\r\n    return promise;\r\n  }\r\n\r\n  onSettle(promise, key, error, data) {\r\n    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\r\n      this.unlistenAbortSignal();\r\n      Object.defineProperty(promise, \"_error\", {\r\n        get: () => error\r\n      });\r\n      return Promise.reject(error);\r\n    }\r\n\r\n    this.pendingKeysSet.delete(key);\r\n\r\n    if (this.done) {\r\n      // Nothing left to abort!\r\n      this.unlistenAbortSignal();\r\n    }\r\n\r\n    if (error) {\r\n      Object.defineProperty(promise, \"_error\", {\r\n        get: () => error\r\n      });\r\n      this.emit(false, key);\r\n      return Promise.reject(error);\r\n    }\r\n\r\n    Object.defineProperty(promise, \"_data\", {\r\n      get: () => data\r\n    });\r\n    this.emit(false, key);\r\n    return data;\r\n  }\r\n\r\n  emit(aborted, settledKey) {\r\n    this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));\r\n  }\r\n\r\n  subscribe(fn) {\r\n    this.subscribers.add(fn);\r\n    return () => this.subscribers.delete(fn);\r\n  }\r\n\r\n  cancel() {\r\n    this.controller.abort();\r\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\r\n    this.emit(true);\r\n  }\r\n\r\n  async resolveData(signal) {\r\n    let aborted = false;\r\n\r\n    if (!this.done) {\r\n      let onAbort = () => this.cancel();\r\n\r\n      signal.addEventListener(\"abort\", onAbort);\r\n      aborted = await new Promise(resolve => {\r\n        this.subscribe(aborted => {\r\n          signal.removeEventListener(\"abort\", onAbort);\r\n\r\n          if (aborted || this.done) {\r\n            resolve(aborted);\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    return aborted;\r\n  }\r\n\r\n  get done() {\r\n    return this.pendingKeysSet.size === 0;\r\n  }\r\n\r\n  get unwrappedData() {\r\n    invariant(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\r\n    return Object.entries(this.data).reduce((acc, _ref2) => {\r\n      let [key, value] = _ref2;\r\n      return Object.assign(acc, {\r\n        [key]: unwrapTrackedPromise(value)\r\n      });\r\n    }, {});\r\n  }\r\n\r\n  get pendingKeys() {\r\n    return Array.from(this.pendingKeysSet);\r\n  }\r\n\r\n}\r\n\r\nfunction isTrackedPromise(value) {\r\n  return value instanceof Promise && value._tracked === true;\r\n}\r\n\r\nfunction unwrapTrackedPromise(value) {\r\n  if (!isTrackedPromise(value)) {\r\n    return value;\r\n  }\r\n\r\n  if (value._error) {\r\n    throw value._error;\r\n  }\r\n\r\n  return value._data;\r\n}\r\n\r\nconst defer = function defer(data, init) {\r\n  if (init === void 0) {\r\n    init = {};\r\n  }\r\n\r\n  let responseInit = typeof init === \"number\" ? {\r\n    status: init\r\n  } : init;\r\n  return new DeferredData(data, responseInit);\r\n};\r\n/**\r\n * A redirect response. Sets the status code and the `Location` header.\r\n * Defaults to \"302 Found\".\r\n */\r\n\r\nconst redirect = function redirect(url, init) {\r\n  if (init === void 0) {\r\n    init = 302;\r\n  }\r\n\r\n  let responseInit = init;\r\n\r\n  if (typeof responseInit === \"number\") {\r\n    responseInit = {\r\n      status: responseInit\r\n    };\r\n  } else if (typeof responseInit.status === \"undefined\") {\r\n    responseInit.status = 302;\r\n  }\r\n\r\n  let headers = new Headers(responseInit.headers);\r\n  headers.set(\"Location\", url);\r\n  return new Response(null, _extends({}, responseInit, {\r\n    headers\r\n  }));\r\n};\r\n/**\r\n * @private\r\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\r\n */\r\n\r\nclass ErrorResponse {\r\n  constructor(status, statusText, data, internal) {\r\n    if (internal === void 0) {\r\n      internal = false;\r\n    }\r\n\r\n    this.status = status;\r\n    this.statusText = statusText || \"\";\r\n    this.internal = internal;\r\n\r\n    if (data instanceof Error) {\r\n      this.data = data.toString();\r\n      this.error = data;\r\n    } else {\r\n      this.data = data;\r\n    }\r\n  }\r\n\r\n}\r\n/**\r\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\r\n * Response thrown from an action/loader\r\n */\r\n\r\nfunction isRouteErrorResponse(error) {\r\n  return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\r\n}\r\n\r\nconst validMutationMethodsArr = [\"post\", \"put\", \"patch\", \"delete\"];\r\nconst validMutationMethods = new Set(validMutationMethodsArr);\r\nconst validRequestMethodsArr = [\"get\", ...validMutationMethodsArr];\r\nconst validRequestMethods = new Set(validRequestMethodsArr);\r\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\r\nconst redirectPreserveMethodStatusCodes = new Set([307, 308]);\r\nconst IDLE_NAVIGATION = {\r\n  state: \"idle\",\r\n  location: undefined,\r\n  formMethod: undefined,\r\n  formAction: undefined,\r\n  formEncType: undefined,\r\n  formData: undefined\r\n};\r\nconst IDLE_FETCHER = {\r\n  state: \"idle\",\r\n  data: undefined,\r\n  formMethod: undefined,\r\n  formAction: undefined,\r\n  formEncType: undefined,\r\n  formData: undefined\r\n};\r\nconst IDLE_BLOCKER = {\r\n  state: \"unblocked\",\r\n  proceed: undefined,\r\n  reset: undefined,\r\n  location: undefined\r\n};\r\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\r\nconst isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\r\nconst isServer = !isBrowser; //#endregion\r\n////////////////////////////////////////////////////////////////////////////////\r\n//#region createRouter\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n/**\r\n * Create a router and listen to history POP navigations\r\n */\r\n\r\nfunction createRouter(init) {\r\n  invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\r\n  let dataRoutes = convertRoutesToDataRoutes(init.routes); // Cleanup function for history\r\n\r\n  let unlistenHistory = null; // Externally-provided functions to call on all state changes\r\n\r\n  let subscribers = new Set(); // Externally-provided object to hold scroll restoration locations during routing\r\n\r\n  let savedScrollPositions = null; // Externally-provided function to get scroll restoration keys\r\n\r\n  let getScrollRestorationKey = null; // Externally-provided function to get current scroll position\r\n\r\n  let getScrollPosition = null; // One-time flag to control the initial hydration scroll restoration.  Because\r\n  // we don't get the saved positions from <ScrollRestoration /> until _after_\r\n  // the initial render, we need to manually trigger a separate updateState to\r\n  // send along the restoreScrollPosition\r\n  // Set to true if we have `hydrationData` since we assume we were SSR'd and that\r\n  // SSR did the initial scroll restoration.\r\n\r\n  let initialScrollRestored = init.hydrationData != null;\r\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, init.basename);\r\n  let initialErrors = null;\r\n\r\n  if (initialMatches == null) {\r\n    // If we do not match a user-provided-route, fall back to the root\r\n    // to allow the error boundary to take over\r\n    let error = getInternalRouterError(404, {\r\n      pathname: init.history.location.pathname\r\n    });\r\n    let {\r\n      matches,\r\n      route\r\n    } = getShortCircuitMatches(dataRoutes);\r\n    initialMatches = matches;\r\n    initialErrors = {\r\n      [route.id]: error\r\n    };\r\n  }\r\n\r\n  let initialized = !initialMatches.some(m => m.route.loader) || init.hydrationData != null;\r\n  let router;\r\n  let state = {\r\n    historyAction: init.history.action,\r\n    location: init.history.location,\r\n    matches: initialMatches,\r\n    initialized,\r\n    navigation: IDLE_NAVIGATION,\r\n    // Don't restore on initial updateState() if we were SSR'd\r\n    restoreScrollPosition: init.hydrationData != null ? false : null,\r\n    preventScrollReset: false,\r\n    revalidation: \"idle\",\r\n    loaderData: init.hydrationData && init.hydrationData.loaderData || {},\r\n    actionData: init.hydrationData && init.hydrationData.actionData || null,\r\n    errors: init.hydrationData && init.hydrationData.errors || initialErrors,\r\n    fetchers: new Map(),\r\n    blockers: new Map()\r\n  }; // -- Stateful internal variables to manage navigations --\r\n  // Current navigation in progress (to be committed in completeNavigation)\r\n\r\n  let pendingAction = Action.Pop; // Should the current navigation prevent the scroll reset if scroll cannot\r\n  // be restored?\r\n\r\n  let pendingPreventScrollReset = false; // AbortController for the active navigation\r\n\r\n  let pendingNavigationController; // We use this to avoid touching history in completeNavigation if a\r\n  // revalidation is entirely uninterrupted\r\n\r\n  let isUninterruptedRevalidation = false; // Use this internal flag to force revalidation of all loaders:\r\n  //  - submissions (completed or interrupted)\r\n  //  - useRevalidate()\r\n  //  - X-Remix-Revalidate (from redirect)\r\n\r\n  let isRevalidationRequired = false; // Use this internal array to capture routes that require revalidation due\r\n  // to a cancelled deferred on action submission\r\n\r\n  let cancelledDeferredRoutes = []; // Use this internal array to capture fetcher loads that were cancelled by an\r\n  // action navigation and require revalidation\r\n\r\n  let cancelledFetcherLoads = []; // AbortControllers for any in-flight fetchers\r\n\r\n  let fetchControllers = new Map(); // Track loads based on the order in which they started\r\n\r\n  let incrementingLoadId = 0; // Track the outstanding pending navigation data load to be compared against\r\n  // the globally incrementing load when a fetcher load lands after a completed\r\n  // navigation\r\n\r\n  let pendingNavigationLoadId = -1; // Fetchers that triggered data reloads as a result of their actions\r\n\r\n  let fetchReloadIds = new Map(); // Fetchers that triggered redirect navigations from their actions\r\n\r\n  let fetchRedirectIds = new Set(); // Most recent href/match for fetcher.load calls for fetchers\r\n\r\n  let fetchLoadMatches = new Map(); // Store DeferredData instances for active route matches.  When a\r\n  // route loader returns defer() we stick one in here.  Then, when a nested\r\n  // promise resolves we update loaderData.  If a new navigation starts we\r\n  // cancel active deferreds for eliminated routes.\r\n\r\n  let activeDeferreds = new Map(); // Store blocker functions in a separate Map outside of router state since\r\n  // we don't need to update UI state if they change\r\n\r\n  let blockerFunctions = new Map(); // Flag to ignore the next history update, so we can revert the URL change on\r\n  // a POP navigation that was blocked by the user without touching router state\r\n\r\n  let ignoreNextHistoryUpdate = false; // Initialize the router, all side effects should be kicked off from here.\r\n  // Implemented as a Fluent API for ease of:\r\n  //   let router = createRouter(init).initialize();\r\n\r\n  function initialize() {\r\n    // If history informs us of a POP navigation, start the navigation but do not update\r\n    // state.  We'll update our own state once the navigation completes\r\n    unlistenHistory = init.history.listen(_ref => {\r\n      let {\r\n        action: historyAction,\r\n        location,\r\n        delta\r\n      } = _ref;\r\n\r\n      // Ignore this event if it was just us resetting the URL from a\r\n      // blocked POP navigation\r\n      if (ignoreNextHistoryUpdate) {\r\n        ignoreNextHistoryUpdate = false;\r\n        return;\r\n      }\r\n\r\n      warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location \" + \"that was not created by @remix-run/router. This will fail silently in \" + \"production. This can happen if you are navigating outside the router \" + \"via `window.history.pushState`/`window.location.hash` instead of using \" + \"router navigation APIs.  This can also happen if you are using \" + \"createHashRouter and the user manually changes the URL.\");\r\n      let blockerKey = shouldBlockNavigation({\r\n        currentLocation: state.location,\r\n        nextLocation: location,\r\n        historyAction\r\n      });\r\n\r\n      if (blockerKey && delta != null) {\r\n        // Restore the URL to match the current UI, but don't update router state\r\n        ignoreNextHistoryUpdate = true;\r\n        init.history.go(delta * -1); // Put the blocker into a blocked state\r\n\r\n        updateBlocker(blockerKey, {\r\n          state: \"blocked\",\r\n          location,\r\n\r\n          proceed() {\r\n            updateBlocker(blockerKey, {\r\n              state: \"proceeding\",\r\n              proceed: undefined,\r\n              reset: undefined,\r\n              location\r\n            }); // Re-do the same POP navigation we just blocked\r\n\r\n            init.history.go(delta);\r\n          },\r\n\r\n          reset() {\r\n            deleteBlocker(blockerKey);\r\n            updateState({\r\n              blockers: new Map(router.state.blockers)\r\n            });\r\n          }\r\n\r\n        });\r\n        return;\r\n      }\r\n\r\n      return startNavigation(historyAction, location);\r\n    }); // Kick off initial data load if needed.  Use Pop to avoid modifying history\r\n\r\n    if (!state.initialized) {\r\n      startNavigation(Action.Pop, state.location);\r\n    }\r\n\r\n    return router;\r\n  } // Clean up a router and it's side effects\r\n\r\n\r\n  function dispose() {\r\n    if (unlistenHistory) {\r\n      unlistenHistory();\r\n    }\r\n\r\n    subscribers.clear();\r\n    pendingNavigationController && pendingNavigationController.abort();\r\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\r\n    state.blockers.forEach((_, key) => deleteBlocker(key));\r\n  } // Subscribe to state updates for the router\r\n\r\n\r\n  function subscribe(fn) {\r\n    subscribers.add(fn);\r\n    return () => subscribers.delete(fn);\r\n  } // Update our state and notify the calling context of the change\r\n\r\n\r\n  function updateState(newState) {\r\n    state = _extends({}, state, newState);\r\n    subscribers.forEach(subscriber => subscriber(state));\r\n  } // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\r\n  // and setting state.[historyAction/location/matches] to the new route.\r\n  // - Location is a required param\r\n  // - Navigation will always be set to IDLE_NAVIGATION\r\n  // - Can pass any other state in newState\r\n\r\n\r\n  function completeNavigation(location, newState) {\r\n    var _location$state, _location$state2;\r\n\r\n    // Deduce if we're in a loading/actionReload state:\r\n    // - We have committed actionData in the store\r\n    // - The current navigation was a mutation submission\r\n    // - We're past the submitting state and into the loading state\r\n    // - The location being loaded is not the result of a redirect\r\n    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\r\n    let actionData;\r\n\r\n    if (newState.actionData) {\r\n      if (Object.keys(newState.actionData).length > 0) {\r\n        actionData = newState.actionData;\r\n      } else {\r\n        // Empty actionData -> clear prior actionData due to an action error\r\n        actionData = null;\r\n      }\r\n    } else if (isActionReload) {\r\n      // Keep the current data if we're wrapping up the action reload\r\n      actionData = state.actionData;\r\n    } else {\r\n      // Clear actionData on any other completed navigations\r\n      actionData = null;\r\n    } // Always preserve any existing loaderData from re-used routes\r\n\r\n\r\n    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData; // On a successful navigation we can assume we got through all blockers\r\n    // so we can start fresh\r\n\r\n    for (let [key] of blockerFunctions) {\r\n      deleteBlocker(key);\r\n    } // Always respect the user flag.  Otherwise don't reset on mutation\r\n    // submission navigations unless they redirect\r\n\r\n\r\n    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\r\n    updateState(_extends({}, newState, {\r\n      actionData,\r\n      loaderData,\r\n      historyAction: pendingAction,\r\n      location,\r\n      initialized: true,\r\n      navigation: IDLE_NAVIGATION,\r\n      revalidation: \"idle\",\r\n      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\r\n      preventScrollReset,\r\n      blockers: new Map(state.blockers)\r\n    }));\r\n\r\n    if (isUninterruptedRevalidation) ; else if (pendingAction === Action.Pop) ; else if (pendingAction === Action.Push) {\r\n      init.history.push(location, location.state);\r\n    } else if (pendingAction === Action.Replace) {\r\n      init.history.replace(location, location.state);\r\n    } // Reset stateful navigation vars\r\n\r\n\r\n    pendingAction = Action.Pop;\r\n    pendingPreventScrollReset = false;\r\n    isUninterruptedRevalidation = false;\r\n    isRevalidationRequired = false;\r\n    cancelledDeferredRoutes = [];\r\n    cancelledFetcherLoads = [];\r\n  } // Trigger a navigation event, which can either be a numerical POP or a PUSH\r\n  // replace with an optional submission\r\n\r\n\r\n  async function navigate(to, opts) {\r\n    if (typeof to === \"number\") {\r\n      init.history.go(to);\r\n      return;\r\n    }\r\n\r\n    let {\r\n      path,\r\n      submission,\r\n      error\r\n    } = normalizeNavigateOptions(to, opts);\r\n    let currentLocation = state.location;\r\n    let nextLocation = createLocation(state.location, path, opts && opts.state); // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\r\n    // URL from window.location, so we need to encode it here so the behavior\r\n    // remains the same as POP and non-data-router usages.  new URL() does all\r\n    // the same encoding we'd get from a history.pushState/window.location read\r\n    // without having to touch history\r\n\r\n    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\r\n    let userReplace = opts && opts.replace != null ? opts.replace : undefined;\r\n    let historyAction = Action.Push;\r\n\r\n    if (userReplace === true) {\r\n      historyAction = Action.Replace;\r\n    } else if (userReplace === false) ; else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\r\n      // By default on submissions to the current location we REPLACE so that\r\n      // users don't have to double-click the back button to get to the prior\r\n      // location.  If the user redirects to a different location from the\r\n      // action/loader this will be ignored and the redirect will be a PUSH\r\n      historyAction = Action.Replace;\r\n    }\r\n\r\n    let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : undefined;\r\n    let blockerKey = shouldBlockNavigation({\r\n      currentLocation,\r\n      nextLocation,\r\n      historyAction\r\n    });\r\n\r\n    if (blockerKey) {\r\n      // Put the blocker into a blocked state\r\n      updateBlocker(blockerKey, {\r\n        state: \"blocked\",\r\n        location: nextLocation,\r\n\r\n        proceed() {\r\n          updateBlocker(blockerKey, {\r\n            state: \"proceeding\",\r\n            proceed: undefined,\r\n            reset: undefined,\r\n            location: nextLocation\r\n          }); // Send the same navigation through\r\n\r\n          navigate(to, opts);\r\n        },\r\n\r\n        reset() {\r\n          deleteBlocker(blockerKey);\r\n          updateState({\r\n            blockers: new Map(state.blockers)\r\n          });\r\n        }\r\n\r\n      });\r\n      return;\r\n    }\r\n\r\n    return await startNavigation(historyAction, nextLocation, {\r\n      submission,\r\n      // Send through the formData serialization error if we have one so we can\r\n      // render at the right error boundary after we match routes\r\n      pendingError: error,\r\n      preventScrollReset,\r\n      replace: opts && opts.replace\r\n    });\r\n  } // Revalidate all current loaders.  If a navigation is in progress or if this\r\n  // is interrupted by a navigation, allow this to \"succeed\" by calling all\r\n  // loaders during the next loader round\r\n\r\n\r\n  function revalidate() {\r\n    interruptActiveLoads();\r\n    updateState({\r\n      revalidation: \"loading\"\r\n    }); // If we're currently submitting an action, we don't need to start a new\r\n    // navigation, we'll just let the follow up loader execution call all loaders\r\n\r\n    if (state.navigation.state === \"submitting\") {\r\n      return;\r\n    } // If we're currently in an idle state, start a new navigation for the current\r\n    // action/location and mark it as uninterrupted, which will skip the history\r\n    // update in completeNavigation\r\n\r\n\r\n    if (state.navigation.state === \"idle\") {\r\n      startNavigation(state.historyAction, state.location, {\r\n        startUninterruptedRevalidation: true\r\n      });\r\n      return;\r\n    } // Otherwise, if we're currently in a loading state, just start a new\r\n    // navigation to the navigation.location but do not trigger an uninterrupted\r\n    // revalidation so that history correctly updates once the navigation completes\r\n\r\n\r\n    startNavigation(pendingAction || state.historyAction, state.navigation.location, {\r\n      overrideNavigation: state.navigation\r\n    });\r\n  } // Start a navigation to the given action/location.  Can optionally provide a\r\n  // overrideNavigation which will override the normalLoad in the case of a redirect\r\n  // navigation\r\n\r\n\r\n  async function startNavigation(historyAction, location, opts) {\r\n    // Abort any in-progress navigations and start a new one. Unset any ongoing\r\n    // uninterrupted revalidations unless told otherwise, since we want this\r\n    // new navigation to update history normally\r\n    pendingNavigationController && pendingNavigationController.abort();\r\n    pendingNavigationController = null;\r\n    pendingAction = historyAction;\r\n    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true; // Save the current scroll position every time we start a new navigation,\r\n    // and track whether we should reset scroll on completion\r\n\r\n    saveScrollPosition(state.location, state.matches);\r\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\r\n    let loadingNavigation = opts && opts.overrideNavigation;\r\n    let matches = matchRoutes(dataRoutes, location, init.basename); // Short circuit with a 404 on the root error boundary if we match nothing\r\n\r\n    if (!matches) {\r\n      let error = getInternalRouterError(404, {\r\n        pathname: location.pathname\r\n      });\r\n      let {\r\n        matches: notFoundMatches,\r\n        route\r\n      } = getShortCircuitMatches(dataRoutes); // Cancel all pending deferred on 404s since we don't keep any routes\r\n\r\n      cancelActiveDeferreds();\r\n      completeNavigation(location, {\r\n        matches: notFoundMatches,\r\n        loaderData: {},\r\n        errors: {\r\n          [route.id]: error\r\n        }\r\n      });\r\n      return;\r\n    } // Short circuit if it's only a hash change and not a mutation submission\r\n    // For example, on /page#hash and submit a <Form method=\"post\"> which will\r\n    // default to a navigation to /page\r\n\r\n\r\n    if (isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\r\n      completeNavigation(location, {\r\n        matches\r\n      });\r\n      return;\r\n    } // Create a controller/Request for this navigation\r\n\r\n\r\n    pendingNavigationController = new AbortController();\r\n    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\r\n    let pendingActionData;\r\n    let pendingError;\r\n\r\n    if (opts && opts.pendingError) {\r\n      // If we have a pendingError, it means the user attempted a GET submission\r\n      // with binary FormData so assign here and skip to handleLoaders.  That\r\n      // way we handle calling loaders above the boundary etc.  It's not really\r\n      // different from an actionError in that sense.\r\n      pendingError = {\r\n        [findNearestBoundary(matches).route.id]: opts.pendingError\r\n      };\r\n    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\r\n      // Call action if we received an action submission\r\n      let actionOutput = await handleAction(request, location, opts.submission, matches, {\r\n        replace: opts.replace\r\n      });\r\n\r\n      if (actionOutput.shortCircuited) {\r\n        return;\r\n      }\r\n\r\n      pendingActionData = actionOutput.pendingActionData;\r\n      pendingError = actionOutput.pendingActionError;\r\n\r\n      let navigation = _extends({\r\n        state: \"loading\",\r\n        location\r\n      }, opts.submission);\r\n\r\n      loadingNavigation = navigation; // Create a GET request for the loaders\r\n\r\n      request = new Request(request.url, {\r\n        signal: request.signal\r\n      });\r\n    } // Call loaders\r\n\r\n\r\n    let {\r\n      shortCircuited,\r\n      loaderData,\r\n      errors\r\n    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.replace, pendingActionData, pendingError);\r\n\r\n    if (shortCircuited) {\r\n      return;\r\n    } // Clean up now that the action/loaders have completed.  Don't clean up if\r\n    // we short circuited because pendingNavigationController will have already\r\n    // been assigned to a new controller for the next navigation\r\n\r\n\r\n    pendingNavigationController = null;\r\n    completeNavigation(location, _extends({\r\n      matches\r\n    }, pendingActionData ? {\r\n      actionData: pendingActionData\r\n    } : {}, {\r\n      loaderData,\r\n      errors\r\n    }));\r\n  } // Call the action matched by the leaf route for this navigation and handle\r\n  // redirects/errors\r\n\r\n\r\n  async function handleAction(request, location, submission, matches, opts) {\r\n    interruptActiveLoads(); // Put us in a submitting state\r\n\r\n    let navigation = _extends({\r\n      state: \"submitting\",\r\n      location\r\n    }, submission);\r\n\r\n    updateState({\r\n      navigation\r\n    }); // Call our action and get the result\r\n\r\n    let result;\r\n    let actionMatch = getTargetMatch(matches, location);\r\n\r\n    if (!actionMatch.route.action) {\r\n      result = {\r\n        type: ResultType.error,\r\n        error: getInternalRouterError(405, {\r\n          method: request.method,\r\n          pathname: location.pathname,\r\n          routeId: actionMatch.route.id\r\n        })\r\n      };\r\n    } else {\r\n      result = await callLoaderOrAction(\"action\", request, actionMatch, matches, router.basename);\r\n\r\n      if (request.signal.aborted) {\r\n        return {\r\n          shortCircuited: true\r\n        };\r\n      }\r\n    }\r\n\r\n    if (isRedirectResult(result)) {\r\n      let replace;\r\n\r\n      if (opts && opts.replace != null) {\r\n        replace = opts.replace;\r\n      } else {\r\n        // If the user didn't explicity indicate replace behavior, replace if\r\n        // we redirected to the exact same location we're currently at to avoid\r\n        // double back-buttons\r\n        replace = result.location === state.location.pathname + state.location.search;\r\n      }\r\n\r\n      await startRedirectNavigation(state, result, {\r\n        submission,\r\n        replace\r\n      });\r\n      return {\r\n        shortCircuited: true\r\n      };\r\n    }\r\n\r\n    if (isErrorResult(result)) {\r\n      // Store off the pending error - we use it to determine which loaders\r\n      // to call and will commit it when we complete the navigation\r\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id); // By default, all submissions are REPLACE navigations, but if the\r\n      // action threw an error that'll be rendered in an errorElement, we fall\r\n      // back to PUSH so that the user can use the back button to get back to\r\n      // the pre-submission form location to try again\r\n\r\n      if ((opts && opts.replace) !== true) {\r\n        pendingAction = Action.Push;\r\n      }\r\n\r\n      return {\r\n        // Send back an empty object we can use to clear out any prior actionData\r\n        pendingActionData: {},\r\n        pendingActionError: {\r\n          [boundaryMatch.route.id]: result.error\r\n        }\r\n      };\r\n    }\r\n\r\n    if (isDeferredResult(result)) {\r\n      throw getInternalRouterError(400, {\r\n        type: \"defer-action\"\r\n      });\r\n    }\r\n\r\n    return {\r\n      pendingActionData: {\r\n        [actionMatch.route.id]: result.data\r\n      }\r\n    };\r\n  } // Call all applicable loaders for the given matches, handling redirects,\r\n  // errors, etc.\r\n\r\n\r\n  async function handleLoaders(request, location, matches, overrideNavigation, submission, replace, pendingActionData, pendingError) {\r\n    // Figure out the right navigation we want to use for data loading\r\n    let loadingNavigation = overrideNavigation;\r\n\r\n    if (!loadingNavigation) {\r\n      let navigation = _extends({\r\n        state: \"loading\",\r\n        location,\r\n        formMethod: undefined,\r\n        formAction: undefined,\r\n        formEncType: undefined,\r\n        formData: undefined\r\n      }, submission);\r\n\r\n      loadingNavigation = navigation;\r\n    } // If this was a redirect from an action we don't have a \"submission\" but\r\n    // we have it on the loading navigation so use that if available\r\n\r\n\r\n    let activeSubmission = submission ? submission : loadingNavigation.formMethod && loadingNavigation.formAction && loadingNavigation.formData && loadingNavigation.formEncType ? {\r\n      formMethod: loadingNavigation.formMethod,\r\n      formAction: loadingNavigation.formAction,\r\n      formData: loadingNavigation.formData,\r\n      formEncType: loadingNavigation.formEncType\r\n    } : undefined;\r\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, pendingActionData, pendingError, fetchLoadMatches); // Cancel pending deferreds for no-longer-matched routes or routes we're\r\n    // about to reload.  Note that if this is an action reload we would have\r\n    // already cancelled all pending deferreds so this would be a no-op\r\n\r\n    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId)); // Short circuit if we have no loaders to run\r\n\r\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\r\n      completeNavigation(location, _extends({\r\n        matches,\r\n        loaderData: {},\r\n        // Commit pending error if we're short circuiting\r\n        errors: pendingError || null\r\n      }, pendingActionData ? {\r\n        actionData: pendingActionData\r\n      } : {}));\r\n      return {\r\n        shortCircuited: true\r\n      };\r\n    } // If this is an uninterrupted revalidation, we remain in our current idle\r\n    // state.  If not, we need to switch to our loading state and load data,\r\n    // preserving any new action data or existing action data (in the case of\r\n    // a revalidation interrupting an actionReload)\r\n\r\n\r\n    if (!isUninterruptedRevalidation) {\r\n      revalidatingFetchers.forEach(rf => {\r\n        let fetcher = state.fetchers.get(rf.key);\r\n        let revalidatingFetcher = {\r\n          state: \"loading\",\r\n          data: fetcher && fetcher.data,\r\n          formMethod: undefined,\r\n          formAction: undefined,\r\n          formEncType: undefined,\r\n          formData: undefined,\r\n          \" _hasFetcherDoneAnything \": true\r\n        };\r\n        state.fetchers.set(rf.key, revalidatingFetcher);\r\n      });\r\n      let actionData = pendingActionData || state.actionData;\r\n      updateState(_extends({\r\n        navigation: loadingNavigation\r\n      }, actionData ? Object.keys(actionData).length === 0 ? {\r\n        actionData: null\r\n      } : {\r\n        actionData\r\n      } : {}, revalidatingFetchers.length > 0 ? {\r\n        fetchers: new Map(state.fetchers)\r\n      } : {}));\r\n    }\r\n\r\n    pendingNavigationLoadId = ++incrementingLoadId;\r\n    revalidatingFetchers.forEach(rf => fetchControllers.set(rf.key, pendingNavigationController));\r\n    let {\r\n      results,\r\n      loaderResults,\r\n      fetcherResults\r\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\r\n\r\n    if (request.signal.aborted) {\r\n      return {\r\n        shortCircuited: true\r\n      };\r\n    } // Clean up _after_ loaders have completed.  Don't clean up if we short\r\n    // circuited because fetchControllers would have been aborted and\r\n    // reassigned to new controllers for the next navigation\r\n\r\n\r\n    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key)); // If any loaders returned a redirect Response, start a new REPLACE navigation\r\n\r\n    let redirect = findRedirect(results);\r\n\r\n    if (redirect) {\r\n      await startRedirectNavigation(state, redirect, {\r\n        replace\r\n      });\r\n      return {\r\n        shortCircuited: true\r\n      };\r\n    } // Process and commit output from loaders\r\n\r\n\r\n    let {\r\n      loaderData,\r\n      errors\r\n    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds); // Wire up subscribers to update loaderData as promises settle\r\n\r\n    activeDeferreds.forEach((deferredData, routeId) => {\r\n      deferredData.subscribe(aborted => {\r\n        // Note: No need to updateState here since the TrackedPromise on\r\n        // loaderData is stable across resolve/reject\r\n        // Remove this instance if we were aborted or if promises have settled\r\n        if (aborted || deferredData.done) {\r\n          activeDeferreds.delete(routeId);\r\n        }\r\n      });\r\n    });\r\n    markFetchRedirectsDone();\r\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\r\n    return _extends({\r\n      loaderData,\r\n      errors\r\n    }, didAbortFetchLoads || revalidatingFetchers.length > 0 ? {\r\n      fetchers: new Map(state.fetchers)\r\n    } : {});\r\n  }\r\n\r\n  function getFetcher(key) {\r\n    return state.fetchers.get(key) || IDLE_FETCHER;\r\n  } // Trigger a fetcher load/submit for the given fetcher key\r\n\r\n\r\n  function fetch(key, routeId, href, opts) {\r\n    if (isServer) {\r\n      throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. \" + \"You are likely calling a useFetcher() method in the body of your component. \" + \"Try moving it to a useEffect or a callback.\");\r\n    }\r\n\r\n    if (fetchControllers.has(key)) abortFetcher(key);\r\n    let matches = matchRoutes(dataRoutes, href, init.basename);\r\n\r\n    if (!matches) {\r\n      setFetcherError(key, routeId, getInternalRouterError(404, {\r\n        pathname: href\r\n      }));\r\n      return;\r\n    }\r\n\r\n    let {\r\n      path,\r\n      submission\r\n    } = normalizeNavigateOptions(href, opts, true);\r\n    let match = getTargetMatch(matches, path);\r\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\r\n\r\n    if (submission && isMutationMethod(submission.formMethod)) {\r\n      handleFetcherAction(key, routeId, path, match, matches, submission);\r\n      return;\r\n    } // Store off the match so we can call it's shouldRevalidate on subsequent\r\n    // revalidations\r\n\r\n\r\n    fetchLoadMatches.set(key, {\r\n      routeId,\r\n      path,\r\n      match,\r\n      matches\r\n    });\r\n    handleFetcherLoader(key, routeId, path, match, matches, submission);\r\n  } // Call the action for the matched fetcher.submit(), and then handle redirects,\r\n  // errors, and revalidation\r\n\r\n\r\n  async function handleFetcherAction(key, routeId, path, match, requestMatches, submission) {\r\n    interruptActiveLoads();\r\n    fetchLoadMatches.delete(key);\r\n\r\n    if (!match.route.action) {\r\n      let error = getInternalRouterError(405, {\r\n        method: submission.formMethod,\r\n        pathname: path,\r\n        routeId: routeId\r\n      });\r\n      setFetcherError(key, routeId, error);\r\n      return;\r\n    } // Put this fetcher into it's submitting state\r\n\r\n\r\n    let existingFetcher = state.fetchers.get(key);\r\n\r\n    let fetcher = _extends({\r\n      state: \"submitting\"\r\n    }, submission, {\r\n      data: existingFetcher && existingFetcher.data,\r\n      \" _hasFetcherDoneAnything \": true\r\n    });\r\n\r\n    state.fetchers.set(key, fetcher);\r\n    updateState({\r\n      fetchers: new Map(state.fetchers)\r\n    }); // Call the action for the fetcher\r\n\r\n    let abortController = new AbortController();\r\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\r\n    fetchControllers.set(key, abortController);\r\n    let actionResult = await callLoaderOrAction(\"action\", fetchRequest, match, requestMatches, router.basename);\r\n\r\n    if (fetchRequest.signal.aborted) {\r\n      // We can delete this so long as we weren't aborted by ou our own fetcher\r\n      // re-submit which would have put _new_ controller is in fetchControllers\r\n      if (fetchControllers.get(key) === abortController) {\r\n        fetchControllers.delete(key);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (isRedirectResult(actionResult)) {\r\n      fetchControllers.delete(key);\r\n      fetchRedirectIds.add(key);\r\n\r\n      let loadingFetcher = _extends({\r\n        state: \"loading\"\r\n      }, submission, {\r\n        data: undefined,\r\n        \" _hasFetcherDoneAnything \": true\r\n      });\r\n\r\n      state.fetchers.set(key, loadingFetcher);\r\n      updateState({\r\n        fetchers: new Map(state.fetchers)\r\n      });\r\n      return startRedirectNavigation(state, actionResult, {\r\n        isFetchActionRedirect: true\r\n      });\r\n    } // Process any non-redirect errors thrown\r\n\r\n\r\n    if (isErrorResult(actionResult)) {\r\n      setFetcherError(key, routeId, actionResult.error);\r\n      return;\r\n    }\r\n\r\n    if (isDeferredResult(actionResult)) {\r\n      throw getInternalRouterError(400, {\r\n        type: \"defer-action\"\r\n      });\r\n    } // Start the data load for current matches, or the next location if we're\r\n    // in the middle of a navigation\r\n\r\n\r\n    let nextLocation = state.navigation.location || state.location;\r\n    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\r\n    let matches = state.navigation.state !== \"idle\" ? matchRoutes(dataRoutes, state.navigation.location, init.basename) : state.matches;\r\n    invariant(matches, \"Didn't find any matches after fetcher action\");\r\n    let loadId = ++incrementingLoadId;\r\n    fetchReloadIds.set(key, loadId);\r\n\r\n    let loadFetcher = _extends({\r\n      state: \"loading\",\r\n      data: actionResult.data\r\n    }, submission, {\r\n      \" _hasFetcherDoneAnything \": true\r\n    });\r\n\r\n    state.fetchers.set(key, loadFetcher);\r\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, {\r\n      [match.route.id]: actionResult.data\r\n    }, undefined, // No need to send through errors since we short circuit above\r\n    fetchLoadMatches); // Put all revalidating fetchers into the loading state, except for the\r\n    // current fetcher which we want to keep in it's current loading state which\r\n    // contains it's action submission info + action data\r\n\r\n    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {\r\n      let staleKey = rf.key;\r\n      let existingFetcher = state.fetchers.get(staleKey);\r\n      let revalidatingFetcher = {\r\n        state: \"loading\",\r\n        data: existingFetcher && existingFetcher.data,\r\n        formMethod: undefined,\r\n        formAction: undefined,\r\n        formEncType: undefined,\r\n        formData: undefined,\r\n        \" _hasFetcherDoneAnything \": true\r\n      };\r\n      state.fetchers.set(staleKey, revalidatingFetcher);\r\n      fetchControllers.set(staleKey, abortController);\r\n    });\r\n    updateState({\r\n      fetchers: new Map(state.fetchers)\r\n    });\r\n    let {\r\n      results,\r\n      loaderResults,\r\n      fetcherResults\r\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\r\n\r\n    if (abortController.signal.aborted) {\r\n      return;\r\n    }\r\n\r\n    fetchReloadIds.delete(key);\r\n    fetchControllers.delete(key);\r\n    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));\r\n    let redirect = findRedirect(results);\r\n\r\n    if (redirect) {\r\n      return startRedirectNavigation(state, redirect);\r\n    } // Process and commit output from loaders\r\n\r\n\r\n    let {\r\n      loaderData,\r\n      errors\r\n    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);\r\n    let doneFetcher = {\r\n      state: \"idle\",\r\n      data: actionResult.data,\r\n      formMethod: undefined,\r\n      formAction: undefined,\r\n      formEncType: undefined,\r\n      formData: undefined,\r\n      \" _hasFetcherDoneAnything \": true\r\n    };\r\n    state.fetchers.set(key, doneFetcher);\r\n    let didAbortFetchLoads = abortStaleFetchLoads(loadId); // If we are currently in a navigation loading state and this fetcher is\r\n    // more recent than the navigation, we want the newer data so abort the\r\n    // navigation and complete it with the fetcher data\r\n\r\n    if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\r\n      invariant(pendingAction, \"Expected pending action\");\r\n      pendingNavigationController && pendingNavigationController.abort();\r\n      completeNavigation(state.navigation.location, {\r\n        matches,\r\n        loaderData,\r\n        errors,\r\n        fetchers: new Map(state.fetchers)\r\n      });\r\n    } else {\r\n      // otherwise just update with the fetcher data, preserving any existing\r\n      // loaderData for loaders that did not need to reload.  We have to\r\n      // manually merge here since we aren't going through completeNavigation\r\n      updateState(_extends({\r\n        errors,\r\n        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors)\r\n      }, didAbortFetchLoads ? {\r\n        fetchers: new Map(state.fetchers)\r\n      } : {}));\r\n      isRevalidationRequired = false;\r\n    }\r\n  } // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\r\n\r\n\r\n  async function handleFetcherLoader(key, routeId, path, match, matches, submission) {\r\n    let existingFetcher = state.fetchers.get(key); // Put this fetcher into it's loading state\r\n\r\n    let loadingFetcher = _extends({\r\n      state: \"loading\",\r\n      formMethod: undefined,\r\n      formAction: undefined,\r\n      formEncType: undefined,\r\n      formData: undefined\r\n    }, submission, {\r\n      data: existingFetcher && existingFetcher.data,\r\n      \" _hasFetcherDoneAnything \": true\r\n    });\r\n\r\n    state.fetchers.set(key, loadingFetcher);\r\n    updateState({\r\n      fetchers: new Map(state.fetchers)\r\n    }); // Call the loader for this fetcher route match\r\n\r\n    let abortController = new AbortController();\r\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\r\n    fetchControllers.set(key, abortController);\r\n    let result = await callLoaderOrAction(\"loader\", fetchRequest, match, matches, router.basename); // Deferred isn't supported for fetcher loads, await everything and treat it\r\n    // as a normal load.  resolveDeferredData will return undefined if this\r\n    // fetcher gets aborted, so we just leave result untouched and short circuit\r\n    // below if that happens\r\n\r\n    if (isDeferredResult(result)) {\r\n      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;\r\n    } // We can delete this so long as we weren't aborted by ou our own fetcher\r\n    // re-load which would have put _new_ controller is in fetchControllers\r\n\r\n\r\n    if (fetchControllers.get(key) === abortController) {\r\n      fetchControllers.delete(key);\r\n    }\r\n\r\n    if (fetchRequest.signal.aborted) {\r\n      return;\r\n    } // If the loader threw a redirect Response, start a new REPLACE navigation\r\n\r\n\r\n    if (isRedirectResult(result)) {\r\n      await startRedirectNavigation(state, result);\r\n      return;\r\n    } // Process any non-redirect errors thrown\r\n\r\n\r\n    if (isErrorResult(result)) {\r\n      let boundaryMatch = findNearestBoundary(state.matches, routeId);\r\n      state.fetchers.delete(key); // TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -\r\n      // do we need to behave any differently with our non-redirect errors?\r\n      // What if it was a non-redirect Response?\r\n\r\n      updateState({\r\n        fetchers: new Map(state.fetchers),\r\n        errors: {\r\n          [boundaryMatch.route.id]: result.error\r\n        }\r\n      });\r\n      return;\r\n    }\r\n\r\n    invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\"); // Put the fetcher back into an idle state\r\n\r\n    let doneFetcher = {\r\n      state: \"idle\",\r\n      data: result.data,\r\n      formMethod: undefined,\r\n      formAction: undefined,\r\n      formEncType: undefined,\r\n      formData: undefined,\r\n      \" _hasFetcherDoneAnything \": true\r\n    };\r\n    state.fetchers.set(key, doneFetcher);\r\n    updateState({\r\n      fetchers: new Map(state.fetchers)\r\n    });\r\n  }\r\n  /**\r\n   * Utility function to handle redirects returned from an action or loader.\r\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\r\n   * example:\r\n   *\r\n   *  - user is on /a\r\n   *  - user clicks a link to /b\r\n   *  - loader for /b redirects to /c\r\n   *\r\n   * In a non-JS app the browser would track the in-flight navigation to /b and\r\n   * then replace it with /c when it encountered the redirect response.  In\r\n   * the end it would only ever update the URL bar with /c.\r\n   *\r\n   * In client-side routing using pushState/replaceState, we aim to emulate\r\n   * this behavior and we also do not update history until the end of the\r\n   * navigation (including processed redirects).  This means that we never\r\n   * actually touch history until we've processed redirects, so we just use\r\n   * the history action from the original navigation (PUSH or REPLACE).\r\n   */\r\n\r\n\r\n  async function startRedirectNavigation(state, redirect, _temp) {\r\n    var _window;\r\n\r\n    let {\r\n      submission,\r\n      replace,\r\n      isFetchActionRedirect\r\n    } = _temp === void 0 ? {} : _temp;\r\n\r\n    if (redirect.revalidate) {\r\n      isRevalidationRequired = true;\r\n    }\r\n\r\n    let redirectLocation = createLocation(state.location, redirect.location, // TODO: This can be removed once we get rid of useTransition in Remix v2\r\n    _extends({\r\n      _isRedirect: true\r\n    }, isFetchActionRedirect ? {\r\n      _isFetchActionRedirect: true\r\n    } : {}));\r\n    invariant(redirectLocation, \"Expected a location on the redirect navigation\"); // Check if this an absolute external redirect that goes to a new origin\r\n\r\n    if (ABSOLUTE_URL_REGEX.test(redirect.location) && isBrowser && typeof ((_window = window) == null ? void 0 : _window.location) !== \"undefined\") {\r\n      let newOrigin = init.history.createURL(redirect.location).origin;\r\n\r\n      if (window.location.origin !== newOrigin) {\r\n        if (replace) {\r\n          window.location.replace(redirect.location);\r\n        } else {\r\n          window.location.assign(redirect.location);\r\n        }\r\n\r\n        return;\r\n      }\r\n    } // There's no need to abort on redirects, since we don't detect the\r\n    // redirect until the action/loaders have settled\r\n\r\n\r\n    pendingNavigationController = null;\r\n    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push; // Use the incoming submission if provided, fallback on the active one in\r\n    // state.navigation\r\n\r\n    let {\r\n      formMethod,\r\n      formAction,\r\n      formEncType,\r\n      formData\r\n    } = state.navigation;\r\n\r\n    if (!submission && formMethod && formAction && formData && formEncType) {\r\n      submission = {\r\n        formMethod,\r\n        formAction,\r\n        formEncType,\r\n        formData\r\n      };\r\n    } // If this was a 307/308 submission we want to preserve the HTTP method and\r\n    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\r\n    // redirected location\r\n\r\n\r\n    if (redirectPreserveMethodStatusCodes.has(redirect.status) && submission && isMutationMethod(submission.formMethod)) {\r\n      await startNavigation(redirectHistoryAction, redirectLocation, {\r\n        submission: _extends({}, submission, {\r\n          formAction: redirect.location\r\n        }),\r\n        // Preserve this flag across redirects\r\n        preventScrollReset: pendingPreventScrollReset\r\n      });\r\n    } else {\r\n      // Otherwise, we kick off a new loading navigation, preserving the\r\n      // submission info for the duration of this navigation\r\n      await startNavigation(redirectHistoryAction, redirectLocation, {\r\n        overrideNavigation: {\r\n          state: \"loading\",\r\n          location: redirectLocation,\r\n          formMethod: submission ? submission.formMethod : undefined,\r\n          formAction: submission ? submission.formAction : undefined,\r\n          formEncType: submission ? submission.formEncType : undefined,\r\n          formData: submission ? submission.formData : undefined\r\n        },\r\n        // Preserve this flag across redirects\r\n        preventScrollReset: pendingPreventScrollReset\r\n      });\r\n    }\r\n  }\r\n\r\n  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\r\n    // Call all navigation loaders and revalidating fetcher loaders in parallel,\r\n    // then slice off the results into separate arrays so we can handle them\r\n    // accordingly\r\n    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction(\"loader\", request, match, matches, router.basename)), ...fetchersToLoad.map(f => callLoaderOrAction(\"loader\", createClientSideRequest(init.history, f.path, request.signal), f.match, f.matches, router.basename))]);\r\n    let loaderResults = results.slice(0, matchesToLoad.length);\r\n    let fetcherResults = results.slice(matchesToLoad.length);\r\n    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, request.signal, false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(f => f.match), fetcherResults, request.signal, true)]);\r\n    return {\r\n      results,\r\n      loaderResults,\r\n      fetcherResults\r\n    };\r\n  }\r\n\r\n  function interruptActiveLoads() {\r\n    // Every interruption triggers a revalidation\r\n    isRevalidationRequired = true; // Cancel pending route-level deferreds and mark cancelled routes for\r\n    // revalidation\r\n\r\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds()); // Abort in-flight fetcher loads\r\n\r\n    fetchLoadMatches.forEach((_, key) => {\r\n      if (fetchControllers.has(key)) {\r\n        cancelledFetcherLoads.push(key);\r\n        abortFetcher(key);\r\n      }\r\n    });\r\n  }\r\n\r\n  function setFetcherError(key, routeId, error) {\r\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\r\n    deleteFetcher(key);\r\n    updateState({\r\n      errors: {\r\n        [boundaryMatch.route.id]: error\r\n      },\r\n      fetchers: new Map(state.fetchers)\r\n    });\r\n  }\r\n\r\n  function deleteFetcher(key) {\r\n    if (fetchControllers.has(key)) abortFetcher(key);\r\n    fetchLoadMatches.delete(key);\r\n    fetchReloadIds.delete(key);\r\n    fetchRedirectIds.delete(key);\r\n    state.fetchers.delete(key);\r\n  }\r\n\r\n  function abortFetcher(key) {\r\n    let controller = fetchControllers.get(key);\r\n    invariant(controller, \"Expected fetch controller: \" + key);\r\n    controller.abort();\r\n    fetchControllers.delete(key);\r\n  }\r\n\r\n  function markFetchersDone(keys) {\r\n    for (let key of keys) {\r\n      let fetcher = getFetcher(key);\r\n      let doneFetcher = {\r\n        state: \"idle\",\r\n        data: fetcher.data,\r\n        formMethod: undefined,\r\n        formAction: undefined,\r\n        formEncType: undefined,\r\n        formData: undefined,\r\n        \" _hasFetcherDoneAnything \": true\r\n      };\r\n      state.fetchers.set(key, doneFetcher);\r\n    }\r\n  }\r\n\r\n  function markFetchRedirectsDone() {\r\n    let doneKeys = [];\r\n\r\n    for (let key of fetchRedirectIds) {\r\n      let fetcher = state.fetchers.get(key);\r\n      invariant(fetcher, \"Expected fetcher: \" + key);\r\n\r\n      if (fetcher.state === \"loading\") {\r\n        fetchRedirectIds.delete(key);\r\n        doneKeys.push(key);\r\n      }\r\n    }\r\n\r\n    markFetchersDone(doneKeys);\r\n  }\r\n\r\n  function abortStaleFetchLoads(landedId) {\r\n    let yeetedKeys = [];\r\n\r\n    for (let [key, id] of fetchReloadIds) {\r\n      if (id < landedId) {\r\n        let fetcher = state.fetchers.get(key);\r\n        invariant(fetcher, \"Expected fetcher: \" + key);\r\n\r\n        if (fetcher.state === \"loading\") {\r\n          abortFetcher(key);\r\n          fetchReloadIds.delete(key);\r\n          yeetedKeys.push(key);\r\n        }\r\n      }\r\n    }\r\n\r\n    markFetchersDone(yeetedKeys);\r\n    return yeetedKeys.length > 0;\r\n  }\r\n\r\n  function getBlocker(key, fn) {\r\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\r\n\r\n    if (blockerFunctions.get(key) !== fn) {\r\n      blockerFunctions.set(key, fn);\r\n    }\r\n\r\n    return blocker;\r\n  }\r\n\r\n  function deleteBlocker(key) {\r\n    state.blockers.delete(key);\r\n    blockerFunctions.delete(key);\r\n  } // Utility function to update blockers, ensuring valid state transitions\r\n\r\n\r\n  function updateBlocker(key, newBlocker) {\r\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER; // Poor mans state machine :)\r\n    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\r\n\r\n    invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", \"Invalid blocker state transition: \" + blocker.state + \" -> \" + newBlocker.state);\r\n    state.blockers.set(key, newBlocker);\r\n    updateState({\r\n      blockers: new Map(state.blockers)\r\n    });\r\n  }\r\n\r\n  function shouldBlockNavigation(_ref2) {\r\n    let {\r\n      currentLocation,\r\n      nextLocation,\r\n      historyAction\r\n    } = _ref2;\r\n\r\n    if (blockerFunctions.size === 0) {\r\n      return;\r\n    } // We ony support a single active blocker at the moment since we don't have\r\n    // any compelling use cases for multi-blocker yet\r\n\r\n\r\n    if (blockerFunctions.size > 1) {\r\n      warning(false, \"A router only supports one blocker at a time\");\r\n    }\r\n\r\n    let entries = Array.from(blockerFunctions.entries());\r\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\r\n    let blocker = state.blockers.get(blockerKey);\r\n\r\n    if (blocker && blocker.state === \"proceeding\") {\r\n      // If the blocker is currently proceeding, we don't need to re-check\r\n      // it and can let this navigation continue\r\n      return;\r\n    } // At this point, we know we're unblocked/blocked so we need to check the\r\n    // user-provided blocker function\r\n\r\n\r\n    if (blockerFunction({\r\n      currentLocation,\r\n      nextLocation,\r\n      historyAction\r\n    })) {\r\n      return blockerKey;\r\n    }\r\n  }\r\n\r\n  function cancelActiveDeferreds(predicate) {\r\n    let cancelledRouteIds = [];\r\n    activeDeferreds.forEach((dfd, routeId) => {\r\n      if (!predicate || predicate(routeId)) {\r\n        // Cancel the deferred - but do not remove from activeDeferreds here -\r\n        // we rely on the subscribers to do that so our tests can assert proper\r\n        // cleanup via _internalActiveDeferreds\r\n        dfd.cancel();\r\n        cancelledRouteIds.push(routeId);\r\n        activeDeferreds.delete(routeId);\r\n      }\r\n    });\r\n    return cancelledRouteIds;\r\n  } // Opt in to capturing and reporting scroll positions during navigations,\r\n  // used by the <ScrollRestoration> component\r\n\r\n\r\n  function enableScrollRestoration(positions, getPosition, getKey) {\r\n    savedScrollPositions = positions;\r\n    getScrollPosition = getPosition;\r\n\r\n    getScrollRestorationKey = getKey || (location => location.key); // Perform initial hydration scroll restoration, since we miss the boat on\r\n    // the initial updateState() because we've not yet rendered <ScrollRestoration/>\r\n    // and therefore have no savedScrollPositions available\r\n\r\n\r\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\r\n      initialScrollRestored = true;\r\n      let y = getSavedScrollPosition(state.location, state.matches);\r\n\r\n      if (y != null) {\r\n        updateState({\r\n          restoreScrollPosition: y\r\n        });\r\n      }\r\n    }\r\n\r\n    return () => {\r\n      savedScrollPositions = null;\r\n      getScrollPosition = null;\r\n      getScrollRestorationKey = null;\r\n    };\r\n  }\r\n\r\n  function saveScrollPosition(location, matches) {\r\n    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {\r\n      let userMatches = matches.map(m => createUseMatchesMatch(m, state.loaderData));\r\n      let key = getScrollRestorationKey(location, userMatches) || location.key;\r\n      savedScrollPositions[key] = getScrollPosition();\r\n    }\r\n  }\r\n\r\n  function getSavedScrollPosition(location, matches) {\r\n    if (savedScrollPositions && getScrollRestorationKey && getScrollPosition) {\r\n      let userMatches = matches.map(m => createUseMatchesMatch(m, state.loaderData));\r\n      let key = getScrollRestorationKey(location, userMatches) || location.key;\r\n      let y = savedScrollPositions[key];\r\n\r\n      if (typeof y === \"number\") {\r\n        return y;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  router = {\r\n    get basename() {\r\n      return init.basename;\r\n    },\r\n\r\n    get state() {\r\n      return state;\r\n    },\r\n\r\n    get routes() {\r\n      return dataRoutes;\r\n    },\r\n\r\n    initialize,\r\n    subscribe,\r\n    enableScrollRestoration,\r\n    navigate,\r\n    fetch,\r\n    revalidate,\r\n    // Passthrough to history-aware createHref used by useHref so we get proper\r\n    // hash-aware URLs in DOM paths\r\n    createHref: to => init.history.createHref(to),\r\n    encodeLocation: to => init.history.encodeLocation(to),\r\n    getFetcher,\r\n    deleteFetcher,\r\n    dispose,\r\n    getBlocker,\r\n    deleteBlocker,\r\n    _internalFetchControllers: fetchControllers,\r\n    _internalActiveDeferreds: activeDeferreds\r\n  };\r\n  return router;\r\n} //#endregion\r\n////////////////////////////////////////////////////////////////////////////////\r\n//#region createStaticHandler\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\nconst UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\r\nfunction createStaticHandler(routes, opts) {\r\n  invariant(routes.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\r\n  let dataRoutes = convertRoutesToDataRoutes(routes);\r\n  let basename = (opts ? opts.basename : null) || \"/\";\r\n  /**\r\n   * The query() method is intended for document requests, in which we want to\r\n   * call an optional action and potentially multiple loaders for all nested\r\n   * routes.  It returns a StaticHandlerContext object, which is very similar\r\n   * to the router state (location, loaderData, actionData, errors, etc.) and\r\n   * also adds SSR-specific information such as the statusCode and headers\r\n   * from action/loaders Responses.\r\n   *\r\n   * It _should_ never throw and should report all errors through the\r\n   * returned context.errors object, properly associating errors to their error\r\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\r\n   * used to emulate React error boundaries during SSr by performing a second\r\n   * pass only down to the boundaryId.\r\n   *\r\n   * The one exception where we do not return a StaticHandlerContext is when a\r\n   * redirect response is returned or thrown from any action/loader.  We\r\n   * propagate that out and return the raw Response so the HTTP server can\r\n   * return it directly.\r\n   */\r\n\r\n  async function query(request, _temp2) {\r\n    let {\r\n      requestContext\r\n    } = _temp2 === void 0 ? {} : _temp2;\r\n    let url = new URL(request.url);\r\n    let method = request.method.toLowerCase();\r\n    let location = createLocation(\"\", createPath(url), null, \"default\");\r\n    let matches = matchRoutes(dataRoutes, location, basename); // SSR supports HEAD requests while SPA doesn't\r\n\r\n    if (!isValidMethod(method) && method !== \"head\") {\r\n      let error = getInternalRouterError(405, {\r\n        method\r\n      });\r\n      let {\r\n        matches: methodNotAllowedMatches,\r\n        route\r\n      } = getShortCircuitMatches(dataRoutes);\r\n      return {\r\n        basename,\r\n        location,\r\n        matches: methodNotAllowedMatches,\r\n        loaderData: {},\r\n        actionData: null,\r\n        errors: {\r\n          [route.id]: error\r\n        },\r\n        statusCode: error.status,\r\n        loaderHeaders: {},\r\n        actionHeaders: {},\r\n        activeDeferreds: null\r\n      };\r\n    } else if (!matches) {\r\n      let error = getInternalRouterError(404, {\r\n        pathname: location.pathname\r\n      });\r\n      let {\r\n        matches: notFoundMatches,\r\n        route\r\n      } = getShortCircuitMatches(dataRoutes);\r\n      return {\r\n        basename,\r\n        location,\r\n        matches: notFoundMatches,\r\n        loaderData: {},\r\n        actionData: null,\r\n        errors: {\r\n          [route.id]: error\r\n        },\r\n        statusCode: error.status,\r\n        loaderHeaders: {},\r\n        actionHeaders: {},\r\n        activeDeferreds: null\r\n      };\r\n    }\r\n\r\n    let result = await queryImpl(request, location, matches, requestContext);\r\n\r\n    if (isResponse(result)) {\r\n      return result;\r\n    } // When returning StaticHandlerContext, we patch back in the location here\r\n    // since we need it for React Context.  But this helps keep our submit and\r\n    // loadRouteData operating on a Request instead of a Location\r\n\r\n\r\n    return _extends({\r\n      location,\r\n      basename\r\n    }, result);\r\n  }\r\n  /**\r\n   * The queryRoute() method is intended for targeted route requests, either\r\n   * for fetch ?_data requests or resource route requests.  In this case, we\r\n   * are only ever calling a single action or loader, and we are returning the\r\n   * returned value directly.  In most cases, this will be a Response returned\r\n   * from the action/loader, but it may be a primitive or other value as well -\r\n   * and in such cases the calling context should handle that accordingly.\r\n   *\r\n   * We do respect the throw/return differentiation, so if an action/loader\r\n   * throws, then this method will throw the value.  This is important so we\r\n   * can do proper boundary identification in Remix where a thrown Response\r\n   * must go to the Catch Boundary but a returned Response is happy-path.\r\n   *\r\n   * One thing to note is that any Router-initiated Errors that make sense\r\n   * to associate with a status code will be thrown as an ErrorResponse\r\n   * instance which include the raw Error, such that the calling context can\r\n   * serialize the error as they see fit while including the proper response\r\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\r\n   * any user-defined loaders.\r\n   */\r\n\r\n\r\n  async function queryRoute(request, _temp3) {\r\n    let {\r\n      routeId,\r\n      requestContext\r\n    } = _temp3 === void 0 ? {} : _temp3;\r\n    let url = new URL(request.url);\r\n    let method = request.method.toLowerCase();\r\n    let location = createLocation(\"\", createPath(url), null, \"default\");\r\n    let matches = matchRoutes(dataRoutes, location, basename); // SSR supports HEAD requests while SPA doesn't\r\n\r\n    if (!isValidMethod(method) && method !== \"head\" && method !== \"options\") {\r\n      throw getInternalRouterError(405, {\r\n        method\r\n      });\r\n    } else if (!matches) {\r\n      throw getInternalRouterError(404, {\r\n        pathname: location.pathname\r\n      });\r\n    }\r\n\r\n    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);\r\n\r\n    if (routeId && !match) {\r\n      throw getInternalRouterError(403, {\r\n        pathname: location.pathname,\r\n        routeId\r\n      });\r\n    } else if (!match) {\r\n      // This should never hit I don't think?\r\n      throw getInternalRouterError(404, {\r\n        pathname: location.pathname\r\n      });\r\n    }\r\n\r\n    let result = await queryImpl(request, location, matches, requestContext, match);\r\n\r\n    if (isResponse(result)) {\r\n      return result;\r\n    }\r\n\r\n    let error = result.errors ? Object.values(result.errors)[0] : undefined;\r\n\r\n    if (error !== undefined) {\r\n      // If we got back result.errors, that means the loader/action threw\r\n      // _something_ that wasn't a Response, but it's not guaranteed/required\r\n      // to be an `instanceof Error` either, so we have to use throw here to\r\n      // preserve the \"error\" state outside of queryImpl.\r\n      throw error;\r\n    } // Pick off the right state value to return\r\n\r\n\r\n    if (result.actionData) {\r\n      return Object.values(result.actionData)[0];\r\n    }\r\n\r\n    if (result.loaderData) {\r\n      var _result$activeDeferre;\r\n\r\n      let data = Object.values(result.loaderData)[0];\r\n\r\n      if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {\r\n        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\r\n      }\r\n\r\n      return data;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  async function queryImpl(request, location, matches, requestContext, routeMatch) {\r\n    invariant(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\r\n\r\n    try {\r\n      if (isMutationMethod(request.method.toLowerCase())) {\r\n        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);\r\n        return result;\r\n      }\r\n\r\n      let result = await loadRouteData(request, matches, requestContext, routeMatch);\r\n      return isResponse(result) ? result : _extends({}, result, {\r\n        actionData: null,\r\n        actionHeaders: {}\r\n      });\r\n    } catch (e) {\r\n      // If the user threw/returned a Response in callLoaderOrAction, we throw\r\n      // it to bail out and then return or throw here based on whether the user\r\n      // returned or threw\r\n      if (isQueryRouteResponse(e)) {\r\n        if (e.type === ResultType.error && !isRedirectResponse(e.response)) {\r\n          throw e.response;\r\n        }\r\n\r\n        return e.response;\r\n      } // Redirects are always returned since they don't propagate to catch\r\n      // boundaries\r\n\r\n\r\n      if (isRedirectResponse(e)) {\r\n        return e;\r\n      }\r\n\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {\r\n    let result;\r\n\r\n    if (!actionMatch.route.action) {\r\n      let error = getInternalRouterError(405, {\r\n        method: request.method,\r\n        pathname: new URL(request.url).pathname,\r\n        routeId: actionMatch.route.id\r\n      });\r\n\r\n      if (isRouteRequest) {\r\n        throw error;\r\n      }\r\n\r\n      result = {\r\n        type: ResultType.error,\r\n        error\r\n      };\r\n    } else {\r\n      result = await callLoaderOrAction(\"action\", request, actionMatch, matches, basename, true, isRouteRequest, requestContext);\r\n\r\n      if (request.signal.aborted) {\r\n        let method = isRouteRequest ? \"queryRoute\" : \"query\";\r\n        throw new Error(method + \"() call aborted\");\r\n      }\r\n    }\r\n\r\n    if (isRedirectResult(result)) {\r\n      // Uhhhh - this should never happen, we should always throw these from\r\n      // callLoaderOrAction, but the type narrowing here keeps TS happy and we\r\n      // can get back on the \"throw all redirect responses\" train here should\r\n      // this ever happen :/\r\n      throw new Response(null, {\r\n        status: result.status,\r\n        headers: {\r\n          Location: result.location\r\n        }\r\n      });\r\n    }\r\n\r\n    if (isDeferredResult(result)) {\r\n      let error = getInternalRouterError(400, {\r\n        type: \"defer-action\"\r\n      });\r\n\r\n      if (isRouteRequest) {\r\n        throw error;\r\n      }\r\n\r\n      result = {\r\n        type: ResultType.error,\r\n        error\r\n      };\r\n    }\r\n\r\n    if (isRouteRequest) {\r\n      // Note: This should only be non-Response values if we get here, since\r\n      // isRouteRequest should throw any Response received in callLoaderOrAction\r\n      if (isErrorResult(result)) {\r\n        throw result.error;\r\n      }\r\n\r\n      return {\r\n        matches: [actionMatch],\r\n        loaderData: {},\r\n        actionData: {\r\n          [actionMatch.route.id]: result.data\r\n        },\r\n        errors: null,\r\n        // Note: statusCode + headers are unused here since queryRoute will\r\n        // return the raw Response or value\r\n        statusCode: 200,\r\n        loaderHeaders: {},\r\n        actionHeaders: {},\r\n        activeDeferreds: null\r\n      };\r\n    }\r\n\r\n    if (isErrorResult(result)) {\r\n      // Store off the pending error - we use it to determine which loaders\r\n      // to call and will commit it when we complete the navigation\r\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\r\n      let context = await loadRouteData(request, matches, requestContext, undefined, {\r\n        [boundaryMatch.route.id]: result.error\r\n      }); // action status codes take precedence over loader status codes\r\n\r\n      return _extends({}, context, {\r\n        statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,\r\n        actionData: null,\r\n        actionHeaders: _extends({}, result.headers ? {\r\n          [actionMatch.route.id]: result.headers\r\n        } : {})\r\n      });\r\n    } // Create a GET request for the loaders\r\n\r\n\r\n    let loaderRequest = new Request(request.url, {\r\n      headers: request.headers,\r\n      redirect: request.redirect,\r\n      signal: request.signal\r\n    });\r\n    let context = await loadRouteData(loaderRequest, matches, requestContext);\r\n    return _extends({}, context, result.statusCode ? {\r\n      statusCode: result.statusCode\r\n    } : {}, {\r\n      actionData: {\r\n        [actionMatch.route.id]: result.data\r\n      },\r\n      actionHeaders: _extends({}, result.headers ? {\r\n        [actionMatch.route.id]: result.headers\r\n      } : {})\r\n    });\r\n  }\r\n\r\n  async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {\r\n    let isRouteRequest = routeMatch != null; // Short circuit if we have no loaders to run (queryRoute())\r\n\r\n    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader)) {\r\n      throw getInternalRouterError(400, {\r\n        method: request.method,\r\n        pathname: new URL(request.url).pathname,\r\n        routeId: routeMatch == null ? void 0 : routeMatch.route.id\r\n      });\r\n    }\r\n\r\n    let requestMatches = routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);\r\n    let matchesToLoad = requestMatches.filter(m => m.route.loader); // Short circuit if we have no loaders to run (query())\r\n\r\n    if (matchesToLoad.length === 0) {\r\n      return {\r\n        matches,\r\n        // Add a null for all matched routes for proper revalidation on the client\r\n        loaderData: matches.reduce((acc, m) => Object.assign(acc, {\r\n          [m.route.id]: null\r\n        }), {}),\r\n        errors: pendingActionError || null,\r\n        statusCode: 200,\r\n        loaderHeaders: {},\r\n        activeDeferreds: null\r\n      };\r\n    }\r\n\r\n    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction(\"loader\", request, match, matches, basename, true, isRouteRequest, requestContext))]);\r\n\r\n    if (request.signal.aborted) {\r\n      let method = isRouteRequest ? \"queryRoute\" : \"query\";\r\n      throw new Error(method + \"() call aborted\");\r\n    } // Process and commit output from loaders\r\n\r\n\r\n    let activeDeferreds = new Map();\r\n    let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds); // Add a null for any non-loader matches for proper revalidation on the client\r\n\r\n    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));\r\n    matches.forEach(match => {\r\n      if (!executedLoaders.has(match.route.id)) {\r\n        context.loaderData[match.route.id] = null;\r\n      }\r\n    });\r\n    return _extends({}, context, {\r\n      matches,\r\n      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null\r\n    });\r\n  }\r\n\r\n  return {\r\n    dataRoutes,\r\n    query,\r\n    queryRoute\r\n  };\r\n} //#endregion\r\n////////////////////////////////////////////////////////////////////////////////\r\n//#region Helpers\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n/**\r\n * Given an existing StaticHandlerContext and an error thrown at render time,\r\n * provide an updated StaticHandlerContext suitable for a second SSR render\r\n */\r\n\r\nfunction getStaticContextFromError(routes, context, error) {\r\n  let newContext = _extends({}, context, {\r\n    statusCode: 500,\r\n    errors: {\r\n      [context._deepestRenderedBoundaryId || routes[0].id]: error\r\n    }\r\n  });\r\n\r\n  return newContext;\r\n}\r\n\r\nfunction isSubmissionNavigation(opts) {\r\n  return opts != null && \"formData\" in opts;\r\n} // Normalize navigation options by converting formMethod=GET formData objects to\r\n// URLSearchParams so they behave identically to links with query params\r\n\r\n\r\nfunction normalizeNavigateOptions(to, opts, isFetcher) {\r\n  if (isFetcher === void 0) {\r\n    isFetcher = false;\r\n  }\r\n\r\n  let path = typeof to === \"string\" ? to : createPath(to); // Return location verbatim on non-submission navigations\r\n\r\n  if (!opts || !isSubmissionNavigation(opts)) {\r\n    return {\r\n      path\r\n    };\r\n  }\r\n\r\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\r\n    return {\r\n      path,\r\n      error: getInternalRouterError(405, {\r\n        method: opts.formMethod\r\n      })\r\n    };\r\n  } // Create a Submission on non-GET navigations\r\n\r\n\r\n  let submission;\r\n\r\n  if (opts.formData) {\r\n    submission = {\r\n      formMethod: opts.formMethod || \"get\",\r\n      formAction: stripHashFromPath(path),\r\n      formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\r\n      formData: opts.formData\r\n    };\r\n\r\n    if (isMutationMethod(submission.formMethod)) {\r\n      return {\r\n        path,\r\n        submission\r\n      };\r\n    }\r\n  } // Flatten submission onto URLSearchParams for GET submissions\r\n\r\n\r\n  let parsedPath = parsePath(path);\r\n  let searchParams = convertFormDataToSearchParams(opts.formData); // Since fetcher GET submissions only run a single loader (as opposed to\r\n  // navigation GET submissions which run all loaders), we need to preserve\r\n  // any incoming ?index params\r\n\r\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\r\n    searchParams.append(\"index\", \"\");\r\n  }\r\n\r\n  parsedPath.search = \"?\" + searchParams;\r\n  return {\r\n    path: createPath(parsedPath),\r\n    submission\r\n  };\r\n} // Filter out all routes below any caught error as they aren't going to\r\n// render so we don't need to load them\r\n\r\n\r\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\r\n  let boundaryMatches = matches;\r\n\r\n  if (boundaryId) {\r\n    let index = matches.findIndex(m => m.route.id === boundaryId);\r\n\r\n    if (index >= 0) {\r\n      boundaryMatches = matches.slice(0, index);\r\n    }\r\n  }\r\n\r\n  return boundaryMatches;\r\n}\r\n\r\nfunction getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, pendingActionData, pendingError, fetchLoadMatches) {\r\n  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;\r\n  let currentUrl = history.createURL(state.location);\r\n  let nextUrl = history.createURL(location);\r\n  let defaultShouldRevalidate = // Forced revalidation due to submission, useRevalidate, or X-Remix-Revalidate\r\n  isRevalidationRequired || // Clicked the same link, resubmitted a GET form\r\n  currentUrl.toString() === nextUrl.toString() || // Search params affect all loaders\r\n  currentUrl.search !== nextUrl.search; // Pick navigation matches that are net-new or qualify for revalidation\r\n\r\n  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\r\n  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\r\n  let navigationMatches = boundaryMatches.filter((match, index) => {\r\n    if (match.route.loader == null) {\r\n      return false;\r\n    } // Always call the loader on new route instances and pending defer cancellations\r\n\r\n\r\n    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {\r\n      return true;\r\n    } // This is the default implementation for when we revalidate.  If the route\r\n    // provides it's own implementation, then we give them full control but\r\n    // provide this value so they can leverage it if needed after they check\r\n    // their own specific use cases\r\n\r\n\r\n    let currentRouteMatch = state.matches[index];\r\n    let nextRouteMatch = match;\r\n    return shouldRevalidateLoader(match, _extends({\r\n      currentUrl,\r\n      currentParams: currentRouteMatch.params,\r\n      nextUrl,\r\n      nextParams: nextRouteMatch.params\r\n    }, submission, {\r\n      actionResult,\r\n      defaultShouldRevalidate: defaultShouldRevalidate || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\r\n    }));\r\n  }); // Pick fetcher.loads that need to be revalidated\r\n\r\n  let revalidatingFetchers = [];\r\n  fetchLoadMatches && fetchLoadMatches.forEach((f, key) => {\r\n    if (!matches.some(m => m.route.id === f.routeId)) {\r\n      // This fetcher is not going to be present in the subsequent render so\r\n      // there's no need to revalidate it\r\n      return;\r\n    } else if (cancelledFetcherLoads.includes(key)) {\r\n      // This fetcher was cancelled from a prior action submission - force reload\r\n      revalidatingFetchers.push(_extends({\r\n        key\r\n      }, f));\r\n    } else {\r\n      // Revalidating fetchers are decoupled from the route matches since they\r\n      // hit a static href, so they _always_ check shouldRevalidate and the\r\n      // default is strictly if a revalidation is explicitly required (action\r\n      // submissions, useRevalidator, X-Remix-Revalidate).\r\n      let shouldRevalidate = shouldRevalidateLoader(f.match, _extends({\r\n        currentUrl,\r\n        currentParams: state.matches[state.matches.length - 1].params,\r\n        nextUrl,\r\n        nextParams: matches[matches.length - 1].params\r\n      }, submission, {\r\n        actionResult,\r\n        defaultShouldRevalidate\r\n      }));\r\n\r\n      if (shouldRevalidate) {\r\n        revalidatingFetchers.push(_extends({\r\n          key\r\n        }, f));\r\n      }\r\n    }\r\n  });\r\n  return [navigationMatches, revalidatingFetchers];\r\n}\r\n\r\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\r\n  let isNew = // [a] -> [a, b]\r\n  !currentMatch || // [a, b] -> [a, c]\r\n  match.route.id !== currentMatch.route.id; // Handle the case that we don't have data for a re-used route, potentially\r\n  // from a prior error or from a cancelled pending deferred\r\n\r\n  let isMissingData = currentLoaderData[match.route.id] === undefined; // Always load if this is a net-new route or we don't yet have data\r\n\r\n  return isNew || isMissingData;\r\n}\r\n\r\nfunction isNewRouteInstance(currentMatch, match) {\r\n  let currentPath = currentMatch.route.path;\r\n  return (// param change for this match, /users/123 -> /users/456\r\n    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path\r\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\r\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]\r\n  );\r\n}\r\n\r\nfunction shouldRevalidateLoader(loaderMatch, arg) {\r\n  if (loaderMatch.route.shouldRevalidate) {\r\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\r\n\r\n    if (typeof routeChoice === \"boolean\") {\r\n      return routeChoice;\r\n    }\r\n  }\r\n\r\n  return arg.defaultShouldRevalidate;\r\n}\r\n\r\nasync function callLoaderOrAction(type, request, match, matches, basename, isStaticRequest, isRouteRequest, requestContext) {\r\n  if (basename === void 0) {\r\n    basename = \"/\";\r\n  }\r\n\r\n  if (isStaticRequest === void 0) {\r\n    isStaticRequest = false;\r\n  }\r\n\r\n  if (isRouteRequest === void 0) {\r\n    isRouteRequest = false;\r\n  }\r\n\r\n  let resultType;\r\n  let result; // Setup a promise we can race against so that abort signals short circuit\r\n\r\n  let reject;\r\n  let abortPromise = new Promise((_, r) => reject = r);\r\n\r\n  let onReject = () => reject();\r\n\r\n  request.signal.addEventListener(\"abort\", onReject);\r\n\r\n  try {\r\n    let handler = match.route[type];\r\n    invariant(handler, \"Could not find the \" + type + \" to run on the \\\"\" + match.route.id + \"\\\" route\");\r\n    result = await Promise.race([handler({\r\n      request,\r\n      params: match.params,\r\n      context: requestContext\r\n    }), abortPromise]);\r\n    invariant(result !== undefined, \"You defined \" + (type === \"action\" ? \"an action\" : \"a loader\") + \" for route \" + (\"\\\"\" + match.route.id + \"\\\" but didn't return anything from your `\" + type + \"` \") + \"function. Please return a value or `null`.\");\r\n  } catch (e) {\r\n    resultType = ResultType.error;\r\n    result = e;\r\n  } finally {\r\n    request.signal.removeEventListener(\"abort\", onReject);\r\n  }\r\n\r\n  if (isResponse(result)) {\r\n    let status = result.status; // Process redirects\r\n\r\n    if (redirectStatusCodes.has(status)) {\r\n      let location = result.headers.get(\"Location\");\r\n      invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\"); // Support relative routing in internal redirects\r\n\r\n      if (!ABSOLUTE_URL_REGEX.test(location)) {\r\n        let activeMatches = matches.slice(0, matches.indexOf(match) + 1);\r\n        let routePathnames = getPathContributingMatches(activeMatches).map(match => match.pathnameBase);\r\n        let resolvedLocation = resolveTo(location, routePathnames, new URL(request.url).pathname);\r\n        invariant(createPath(resolvedLocation), \"Unable to resolve redirect location: \" + location); // Prepend the basename to the redirect location if we have one\r\n\r\n        if (basename) {\r\n          let path = resolvedLocation.pathname;\r\n          resolvedLocation.pathname = path === \"/\" ? basename : joinPaths([basename, path]);\r\n        }\r\n\r\n        location = createPath(resolvedLocation);\r\n      } else if (!isStaticRequest) {\r\n        // Strip off the protocol+origin for same-origin absolute redirects.\r\n        // If this is a static reques, we can let it go back to the browser\r\n        // as-is\r\n        let currentUrl = new URL(request.url);\r\n        let url = location.startsWith(\"//\") ? new URL(currentUrl.protocol + location) : new URL(location);\r\n\r\n        if (url.origin === currentUrl.origin) {\r\n          location = url.pathname + url.search + url.hash;\r\n        }\r\n      } // Don't process redirects in the router during static requests requests.\r\n      // Instead, throw the Response and let the server handle it with an HTTP\r\n      // redirect.  We also update the Location header in place in this flow so\r\n      // basename and relative routing is taken into account\r\n\r\n\r\n      if (isStaticRequest) {\r\n        result.headers.set(\"Location\", location);\r\n        throw result;\r\n      }\r\n\r\n      return {\r\n        type: ResultType.redirect,\r\n        status,\r\n        location,\r\n        revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null\r\n      };\r\n    } // For SSR single-route requests, we want to hand Responses back directly\r\n    // without unwrapping.  We do this with the QueryRouteResponse wrapper\r\n    // interface so we can know whether it was returned or thrown\r\n\r\n\r\n    if (isRouteRequest) {\r\n      // eslint-disable-next-line no-throw-literal\r\n      throw {\r\n        type: resultType || ResultType.data,\r\n        response: result\r\n      };\r\n    }\r\n\r\n    let data;\r\n    let contentType = result.headers.get(\"Content-Type\"); // Check between word boundaries instead of startsWith() due to the last\r\n    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\r\n\r\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\r\n      data = await result.json();\r\n    } else {\r\n      data = await result.text();\r\n    }\r\n\r\n    if (resultType === ResultType.error) {\r\n      return {\r\n        type: resultType,\r\n        error: new ErrorResponse(status, result.statusText, data),\r\n        headers: result.headers\r\n      };\r\n    }\r\n\r\n    return {\r\n      type: ResultType.data,\r\n      data,\r\n      statusCode: result.status,\r\n      headers: result.headers\r\n    };\r\n  }\r\n\r\n  if (resultType === ResultType.error) {\r\n    return {\r\n      type: resultType,\r\n      error: result\r\n    };\r\n  }\r\n\r\n  if (result instanceof DeferredData) {\r\n    return {\r\n      type: ResultType.deferred,\r\n      deferredData: result\r\n    };\r\n  }\r\n\r\n  return {\r\n    type: ResultType.data,\r\n    data: result\r\n  };\r\n} // Utility method for creating the Request instances for loaders/actions during\r\n// client-side navigations and fetches.  During SSR we will always have a\r\n// Request instance from the static handler (query/queryRoute)\r\n\r\n\r\nfunction createClientSideRequest(history, location, signal, submission) {\r\n  let url = history.createURL(stripHashFromPath(location)).toString();\r\n  let init = {\r\n    signal\r\n  };\r\n\r\n  if (submission && isMutationMethod(submission.formMethod)) {\r\n    let {\r\n      formMethod,\r\n      formEncType,\r\n      formData\r\n    } = submission;\r\n    init.method = formMethod.toUpperCase();\r\n    init.body = formEncType === \"application/x-www-form-urlencoded\" ? convertFormDataToSearchParams(formData) : formData;\r\n  } // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\r\n\r\n\r\n  return new Request(url, init);\r\n}\r\n\r\nfunction convertFormDataToSearchParams(formData) {\r\n  let searchParams = new URLSearchParams();\r\n\r\n  for (let [key, value] of formData.entries()) {\r\n    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\r\n    searchParams.append(key, value instanceof File ? value.name : value);\r\n  }\r\n\r\n  return searchParams;\r\n}\r\n\r\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\r\n  // Fill in loaderData/errors from our loaders\r\n  let loaderData = {};\r\n  let errors = null;\r\n  let statusCode;\r\n  let foundError = false;\r\n  let loaderHeaders = {}; // Process loader results into state.loaderData/state.errors\r\n\r\n  results.forEach((result, index) => {\r\n    let id = matchesToLoad[index].route.id;\r\n    invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\r\n\r\n    if (isErrorResult(result)) {\r\n      // Look upwards from the matched route for the closest ancestor\r\n      // error boundary, defaulting to the root match\r\n      let boundaryMatch = findNearestBoundary(matches, id);\r\n      let error = result.error; // If we have a pending action error, we report it at the highest-route\r\n      // that throws a loader error, and then clear it out to indicate that\r\n      // it was consumed\r\n\r\n      if (pendingError) {\r\n        error = Object.values(pendingError)[0];\r\n        pendingError = undefined;\r\n      }\r\n\r\n      errors = errors || {}; // Prefer higher error values if lower errors bubble to the same boundary\r\n\r\n      if (errors[boundaryMatch.route.id] == null) {\r\n        errors[boundaryMatch.route.id] = error;\r\n      } // Clear our any prior loaderData for the throwing route\r\n\r\n\r\n      loaderData[id] = undefined; // Once we find our first (highest) error, we set the status code and\r\n      // prevent deeper status codes from overriding\r\n\r\n      if (!foundError) {\r\n        foundError = true;\r\n        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\r\n      }\r\n\r\n      if (result.headers) {\r\n        loaderHeaders[id] = result.headers;\r\n      }\r\n    } else {\r\n      if (isDeferredResult(result)) {\r\n        activeDeferreds.set(id, result.deferredData);\r\n        loaderData[id] = result.deferredData.data;\r\n      } else {\r\n        loaderData[id] = result.data;\r\n      } // Error status codes always override success status codes, but if all\r\n      // loaders are successful we take the deepest status code.\r\n\r\n\r\n      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\r\n        statusCode = result.statusCode;\r\n      }\r\n\r\n      if (result.headers) {\r\n        loaderHeaders[id] = result.headers;\r\n      }\r\n    }\r\n  }); // If we didn't consume the pending action error (i.e., all loaders\r\n  // resolved), then consume it here.  Also clear out any loaderData for the\r\n  // throwing route\r\n\r\n  if (pendingError) {\r\n    errors = pendingError;\r\n    loaderData[Object.keys(pendingError)[0]] = undefined;\r\n  }\r\n\r\n  return {\r\n    loaderData,\r\n    errors,\r\n    statusCode: statusCode || 200,\r\n    loaderHeaders\r\n  };\r\n}\r\n\r\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\r\n  let {\r\n    loaderData,\r\n    errors\r\n  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds); // Process results from our revalidating fetchers\r\n\r\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\r\n    let {\r\n      key,\r\n      match\r\n    } = revalidatingFetchers[index];\r\n    invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, \"Did not find corresponding fetcher result\");\r\n    let result = fetcherResults[index]; // Process fetcher non-redirect errors\r\n\r\n    if (isErrorResult(result)) {\r\n      let boundaryMatch = findNearestBoundary(state.matches, match.route.id);\r\n\r\n      if (!(errors && errors[boundaryMatch.route.id])) {\r\n        errors = _extends({}, errors, {\r\n          [boundaryMatch.route.id]: result.error\r\n        });\r\n      }\r\n\r\n      state.fetchers.delete(key);\r\n    } else if (isRedirectResult(result)) {\r\n      // Should never get here, redirects should get processed above, but we\r\n      // keep this to type narrow to a success result in the else\r\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\r\n    } else if (isDeferredResult(result)) {\r\n      // Should never get here, deferred data should be awaited for fetchers\r\n      // in resolveDeferredResults\r\n      invariant(false, \"Unhandled fetcher deferred data\");\r\n    } else {\r\n      let doneFetcher = {\r\n        state: \"idle\",\r\n        data: result.data,\r\n        formMethod: undefined,\r\n        formAction: undefined,\r\n        formEncType: undefined,\r\n        formData: undefined,\r\n        \" _hasFetcherDoneAnything \": true\r\n      };\r\n      state.fetchers.set(key, doneFetcher);\r\n    }\r\n  }\r\n\r\n  return {\r\n    loaderData,\r\n    errors\r\n  };\r\n}\r\n\r\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\r\n  let mergedLoaderData = _extends({}, newLoaderData);\r\n\r\n  for (let match of matches) {\r\n    let id = match.route.id;\r\n\r\n    if (newLoaderData.hasOwnProperty(id)) {\r\n      if (newLoaderData[id] !== undefined) {\r\n        mergedLoaderData[id] = newLoaderData[id];\r\n      }\r\n    } else if (loaderData[id] !== undefined) {\r\n      mergedLoaderData[id] = loaderData[id];\r\n    }\r\n\r\n    if (errors && errors.hasOwnProperty(id)) {\r\n      // Don't keep any loader data below the boundary\r\n      break;\r\n    }\r\n  }\r\n\r\n  return mergedLoaderData;\r\n} // Find the nearest error boundary, looking upwards from the leaf route (or the\r\n// route specified by routeId) for the closest ancestor error boundary,\r\n// defaulting to the root match\r\n\r\n\r\nfunction findNearestBoundary(matches, routeId) {\r\n  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];\r\n  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];\r\n}\r\n\r\nfunction getShortCircuitMatches(routes) {\r\n  // Prefer a root layout route if present, otherwise shim in a route object\r\n  let route = routes.find(r => r.index || !r.path || r.path === \"/\") || {\r\n    id: \"__shim-error-route__\"\r\n  };\r\n  return {\r\n    matches: [{\r\n      params: {},\r\n      pathname: \"\",\r\n      pathnameBase: \"\",\r\n      route\r\n    }],\r\n    route\r\n  };\r\n}\r\n\r\nfunction getInternalRouterError(status, _temp4) {\r\n  let {\r\n    pathname,\r\n    routeId,\r\n    method,\r\n    type\r\n  } = _temp4 === void 0 ? {} : _temp4;\r\n  let statusText = \"Unknown Server Error\";\r\n  let errorMessage = \"Unknown @remix-run/router error\";\r\n\r\n  if (status === 400) {\r\n    statusText = \"Bad Request\";\r\n\r\n    if (method && pathname && routeId) {\r\n      errorMessage = \"You made a \" + method + \" request to \\\"\" + pathname + \"\\\" but \" + (\"did not provide a `loader` for route \\\"\" + routeId + \"\\\", \") + \"so there is no way to handle the request.\";\r\n    } else if (type === \"defer-action\") {\r\n      errorMessage = \"defer() is not supported in actions\";\r\n    }\r\n  } else if (status === 403) {\r\n    statusText = \"Forbidden\";\r\n    errorMessage = \"Route \\\"\" + routeId + \"\\\" does not match URL \\\"\" + pathname + \"\\\"\";\r\n  } else if (status === 404) {\r\n    statusText = \"Not Found\";\r\n    errorMessage = \"No route matches URL \\\"\" + pathname + \"\\\"\";\r\n  } else if (status === 405) {\r\n    statusText = \"Method Not Allowed\";\r\n\r\n    if (method && pathname && routeId) {\r\n      errorMessage = \"You made a \" + method.toUpperCase() + \" request to \\\"\" + pathname + \"\\\" but \" + (\"did not provide an `action` for route \\\"\" + routeId + \"\\\", \") + \"so there is no way to handle the request.\";\r\n    } else if (method) {\r\n      errorMessage = \"Invalid request method \\\"\" + method.toUpperCase() + \"\\\"\";\r\n    }\r\n  }\r\n\r\n  return new ErrorResponse(status || 500, statusText, new Error(errorMessage), true);\r\n} // Find any returned redirect errors, starting from the lowest match\r\n\r\n\r\nfunction findRedirect(results) {\r\n  for (let i = results.length - 1; i >= 0; i--) {\r\n    let result = results[i];\r\n\r\n    if (isRedirectResult(result)) {\r\n      return result;\r\n    }\r\n  }\r\n}\r\n\r\nfunction stripHashFromPath(path) {\r\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\r\n  return createPath(_extends({}, parsedPath, {\r\n    hash: \"\"\r\n  }));\r\n}\r\n\r\nfunction isHashChangeOnly(a, b) {\r\n  return a.pathname === b.pathname && a.search === b.search && a.hash !== b.hash;\r\n}\r\n\r\nfunction isDeferredResult(result) {\r\n  return result.type === ResultType.deferred;\r\n}\r\n\r\nfunction isErrorResult(result) {\r\n  return result.type === ResultType.error;\r\n}\r\n\r\nfunction isRedirectResult(result) {\r\n  return (result && result.type) === ResultType.redirect;\r\n}\r\n\r\nfunction isResponse(value) {\r\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\r\n}\r\n\r\nfunction isRedirectResponse(result) {\r\n  if (!isResponse(result)) {\r\n    return false;\r\n  }\r\n\r\n  let status = result.status;\r\n  let location = result.headers.get(\"Location\");\r\n  return status >= 300 && status <= 399 && location != null;\r\n}\r\n\r\nfunction isQueryRouteResponse(obj) {\r\n  return obj && isResponse(obj.response) && (obj.type === ResultType.data || ResultType.error);\r\n}\r\n\r\nfunction isValidMethod(method) {\r\n  return validRequestMethods.has(method);\r\n}\r\n\r\nfunction isMutationMethod(method) {\r\n  return validMutationMethods.has(method);\r\n}\r\n\r\nasync function resolveDeferredResults(currentMatches, matchesToLoad, results, signal, isFetcher, currentLoaderData) {\r\n  for (let index = 0; index < results.length; index++) {\r\n    let result = results[index];\r\n    let match = matchesToLoad[index];\r\n    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);\r\n    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\r\n\r\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\r\n      // Note: we do not have to touch activeDeferreds here since we race them\r\n      // against the signal in resolveDeferredData and they'll get aborted\r\n      // there if needed\r\n      await resolveDeferredData(result, signal, isFetcher).then(result => {\r\n        if (result) {\r\n          results[index] = result || results[index];\r\n        }\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nasync function resolveDeferredData(result, signal, unwrap) {\r\n  if (unwrap === void 0) {\r\n    unwrap = false;\r\n  }\r\n\r\n  let aborted = await result.deferredData.resolveData(signal);\r\n\r\n  if (aborted) {\r\n    return;\r\n  }\r\n\r\n  if (unwrap) {\r\n    try {\r\n      return {\r\n        type: ResultType.data,\r\n        data: result.deferredData.unwrappedData\r\n      };\r\n    } catch (e) {\r\n      // Handle any TrackedPromise._error values encountered while unwrapping\r\n      return {\r\n        type: ResultType.error,\r\n        error: e\r\n      };\r\n    }\r\n  }\r\n\r\n  return {\r\n    type: ResultType.data,\r\n    data: result.deferredData.data\r\n  };\r\n}\r\n\r\nfunction hasNakedIndexQuery(search) {\r\n  return new URLSearchParams(search).getAll(\"index\").some(v => v === \"\");\r\n} // Note: This should match the format exported by useMatches, so if you change\r\n// this please also change that :)  Eventually we'll DRY this up\r\n\r\n\r\nfunction createUseMatchesMatch(match, loaderData) {\r\n  let {\r\n    route,\r\n    pathname,\r\n    params\r\n  } = match;\r\n  return {\r\n    id: route.id,\r\n    pathname,\r\n    params,\r\n    data: loaderData[route.id],\r\n    handle: route.handle\r\n  };\r\n}\r\n\r\nfunction getTargetMatch(matches, location) {\r\n  let search = typeof location === \"string\" ? parsePath(location).search : location.search;\r\n\r\n  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\r\n    // Return the leaf index route when index is present\r\n    return matches[matches.length - 1];\r\n  } // Otherwise grab the deepest \"path contributing\" match (ignoring index and\r\n  // pathless layout routes)\r\n\r\n\r\n  let pathMatches = getPathContributingMatches(matches);\r\n  return pathMatches[pathMatches.length - 1];\r\n} //#endregion\r\n\r\nexport { AbortedDeferredError, Action, ErrorResponse, IDLE_BLOCKER, IDLE_FETCHER, IDLE_NAVIGATION, UNSAFE_DEFERRED_SYMBOL, DeferredData as UNSAFE_DeferredData, convertRoutesToDataRoutes as UNSAFE_convertRoutesToDataRoutes, getPathContributingMatches as UNSAFE_getPathContributingMatches, createBrowserHistory, createHashHistory, createMemoryHistory, createPath, createRouter, createStaticHandler, defer, generatePath, getStaticContextFromError, getToPathname, invariant, isRouteErrorResponse, joinPaths, json, matchPath, matchRoutes, normalizePathname, parsePath, redirect, resolvePath, resolveTo, stripBasename, warning };\r\n//# sourceMappingURL=router.js.map\r\n"],"names":["_extends","target","i","source","key","Action","PopStateEventType","createHashHistory","options","createHashLocation","window","globalHistory","pathname","search","hash","parsePath","createLocation","createHashHref","to","base","href","url","hashIndex","createPath","validateHashLocation","location","warning$1","getUrlBasedHistory","invariant","value","message","cond","createKey","getHistoryState","index","current","state","_ref","path","parsedPath","searchIndex","getLocation","createHref","validateLocation","v5Compat","action","listener","getIndex","handlePop","nextIndex","delta","history","push","historyState","replace","createURL","fn","n","ResultType","matchRoutes","routes","locationArg","basename","stripBasename","branches","flattenRoutes","rankRouteBranches","matches","matchRouteBranch","safelyDecodeURI","parentsMeta","parentPath","flattenRoute","route","relativePath","meta","joinPaths","routesMeta","computeScore","_route$path","exploded","explodeOptionalSegments","segments","first","rest","isOptional","required","restExploded","result","subpath","a","b","compareIndexes","paramRe","dynamicSegmentValue","indexRouteValue","emptySegmentValue","staticSegmentValue","splatPenalty","isSplat","s","initialScore","score","segment","branch","matchedParams","matchedPathname","end","remainingPathname","match","matchPath","normalizePathname","pattern","matcher","paramNames","compilePath","pathnameBase","captureGroups","memo","paramName","splatValue","safelyDecodeURIComponent","caseSensitive","warning","regexpSource","_","error","startIndex","nextChar","resolvePath","fromPathname","toPathname","resolvePathname","normalizeSearch","normalizeHash","getInvalidPathError","char","field","dest","getPathContributingMatches","resolveTo","toArg","routePathnames","locationPathname","isPathRelative","isEmptyPath","from","routePathnameIndex","toSegments","hasExplicitTrailingSlash","hasCurrentTrailingSlash","paths","isRouteErrorResponse","validMutationMethodsArr"],"mappings":"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"}
{"version":3,"file":"tabster-dacef0e4.js","sources":["../../../frontend/node_modules/tabster/dist/tabster.esm.js"],"sourcesContent":["import { nativeFocus, KEYBORG_FOCUSIN, createKeyborg, disposeKeyborg } from 'keyborg';\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst TabsterAttributeName = \"data-tabster\";\nconst TabsterDummyInputAttributeName = \"data-tabster-dummy\";\nconst DeloserEventName = \"tabster:deloser\";\nconst ModalizerActiveEventName = \"tabster:modalizer:active\";\nconst ModalizerInactiveEventName = \"tabster:modalizer:inactive\";\nconst ModalizerFocusInEventName = \"tabster:modalizer:focusin\";\nconst ModalizerFocusOutEventName = \"tabster:modalizer:focusout\";\nconst ModalizerBeforeFocusOutEventName = \"tabster:modalizer:beforefocusout\";\nconst MoverEventName = \"tabster:mover\";\nconst FocusInEventName = \"tabster:focusin\";\nconst FocusOutEventName = \"tabster:focusout\";\nconst ObservedElementAccesibilities = {\n  Any: 0,\n  Accessible: 1,\n  Focusable: 2\n};\nconst RestoreFocusOrders = {\n  History: 0,\n  DeloserDefault: 1,\n  RootDefault: 2,\n  DeloserFirst: 3,\n  RootFirst: 4\n};\nconst Visibilities = {\n  Invisible: 0,\n  PartiallyVisible: 1,\n  Visible: 2\n};\nconst MoverDirections = {\n  Both: 0,\n  Vertical: 1,\n  Horizontal: 2,\n  Grid: 3\n};\nconst GroupperTabbabilities = {\n  Unlimited: 0,\n  Limited: 1,\n  LimitedTrapFocus: 2\n};\nconst SysDummyInputsPositions = {\n  Auto: 0,\n  Inside: 1,\n  Outside: 2\n};\n\nvar Types = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    TabsterAttributeName: TabsterAttributeName,\n    TabsterDummyInputAttributeName: TabsterDummyInputAttributeName,\n    DeloserEventName: DeloserEventName,\n    ModalizerActiveEventName: ModalizerActiveEventName,\n    ModalizerInactiveEventName: ModalizerInactiveEventName,\n    ModalizerFocusInEventName: ModalizerFocusInEventName,\n    ModalizerFocusOutEventName: ModalizerFocusOutEventName,\n    ModalizerBeforeFocusOutEventName: ModalizerBeforeFocusOutEventName,\n    MoverEventName: MoverEventName,\n    FocusInEventName: FocusInEventName,\n    FocusOutEventName: FocusOutEventName,\n    ObservedElementAccesibilities: ObservedElementAccesibilities,\n    RestoreFocusOrders: RestoreFocusOrders,\n    Visibilities: Visibilities,\n    MoverDirections: MoverDirections,\n    GroupperTabbabilities: GroupperTabbabilities,\n    SysDummyInputsPositions: SysDummyInputsPositions\n});\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction getTabsterOnElement(tabster, element) {\n  var _a;\n\n  return (_a = tabster.storageEntry(element)) === null || _a === void 0 ? void 0 : _a.tabster;\n}\nfunction updateTabsterByAttribute(tabster, element, dispose) {\n  var _a, _b;\n\n  const newAttrValue = dispose || tabster._noop ? undefined : element.getAttribute(TabsterAttributeName);\n  let entry = tabster.storageEntry(element);\n  let newAttr;\n\n  if (newAttrValue) {\n    if (newAttrValue !== ((_a = entry === null || entry === void 0 ? void 0 : entry.attr) === null || _a === void 0 ? void 0 : _a.string)) {\n      try {\n        const newValue = JSON.parse(newAttrValue);\n\n        if (typeof newValue !== \"object\") {\n          throw new Error(`Value is not a JSON object, got '${newAttrValue}'.`);\n        }\n\n        newAttr = {\n          string: newAttrValue,\n          object: newValue\n        };\n      } catch (e) {\n        if (process.env.NODE_ENV === 'development') {\n          console.error(`data-tabster attribute error: ${e}`, element);\n        }\n      }\n    } else {\n      return;\n    }\n  } else if (!entry) {\n    return;\n  }\n\n  if (!entry) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    entry = tabster.storageEntry(element, true);\n  }\n\n  if (!entry.tabster) {\n    entry.tabster = {};\n  }\n\n  const tabsterOnElement = entry.tabster || {};\n  const oldTabsterProps = ((_b = entry.attr) === null || _b === void 0 ? void 0 : _b.object) || {};\n  const newTabsterProps = (newAttr === null || newAttr === void 0 ? void 0 : newAttr.object) || {};\n\n  for (const key of Object.keys(oldTabsterProps)) {\n    if (!newTabsterProps[key]) {\n      if (key === \"root\") {\n        const root = tabsterOnElement[key];\n\n        if (root) {\n          tabster.root.onRoot(root, true);\n        }\n      }\n\n      switch (key) {\n        case \"deloser\":\n        case \"root\":\n        case \"groupper\":\n        case \"modalizer\":\n        case \"mover\":\n          // eslint-disable-next-line no-case-declarations\n          const part = tabsterOnElement[key];\n\n          if (part) {\n            part.dispose();\n            delete tabsterOnElement[key];\n          }\n\n          break;\n\n        case \"observed\":\n          delete tabsterOnElement[key];\n\n          if (tabster.observedElement) {\n            tabster.observedElement.onObservedElementUpdate(element);\n          }\n\n          break;\n\n        case \"focusable\":\n        case \"outline\":\n        case \"uncontrolled\":\n        case \"sys\":\n          delete tabsterOnElement[key];\n          break;\n      }\n    }\n  }\n\n  for (const key of Object.keys(newTabsterProps)) {\n    const sys = newTabsterProps.sys;\n\n    switch (key) {\n      case \"deloser\":\n        if (tabsterOnElement.deloser) {\n          tabsterOnElement.deloser.setProps(newTabsterProps.deloser);\n        } else {\n          if (tabster.deloser) {\n            tabsterOnElement.deloser = tabster.deloser.createDeloser(element, newTabsterProps.deloser);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Deloser API used before initialization, please call `getDeloser()`\");\n          }\n        }\n\n        break;\n\n      case \"root\":\n        if (tabsterOnElement.root) {\n          tabsterOnElement.root.setProps(newTabsterProps.root);\n        } else {\n          tabsterOnElement.root = tabster.root.createRoot(element, newTabsterProps.root, sys);\n        }\n\n        tabster.root.onRoot(tabsterOnElement.root);\n        break;\n\n      case \"modalizer\":\n        if (tabsterOnElement.modalizer) {\n          tabsterOnElement.modalizer.setProps(newTabsterProps.modalizer);\n        } else {\n          if (tabster.modalizer) {\n            tabsterOnElement.modalizer = tabster.modalizer.createModalizer(element, newTabsterProps.modalizer, sys);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Modalizer API used before initialization, please call `getModalizer()`\");\n          }\n        }\n\n        break;\n\n      case \"focusable\":\n        tabsterOnElement.focusable = newTabsterProps.focusable;\n        break;\n\n      case \"groupper\":\n        if (tabsterOnElement.groupper) {\n          tabsterOnElement.groupper.setProps(newTabsterProps.groupper);\n        } else {\n          if (tabster.groupper) {\n            tabsterOnElement.groupper = tabster.groupper.createGroupper(element, newTabsterProps.groupper, sys);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Groupper API used before initialization, please call `getGroupper()`\");\n          }\n        }\n\n        break;\n\n      case \"mover\":\n        if (tabsterOnElement.mover) {\n          tabsterOnElement.mover.setProps(newTabsterProps.mover);\n        } else {\n          if (tabster.mover) {\n            tabsterOnElement.mover = tabster.mover.createMover(element, newTabsterProps.mover, sys);\n          } else if (process.env.NODE_ENV === 'development') {\n            console.error(\"Mover API used before initialization, please call `getMover()`\");\n          }\n        }\n\n        break;\n\n      case \"observed\":\n        if (tabster.observedElement) {\n          tabsterOnElement.observed = newTabsterProps.observed;\n          tabster.observedElement.onObservedElementUpdate(element);\n        } else if (process.env.NODE_ENV === 'development') {\n          console.error(\"ObservedElement API used before initialization, please call `getObservedElement()`\");\n        }\n\n        break;\n\n      case \"uncontrolled\":\n        tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;\n        break;\n\n      case \"outline\":\n        if (tabster.outline) {\n          tabsterOnElement.outline = newTabsterProps.outline;\n        } else if (process.env.NODE_ENV === 'development') {\n          console.error(\"Outline API used before initialization, please call `getOutline()`\");\n        }\n\n        break;\n\n      case \"sys\":\n        tabsterOnElement.sys = newTabsterProps.sys;\n        break;\n\n      default:\n        console.error(`Unknown key '${key}' in data-tabster attribute value.`);\n    }\n  }\n\n  if (newAttr) {\n    entry.attr = newAttr;\n  } else {\n    if (Object.keys(tabsterOnElement).length === 0) {\n      delete entry.tabster;\n      delete entry.attr;\n    }\n\n    tabster.storageEntry(element, false);\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction createEventTarget(getWindow) {\n  const global = getWindow();\n\n  try {\n    if (global.EventTarget) {\n      return new global.EventTarget();\n    }\n  } catch (error) {\n    // thrown if EventTarget is not constructable or doesn't exit\n    if (!(error instanceof TypeError)) {\n      throw error;\n    }\n  }\n\n  return global.document.createElement(\"div\");\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nlet _isBrokenIE11;\n\nconst _DOMRect = typeof DOMRect !== \"undefined\" ? DOMRect : class {\n  constructor(x, y, width, height) {\n    this.left = x || 0;\n    this.top = y || 0;\n    this.right = (x || 0) + (width || 0);\n    this.bottom = (y || 0) + (height || 0);\n  }\n\n};\n\nlet _uidCounter = 0;\n\ntry {\n  // IE11 only accepts `filter` argument as a function (not object with the `acceptNode`\n  // property as the docs define). Also `entityReferenceExpansion` argument is not\n  // optional. And it throws exception when the above arguments aren't there.\n  document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);\n  _isBrokenIE11 = false;\n} catch (e) {\n  _isBrokenIE11 = true;\n}\n\nconst _updateDummyInputsTimeout = 100;\nfunction getInstanceContext(getWindow) {\n  const win = getWindow();\n  let ctx = win.__tabsterInstanceContext;\n\n  if (!ctx) {\n    ctx = {\n      elementByUId: {},\n      basics: {\n        Promise: win.Promise || undefined,\n        WeakRef: win.WeakRef || undefined\n      },\n      containerBoundingRectCache: {},\n      lastContainerBoundingRectCacheId: 0,\n      fakeWeakRefs: [],\n      fakeWeakRefsStarted: false\n    };\n    win.__tabsterInstanceContext = ctx;\n  }\n\n  return ctx;\n}\nfunction disposeInstanceContext(win) {\n  const ctx = win.__tabsterInstanceContext;\n\n  if (ctx) {\n    ctx.elementByUId = {};\n    delete ctx.WeakRef;\n    ctx.containerBoundingRectCache = {};\n\n    if (ctx.containerBoundingRectCacheTimer) {\n      win.clearTimeout(ctx.containerBoundingRectCacheTimer);\n    }\n\n    if (ctx.fakeWeakRefsTimer) {\n      win.clearTimeout(ctx.fakeWeakRefsTimer);\n    }\n\n    ctx.fakeWeakRefs = [];\n    delete win.__tabsterInstanceContext;\n  }\n}\nfunction createWeakMap(win) {\n  const ctx = win.__tabsterInstanceContext;\n  return new ((ctx === null || ctx === void 0 ? void 0 : ctx.basics.WeakMap) || WeakMap)();\n}\n\nclass FakeWeakRef {\n  constructor(target) {\n    this._target = target;\n  }\n\n  deref() {\n    return this._target;\n  }\n\n  static cleanup(fwr, forceRemove) {\n    if (!fwr._target) {\n      return true;\n    }\n\n    if (forceRemove || !documentContains(fwr._target.ownerDocument, fwr._target)) {\n      delete fwr._target;\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nclass WeakHTMLElement {\n  constructor(getWindow, element, data) {\n    const context = getInstanceContext(getWindow);\n    let ref;\n\n    if (context.WeakRef) {\n      ref = new context.WeakRef(element);\n    } else {\n      ref = new FakeWeakRef(element);\n      context.fakeWeakRefs.push(ref);\n    }\n\n    this._ref = ref;\n    this._data = data;\n  }\n\n  get() {\n    const ref = this._ref;\n    let element;\n\n    if (ref) {\n      element = ref.deref();\n\n      if (!element) {\n        delete this._ref;\n      }\n    }\n\n    return element;\n  }\n\n  getData() {\n    return this._data;\n  }\n\n}\nfunction cleanupFakeWeakRefs(getWindow, forceRemove) {\n  const context = getInstanceContext(getWindow);\n  context.fakeWeakRefs = context.fakeWeakRefs.filter(e => !FakeWeakRef.cleanup(e, forceRemove));\n}\nfunction startFakeWeakRefsCleanup(getWindow) {\n  const context = getInstanceContext(getWindow);\n\n  if (!context.fakeWeakRefsStarted) {\n    context.fakeWeakRefsStarted = true;\n    context.WeakRef = getWeakRef(context);\n  }\n\n  if (!context.fakeWeakRefsTimer) {\n    context.fakeWeakRefsTimer = getWindow().setTimeout(() => {\n      context.fakeWeakRefsTimer = undefined;\n      cleanupFakeWeakRefs(getWindow);\n      startFakeWeakRefsCleanup(getWindow);\n    }, 2 * 60 * 1000); // 2 minutes.\n  }\n}\nfunction stopFakeWeakRefsCleanupAndClearStorage(getWindow) {\n  const context = getInstanceContext(getWindow);\n  context.fakeWeakRefsStarted = false;\n\n  if (context.fakeWeakRefsTimer) {\n    getWindow().clearTimeout(context.fakeWeakRefsTimer);\n    context.fakeWeakRefsTimer = undefined;\n    context.fakeWeakRefs = [];\n  }\n}\nfunction createElementTreeWalker(doc, root, acceptNode) {\n  // IE11 will throw an exception when the TreeWalker root is not an Element.\n  if (root.nodeType !== Node.ELEMENT_NODE) {\n    return undefined;\n  } // TypeScript isn't aware of IE11 behaving badly.\n\n\n  const filter = _isBrokenIE11 ? acceptNode : {\n    acceptNode\n  };\n  return doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filter, // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.\n  false\n  /* Last argument is not optional for IE11! */\n  );\n}\nfunction getBoundingRect(getWindow, element) {\n  let cacheId = element.__tabsterCacheId;\n  const context = getInstanceContext(getWindow);\n  const cached = cacheId ? context.containerBoundingRectCache[cacheId] : undefined;\n\n  if (cached) {\n    return cached.rect;\n  }\n\n  const scrollingElement = element.ownerDocument && element.ownerDocument.documentElement;\n\n  if (!scrollingElement) {\n    return new _DOMRect();\n  } // A bounding rect of the top-level element contains the whole page regardless of the\n  // scrollbar. So, we improvise a little and limiting the final result...\n\n\n  let left = 0;\n  let top = 0;\n  let right = scrollingElement.clientWidth;\n  let bottom = scrollingElement.clientHeight;\n\n  if (element !== scrollingElement) {\n    const r = element.getBoundingClientRect();\n    left = Math.max(left, r.left);\n    top = Math.max(top, r.top);\n    right = Math.min(right, r.right);\n    bottom = Math.min(bottom, r.bottom);\n  }\n\n  const rect = new _DOMRect(left < right ? left : -1, top < bottom ? top : -1, left < right ? right - left : 0, top < bottom ? bottom - top : 0);\n\n  if (!cacheId) {\n    cacheId = \"r-\" + ++context.lastContainerBoundingRectCacheId;\n    element.__tabsterCacheId = cacheId;\n  }\n\n  context.containerBoundingRectCache[cacheId] = {\n    rect,\n    element\n  };\n\n  if (!context.containerBoundingRectCacheTimer) {\n    context.containerBoundingRectCacheTimer = window.setTimeout(() => {\n      context.containerBoundingRectCacheTimer = undefined;\n\n      for (const cId of Object.keys(context.containerBoundingRectCache)) {\n        delete context.containerBoundingRectCache[cId].element.__tabsterCacheId;\n      }\n\n      context.containerBoundingRectCache = {};\n    }, 50);\n  }\n\n  return rect;\n}\nfunction isElementVerticallyVisibleInContainer(getWindow, element, tolerance) {\n  const container = getScrollableContainer(element);\n\n  if (!container) {\n    return false;\n  }\n\n  const containerRect = getBoundingRect(getWindow, container);\n  const elementRect = element.getBoundingClientRect();\n  const intersectionTolerance = elementRect.height * (1 - tolerance);\n  const topIntersection = Math.max(0, containerRect.top - elementRect.top);\n  const bottomIntersection = Math.max(0, elementRect.bottom - containerRect.bottom);\n  const totalIntersection = topIntersection + bottomIntersection;\n  return totalIntersection === 0 || totalIntersection <= intersectionTolerance;\n}\nfunction scrollIntoView(getWindow, element, alignToTop) {\n  // Built-in DOM's scrollIntoView() is cool, but when we have nested containers,\n  // it scrolls all of them, not just the deepest one. So, trying to work it around.\n  const container = getScrollableContainer(element);\n\n  if (container) {\n    const containerRect = getBoundingRect(getWindow, container);\n    const elementRect = element.getBoundingClientRect();\n\n    if (alignToTop) {\n      container.scrollTop += elementRect.top - containerRect.top;\n    } else {\n      container.scrollTop += elementRect.bottom - containerRect.bottom;\n    }\n  }\n}\nfunction getScrollableContainer(element) {\n  const doc = element.ownerDocument;\n\n  if (doc) {\n    for (let el = element.parentElement; el; el = el.parentElement) {\n      if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) {\n        return el;\n      }\n    }\n\n    return doc.documentElement;\n  }\n\n  return null;\n}\nfunction makeFocusIgnored(element) {\n  element.__shouldIgnoreFocus = true;\n}\nfunction shouldIgnoreFocus(element) {\n  return !!element.__shouldIgnoreFocus;\n}\nfunction getUId(wnd) {\n  const rnd = new Uint32Array(4);\n\n  if (wnd.crypto && wnd.crypto.getRandomValues) {\n    wnd.crypto.getRandomValues(rnd);\n  } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {\n    wnd.msCrypto.getRandomValues(rnd);\n  } else {\n    for (let i = 0; i < rnd.length; i++) {\n      rnd[i] = 0xffffffff * Math.random();\n    }\n  }\n\n  const srnd = [];\n\n  for (let i = 0; i < rnd.length; i++) {\n    srnd.push(rnd[i].toString(36));\n  }\n\n  srnd.push(\"|\");\n  srnd.push((++_uidCounter).toString(36));\n  srnd.push(\"|\");\n  srnd.push(Date.now().toString(36));\n  return srnd.join(\"\");\n}\nfunction getElementUId(getWindow, element) {\n  const context = getInstanceContext(getWindow);\n  let uid = element.__tabsterElementUID;\n\n  if (!uid) {\n    uid = element.__tabsterElementUID = getUId(getWindow());\n  }\n\n  if (!context.elementByUId[uid] && documentContains(element.ownerDocument, element)) {\n    context.elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n  }\n\n  return uid;\n}\nfunction getWindowUId(win) {\n  let uid = win.__tabsterCrossOriginWindowUID;\n\n  if (!uid) {\n    uid = win.__tabsterCrossOriginWindowUID = getUId(win);\n  }\n\n  return uid;\n}\nfunction clearElementCache(getWindow, parent) {\n  const context = getInstanceContext(getWindow);\n\n  for (const key of Object.keys(context.elementByUId)) {\n    const wel = context.elementByUId[key];\n    const el = wel && wel.get();\n\n    if (el && parent) {\n      if (!parent.contains(el)) {\n        continue;\n      }\n    }\n\n    delete context.elementByUId[key];\n  }\n} // IE11 doesn't have document.contains()...\n\nfunction documentContains(doc, element) {\n  var _a;\n\n  return !!((_a = doc === null || doc === void 0 ? void 0 : doc.body) === null || _a === void 0 ? void 0 : _a.contains(element));\n}\nfunction matchesSelector(element, selector) {\n  const matches = element.matches || element.matchesSelector || element.msMatchesSelector || element.webkitMatchesSelector;\n  return matches && matches.call(element, selector);\n}\nfunction getPromise(getWindow) {\n  const context = getInstanceContext(getWindow);\n\n  if (context.basics.Promise) {\n    return context.basics.Promise;\n  }\n\n  throw new Error(\"No Promise defined.\");\n}\nfunction getWeakRef(context) {\n  return context.basics.WeakRef;\n}\nlet _lastTabsterPartId = 0;\nclass TabsterPart {\n  constructor(tabster, element, props) {\n    const getWindow = tabster.getWindow;\n    this._tabster = tabster;\n    this._element = new WeakHTMLElement(getWindow, element);\n    this._props = { ...props\n    };\n    this.id = \"i\" + ++_lastTabsterPartId;\n  }\n\n  getElement() {\n    return this._element.get();\n  }\n\n  getProps() {\n    return this._props;\n  }\n\n  setProps(props) {\n    this._props = { ...props\n    };\n  }\n\n}\n/**\r\n * Dummy HTML elements that are used as focus sentinels for the DOM enclosed within them\r\n */\n\nclass DummyInput {\n  constructor(getWindow, isOutside, props, element) {\n    var _a;\n\n    this._focusIn = e => {\n      const input = this.input;\n\n      if (this.onFocusIn && input) {\n        const relatedTarget = DummyInputManager.getLastPhantomFrom() || e.relatedTarget;\n        this.onFocusIn(this, this._isBackward(true, input, relatedTarget), relatedTarget);\n      }\n    };\n\n    this._focusOut = e => {\n      this.useDefaultAction = false;\n      const input = this.input;\n\n      if (this.onFocusOut && input) {\n        const relatedTarget = e.relatedTarget;\n        this.onFocusOut(this, this._isBackward(false, input, relatedTarget), relatedTarget);\n      }\n    };\n\n    const win = getWindow();\n    const input = win.document.createElement(\"i\");\n    input.tabIndex = 0;\n    input.setAttribute(\"role\", \"none\");\n    input.setAttribute(TabsterDummyInputAttributeName, \"\");\n    input.setAttribute(\"aria-hidden\", \"true\");\n    const style = input.style;\n    style.position = \"fixed\";\n    style.width = style.height = \"1px\";\n    style.opacity = \"0.001\";\n    style.zIndex = \"-1\";\n    style.setProperty(\"content-visibility\", \"hidden\");\n    makeFocusIgnored(input);\n    this.input = input;\n    this.isFirst = props.isFirst;\n    this.isOutside = isOutside;\n    this._isPhantom = (_a = props.isPhantom) !== null && _a !== void 0 ? _a : false;\n    input.addEventListener(\"focusin\", this._focusIn);\n    input.addEventListener(\"focusout\", this._focusOut);\n    input.__tabsterDummyContainer = element;\n\n    if (this._isPhantom) {\n      this._disposeTimer = win.setTimeout(() => {\n        delete this._disposeTimer;\n        this.dispose();\n      }, 0);\n\n      this._clearDisposeTimeout = () => {\n        if (this._disposeTimer) {\n          win.clearTimeout(this._disposeTimer);\n          delete this._disposeTimer;\n        }\n\n        delete this._clearDisposeTimeout;\n      };\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    if (this._clearDisposeTimeout) {\n      this._clearDisposeTimeout();\n    }\n\n    const input = this.input;\n\n    if (!input) {\n      return;\n    }\n\n    delete this.onFocusIn;\n    delete this.onFocusOut;\n    delete this.input;\n    input.removeEventListener(\"focusin\", this._focusIn);\n    input.removeEventListener(\"focusout\", this._focusOut);\n    delete input.__tabsterDummyContainer;\n    (_a = input.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(input);\n  }\n\n  setTopLeft(top, left) {\n    var _a;\n\n    const style = (_a = this.input) === null || _a === void 0 ? void 0 : _a.style;\n\n    if (style) {\n      style.top = `${top}px`;\n      style.left = `${left}px`;\n    }\n  }\n\n  _isBackward(isIn, current, previous) {\n    return isIn && !previous ? !this.isFirst : !!(previous && current.compareDocumentPosition(previous) & Node.DOCUMENT_POSITION_FOLLOWING);\n  }\n\n}\nconst DummyInputManagerPriorities = {\n  Root: 1,\n  Modalizer: 2,\n  Mover: 3,\n  Groupper: 4\n};\nclass DummyInputManager {\n  constructor(tabster, element, priority, sys, outsideByDefault, callForDefaultAction) {\n    this._element = element;\n    this._instance = new DummyInputManagerCore(tabster, element, this, priority, sys, outsideByDefault, callForDefaultAction);\n\n    this.moveOut = backwards => {\n      var _a;\n\n      (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOut(backwards);\n    };\n\n    this.moveOutWithDefaultAction = backwards => {\n      var _a;\n\n      (_a = this._instance) === null || _a === void 0 ? void 0 : _a.moveOutWithDefaultAction(backwards);\n    };\n  }\n\n  _setHandlers(onFocusIn, onFocusOut) {\n    this._onFocusIn = onFocusIn;\n    this._onFocusOut = onFocusOut;\n  }\n\n  getHandler(isIn) {\n    return isIn ? this._onFocusIn : this._onFocusOut;\n  }\n\n  setTabbable(tabbable) {\n    var _a;\n\n    (_a = this._instance) === null || _a === void 0 ? void 0 : _a.setTabbable(this, tabbable);\n  }\n\n  dispose() {\n    if (this._instance) {\n      this._instance.dispose(this);\n\n      delete this._instance;\n    }\n\n    delete this._onFocusIn;\n    delete this._onFocusOut;\n  }\n\n  static getLastPhantomFrom() {\n    const ret = DummyInputManager._lastPhantomFrom;\n    delete DummyInputManager._lastPhantomFrom;\n    return ret;\n  }\n\n  static moveWithPhantomDummy(tabster, element, moveOutside, isBackward) {\n    const dummy = new DummyInput(tabster.getWindow, true, {\n      isPhantom: true,\n      isFirst: true\n    });\n    const input = dummy.input;\n\n    if (input) {\n      const parent = element.parentElement;\n\n      if (parent) {\n        let insertBefore = moveOutside && !isBackward || !moveOutside && isBackward ? element.nextElementSibling : element;\n\n        if (insertBefore) {\n          if (isBackward) {\n            const beforeBefore = insertBefore.previousElementSibling;\n\n            if (beforeBefore && beforeBefore.__tabsterDummyContainer) {\n              insertBefore = beforeBefore;\n            }\n          } else if (insertBefore.__tabsterDummyContainer) {\n            insertBefore = insertBefore.nextElementSibling;\n          }\n        }\n\n        parent.insertBefore(input, insertBefore);\n        DummyInputManager._lastPhantomFrom = element;\n        tabster.getWindow().setTimeout(() => {\n          delete DummyInputManager._lastPhantomFrom;\n        }, 0);\n        nativeFocus(input);\n      }\n    }\n  }\n\n}\n\nfunction setDummyInputDebugValue(dummy, wrappers) {\n  var _a;\n\n  const what = {\n    1: \"Root\",\n    2: \"Modalizer\",\n    3: \"Mover\",\n    4: \"Groupper\"\n  };\n  (_a = dummy.input) === null || _a === void 0 ? void 0 : _a.setAttribute(TabsterDummyInputAttributeName, [`isFirst=${dummy.isFirst}`, `isOutside=${dummy.isOutside}`, ...wrappers.map(w => `(${what[w.priority]}, tabbable=${w.tabbable})`)].join(\", \"));\n}\n\nclass DummyInputObserver {\n  constructor(win) {\n    this._updateQueue = new Set();\n    this._lastUpdateQueueTime = 0;\n    this._changedParents = new WeakSet();\n    this._dummies = new Map();\n\n    this._domChanged = parent => {\n      var _a;\n\n      if (this._changedParents.has(parent)) {\n        return;\n      }\n\n      this._changedParents.add(parent);\n\n      if (this._updateDummyInputsTimer) {\n        return;\n      }\n\n      this._updateDummyInputsTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {\n        delete this._updateDummyInputsTimer;\n\n        for (const [dummy, callback] of this._dummies) {\n          const dummyParent = dummy.parentElement;\n\n          if (!dummyParent || this._changedParents.has(dummyParent)) {\n            callback();\n          }\n        }\n\n        this._changedParents = new WeakSet();\n      }, _updateDummyInputsTimeout);\n    };\n\n    this._win = win;\n  }\n\n  add(dummy, callback) {\n    this._dummies.set(dummy, callback);\n\n    this.domChanged = this._domChanged;\n  }\n\n  remove(dummy) {\n    const dummyInputElements = this._dummies;\n    dummyInputElements.delete(dummy);\n\n    if (dummyInputElements.size === 0) {\n      delete this.domChanged;\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    const win = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this);\n\n    if (this._updateTimer) {\n      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n\n    if (this._updateDummyInputsTimer) {\n      win === null || win === void 0 ? void 0 : win.clearTimeout(this._updateDummyInputsTimer);\n      delete this._updateDummyInputsTimer;\n    }\n\n    this._changedParents = new WeakSet();\n\n    this._dummies.clear();\n\n    delete this._win;\n  }\n\n  updatePositions(compute) {\n    if (!this._win) {\n      // As this is a public method, we make sure that it has no effect when\n      // called after dispose().\n      return;\n    }\n\n    this._updateQueue.add(compute);\n\n    this._lastUpdateQueueTime = Date.now();\n\n    this._scheduledUpdatePositions();\n  }\n\n  _scheduledUpdatePositions() {\n    var _a;\n\n    if (this._updateTimer) {\n      return;\n    }\n\n    this._updateTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.call(this).setTimeout(() => {\n      delete this._updateTimer; // updatePositions() might be called quite a lot during the scrolling.\n      // So, instead of clearing the timeout and scheduling a new one, we\n      // check if enough time has passed since the last updatePositions() call\n      // and only schedule a new one if not.\n      // At maximum, we will update dummy inputs positions\n      // _updateDummyInputsTimeout * 2 after the last updatePositions() call.\n\n      if (this._lastUpdateQueueTime + _updateDummyInputsTimeout <= Date.now()) {\n        // A cache for current bulk of updates to reduce getComputedStyle() calls.\n        const scrollTopLeftCache = new Map();\n        const setTopLeftCallbacks = [];\n\n        for (const compute of this._updateQueue) {\n          setTopLeftCallbacks.push(compute(scrollTopLeftCache));\n        }\n\n        this._updateQueue.clear(); // We're splitting the computation of offsets and setting them to avoid extra\n        // reflows.\n\n\n        for (const setTopLeft of setTopLeftCallbacks) {\n          setTopLeft();\n        } // Explicitly clear to not hold references till the next garbage collection.\n\n\n        scrollTopLeftCache.clear();\n      } else {\n        this._scheduledUpdatePositions();\n      }\n    }, _updateDummyInputsTimeout);\n  }\n\n}\n/**\r\n * Parent class that encapsulates the behaviour of dummy inputs (focus sentinels)\r\n */\n\nclass DummyInputManagerCore {\n  constructor(tabster, element, manager, priority, sys, outsideByDefault, callForDefaultAction) {\n    this._wrappers = [];\n    this._isOutside = false;\n    this._transformElements = new Set();\n\n    this._onFocusIn = (dummyInput, isBackward, relatedTarget) => {\n      this._onFocus(true, dummyInput, isBackward, relatedTarget);\n    };\n\n    this._onFocusOut = (dummyInput, isBackward, relatedTarget) => {\n      this._onFocus(false, dummyInput, isBackward, relatedTarget);\n    };\n\n    this.moveOut = backwards => {\n      var _a;\n\n      const first = this._firstDummy;\n      const last = this._lastDummy;\n\n      if (first && last) {\n        const firstInput = first.input;\n        const lastInput = last.input;\n        const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n\n        if (firstInput && lastInput && element) {\n          let toFocus;\n\n          if (backwards) {\n            firstInput.tabIndex = 0;\n            toFocus = firstInput;\n          } else {\n            lastInput.tabIndex = 0;\n            toFocus = lastInput;\n          }\n\n          if (toFocus) {\n            nativeFocus(toFocus);\n          }\n        }\n      }\n    };\n    /**\r\n     * Prepares to move focus out of the given element by focusing\r\n     * one of the dummy inputs and setting the `useDefaultAction` flag\r\n     * @param backwards focus moving to an element behind the given element\r\n     */\n\n\n    this.moveOutWithDefaultAction = backwards => {\n      var _a;\n\n      const first = this._firstDummy;\n      const last = this._lastDummy;\n\n      if (first && last) {\n        const firstInput = first.input;\n        const lastInput = last.input;\n        const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n\n        if (firstInput && lastInput && element) {\n          let toFocus;\n\n          if (backwards) {\n            if (!first.isOutside && this._tabster.focusable.isFocusable(element, true, true, true)) {\n              toFocus = element;\n            } else {\n              first.useDefaultAction = true;\n              firstInput.tabIndex = 0;\n              toFocus = firstInput;\n            }\n          } else {\n            last.useDefaultAction = true;\n            lastInput.tabIndex = 0;\n            toFocus = lastInput;\n          }\n\n          if (toFocus) {\n            nativeFocus(toFocus);\n          }\n        }\n      }\n    };\n\n    this.setTabbable = (manager, tabbable) => {\n      var _a, _b;\n\n      for (const w of this._wrappers) {\n        if (w.manager === manager) {\n          w.tabbable = tabbable;\n          break;\n        }\n      }\n\n      const wrapper = this._getCurrent();\n\n      if (wrapper) {\n        const tabIndex = wrapper.tabbable ? 0 : -1;\n        let input = (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input;\n\n        if (input) {\n          input.tabIndex = tabIndex;\n        }\n\n        input = (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input;\n\n        if (input) {\n          input.tabIndex = tabIndex;\n        }\n      }\n\n      if (process.env.NODE_ENV === 'development') {\n        this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);\n        this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);\n      }\n    };\n    /**\r\n     * Adds dummy inputs as the first and last child of the given element\r\n     * Called each time the children under the element is mutated\r\n     */\n\n\n    this._addDummyInputs = () => {\n      if (this._addTimer) {\n        return;\n      }\n\n      this._addTimer = this._getWindow().setTimeout(() => {\n        var _a, _b, _c;\n\n        delete this._addTimer;\n        const element = (_a = this._element) === null || _a === void 0 ? void 0 : _a.get();\n        const dif = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;\n        const dil = (_c = this._lastDummy) === null || _c === void 0 ? void 0 : _c.input;\n\n        if (!element || !dif || !dil) {\n          return;\n        }\n\n        if (this._isOutside) {\n          const elementParent = element.parentElement;\n\n          if (elementParent) {\n            const nextSibling = element.nextElementSibling;\n\n            if (nextSibling !== dil) {\n              elementParent.insertBefore(dil, nextSibling);\n            }\n\n            if (element.previousElementSibling !== dif) {\n              elementParent.insertBefore(dif, element);\n            }\n          }\n        } else {\n          if (element.lastElementChild !== dil) {\n            element.appendChild(dil);\n          }\n\n          const firstElementChild = element.firstElementChild;\n\n          if (firstElementChild && firstElementChild !== dif) {\n            element.insertBefore(dif, firstElementChild);\n          }\n        }\n\n        if (process.env.NODE_ENV === 'development') {\n          this._firstDummy && setDummyInputDebugValue(this._firstDummy, this._wrappers);\n          this._lastDummy && setDummyInputDebugValue(this._lastDummy, this._wrappers);\n        }\n\n        this._addTransformOffsets();\n      }, 0);\n    };\n\n    this._addTransformOffsets = () => {\n      this._tabster._dummyObserver.updatePositions(this._computeTransformOffsets);\n    };\n\n    this._computeTransformOffsets = scrollTopLeftCache => {\n      var _a, _b;\n\n      const from = ((_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.input) || ((_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.input);\n      const transformElements = this._transformElements;\n      const newTransformElements = new Set();\n      let scrollTop = 0;\n      let scrollLeft = 0;\n\n      const win = this._getWindow();\n\n      for (let element = from; element; element = element.parentElement) {\n        let scrollTopLeft = scrollTopLeftCache.get(element); // getComputedStyle() and element.scrollLeft/Top() cause style recalculation,\n        // so we cache the result across all elements in the current bulk.\n\n        if (scrollTopLeft === undefined) {\n          const transform = win.getComputedStyle(element).transform;\n\n          if (transform && transform !== \"none\") {\n            scrollTopLeft = {\n              scrollTop: element.scrollTop,\n              scrollLeft: element.scrollLeft\n            };\n          }\n\n          scrollTopLeftCache.set(element, scrollTopLeft || null);\n        }\n\n        if (scrollTopLeft) {\n          newTransformElements.add(element);\n\n          if (!transformElements.has(element)) {\n            element.addEventListener(\"scroll\", this._addTransformOffsets);\n          }\n\n          scrollTop += scrollTopLeft.scrollTop;\n          scrollLeft += scrollTopLeft.scrollLeft;\n        }\n      }\n\n      for (const el of transformElements) {\n        if (!newTransformElements.has(el)) {\n          el.removeEventListener(\"scroll\", this._addTransformOffsets);\n        }\n      }\n\n      this._transformElements = newTransformElements;\n      return () => {\n        var _a, _b;\n\n        (_a = this._firstDummy) === null || _a === void 0 ? void 0 : _a.setTopLeft(scrollTop, scrollLeft);\n        (_b = this._lastDummy) === null || _b === void 0 ? void 0 : _b.setTopLeft(scrollTop, scrollLeft);\n      };\n    };\n\n    const el = element.get();\n\n    if (!el) {\n      throw new Error(\"No element\");\n    }\n\n    this._tabster = tabster;\n    this._getWindow = tabster.getWindow;\n    this._callForDefaultAction = callForDefaultAction;\n    const instance = el.__tabsterDummy;\n\n    (instance || this)._wrappers.push({\n      manager,\n      priority,\n      tabbable: true\n    });\n\n    if (instance) {\n      if (process.env.NODE_ENV === 'development') {\n        this._firstDummy && setDummyInputDebugValue(this._firstDummy, instance._wrappers);\n        this._lastDummy && setDummyInputDebugValue(this._lastDummy, instance._wrappers);\n      }\n\n      return instance;\n    }\n\n    el.__tabsterDummy = this; // Some elements allow only specific types of direct descendants and we need to\n    // put our dummy inputs inside or outside of the element accordingly.\n\n    const forcedDummyPosition = sys === null || sys === void 0 ? void 0 : sys.dummyInputsPosition;\n    const tagName = el.tagName;\n    this._isOutside = !forcedDummyPosition ? (outsideByDefault || tagName === \"UL\" || tagName === \"OL\" || tagName === \"TABLE\") && !(tagName === \"LI\" || tagName === \"TD\" || tagName === \"TH\") : forcedDummyPosition === SysDummyInputsPositions.Outside;\n    this._firstDummy = new DummyInput(this._getWindow, this._isOutside, {\n      isFirst: true\n    }, element);\n    this._lastDummy = new DummyInput(this._getWindow, this._isOutside, {\n      isFirst: false\n    }, element); // We will be checking dummy input parents to see if their child list have changed.\n    // So, it is enough to have just one of the inputs observed, because\n    // both dummy inputs always have the same parent.\n\n    const dummyElement = this._firstDummy.input;\n    dummyElement && tabster._dummyObserver.add(dummyElement, this._addDummyInputs);\n    this._firstDummy.onFocusIn = this._onFocusIn;\n    this._firstDummy.onFocusOut = this._onFocusOut;\n    this._lastDummy.onFocusIn = this._onFocusIn;\n    this._lastDummy.onFocusOut = this._onFocusOut;\n    this._element = element;\n\n    this._addDummyInputs();\n  }\n\n  dispose(manager, force) {\n    var _a, _b, _c, _d;\n\n    const wrappers = this._wrappers = this._wrappers.filter(w => w.manager !== manager && !force);\n\n    if (process.env.NODE_ENV === 'development') {\n      this._firstDummy && setDummyInputDebugValue(this._firstDummy, wrappers);\n      this._lastDummy && setDummyInputDebugValue(this._lastDummy, wrappers);\n    }\n\n    if (wrappers.length === 0) {\n      delete ((_a = this._element) === null || _a === void 0 ? void 0 : _a.get()).__tabsterDummy;\n\n      for (const el of this._transformElements) {\n        el.removeEventListener(\"scroll\", this._addTransformOffsets);\n      }\n\n      this._transformElements.clear();\n\n      const win = this._getWindow();\n\n      if (this._addTimer) {\n        win.clearTimeout(this._addTimer);\n        delete this._addTimer;\n      }\n\n      const dummyElement = (_b = this._firstDummy) === null || _b === void 0 ? void 0 : _b.input;\n      dummyElement && this._tabster._dummyObserver.remove(dummyElement);\n      (_c = this._firstDummy) === null || _c === void 0 ? void 0 : _c.dispose();\n      (_d = this._lastDummy) === null || _d === void 0 ? void 0 : _d.dispose();\n    }\n  }\n\n  _onFocus(isIn, dummyInput, isBackward, relatedTarget) {\n    var _a;\n\n    const wrapper = this._getCurrent();\n\n    if (wrapper && (!dummyInput.useDefaultAction || this._callForDefaultAction)) {\n      (_a = wrapper.manager.getHandler(isIn)) === null || _a === void 0 ? void 0 : _a(dummyInput, isBackward, relatedTarget);\n    }\n  }\n\n  _getCurrent() {\n    this._wrappers.sort((a, b) => {\n      if (a.tabbable !== b.tabbable) {\n        return a.tabbable ? -1 : 1;\n      }\n\n      return a.priority - b.priority;\n    });\n\n    return this._wrappers[0];\n  }\n\n}\n\nfunction getLastChild(container) {\n  let lastChild = null;\n\n  for (let i = container.lastElementChild; i; i = i.lastElementChild) {\n    lastChild = i;\n  }\n\n  return lastChild || undefined;\n}\nfunction getAdjacentElement(from, prev) {\n  let cur = from;\n  let adjacent = null;\n\n  while (cur && !adjacent) {\n    adjacent = prev ? cur.previousElementSibling : cur.nextElementSibling;\n    cur = cur.parentElement;\n  }\n\n  return adjacent || undefined;\n}\nfunction triggerEvent(target, name, details) {\n  const event = document.createEvent(\"HTMLEvents\");\n  event.initEvent(name, true, true);\n  event.details = details;\n  target.dispatchEvent(event);\n  return !event.defaultPrevented;\n}\nfunction augmentAttribute(tabster, element, name, value // Restore original value when undefined.\n) {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const entry = tabster.storageEntry(element, true);\n  let ret = false;\n\n  if (!entry.aug) {\n    if (value === undefined) {\n      return ret;\n    }\n\n    entry.aug = {};\n  }\n\n  if (value === undefined) {\n    if (name in entry.aug) {\n      const origVal = entry.aug[name];\n      delete entry.aug[name];\n\n      if (origVal === null) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, origVal);\n      }\n\n      ret = true;\n    }\n  } else {\n    let origValue;\n\n    if (!(name in entry.aug)) {\n      origValue = element.getAttribute(name);\n    }\n\n    if (origValue !== undefined && origValue !== value) {\n      entry.aug[name] = origValue;\n\n      if (value === null) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value);\n      }\n\n      ret = true;\n    }\n  }\n\n  if (value === undefined && Object.keys(entry.aug).length === 0) {\n    delete entry.aug;\n    tabster.storageEntry(element, false);\n  }\n\n  return ret;\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction getTabsterAttribute(props, plain) {\n  const attr = JSON.stringify(props);\n\n  if (plain === true) {\n    return attr;\n  }\n\n  return {\n    [TabsterAttributeName]: attr\n  };\n}\n/**\r\n * Updates Tabster props object with new props.\r\n * @param element an element to set data-tabster attribute on.\r\n * @param props current Tabster props to update.\r\n * @param newProps new Tabster props to add.\r\n *  When the value of a property in newProps is undefined, the property\r\n *  will be removed from the attribute.\r\n */\n\nfunction mergeTabsterProps(props, newProps) {\n  for (const key of Object.keys(newProps)) {\n    const value = newProps[key];\n\n    if (value) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      props[key] = value;\n    } else {\n      delete props[key];\n    }\n  }\n}\n/**\r\n * Sets or updates Tabster attribute of the element.\r\n * @param element an element to set data-tabster attribute on.\r\n * @param newProps new Tabster props to set.\r\n * @param update if true, newProps will be merged with the existing props.\r\n *  When true and the value of a property in newProps is undefined, the property\r\n *  will be removed from the attribute.\r\n */\n\nfunction setTabsterAttribute(element, newProps, update) {\n  let props;\n\n  if (update) {\n    const attr = element.getAttribute(TabsterAttributeName);\n\n    if (attr) {\n      try {\n        props = JSON.parse(attr);\n      } catch (e) {\n        if (process.env.NODE_ENV === 'development') {\n          console.error(`data-tabster attribute error: ${e}`, element);\n        }\n      }\n    }\n  }\n\n  if (!props) {\n    props = {};\n  }\n\n  mergeTabsterProps(props, newProps);\n\n  if (Object.keys(props).length > 0) {\n    element.setAttribute(TabsterAttributeName, getTabsterAttribute(props, true));\n  } else {\n    element.removeAttribute(TabsterAttributeName);\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nfunction _setInformativeStyle$3(weakElement, remove, id) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-root\");\n      } else {\n        element.style.setProperty(\"--tabster-root\", id + \",\");\n      }\n    }\n  }\n}\n\nclass RootDummyManager extends DummyInputManager {\n  constructor(tabster, element, setFocused, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Root, sys, undefined, true);\n\n    this._onDummyInputFocus = dummyInput => {\n      var _a;\n\n      if (dummyInput.useDefaultAction) {\n        // When we've reached the last focusable element, we want to let the browser\n        // to move the focus outside of the page. In order to do that we're synchronously\n        // calling focus() of the dummy input from the Tab key handler and allowing\n        // the default action to move the focus out.\n        this._setFocused(false, true);\n      } else {\n        // The only way a dummy input gets focused is during the keyboard navigation.\n        this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);\n\n        const element = this._element.get();\n\n        if (element) {\n          this._setFocused(true, true);\n\n          const toFocus = this._tabster.focusedElement.getFirstOrLastTabbable(dummyInput.isFirst, {\n            container: element,\n            ignoreAccessibility: true\n          });\n\n          if (toFocus) {\n            nativeFocus(toFocus);\n            return;\n          }\n        }\n\n        (_a = dummyInput.input) === null || _a === void 0 ? void 0 : _a.blur();\n      }\n    };\n\n    this._setHandlers(this._onDummyInputFocus);\n\n    this._tabster = tabster;\n    this._setFocused = setFocused;\n  }\n\n}\n\nclass Root extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    super(tabster, element, props);\n    this._isFocused = false;\n\n    this._setFocused = (hasFocused, fromAdjacent) => {\n      if (this._setFocusedTimer) {\n        this._tabster.getWindow().clearTimeout(this._setFocusedTimer);\n\n        delete this._setFocusedTimer;\n      }\n\n      if (this._isFocused === hasFocused) {\n        return;\n      }\n\n      const element = this._element.get();\n\n      if (element) {\n        if (hasFocused) {\n          this._isFocused = true;\n          triggerEvent(this._tabster.root.eventTarget, \"focus\", {\n            element,\n            fromAdjacent\n          });\n        } else {\n          this._setFocusedTimer = this._tabster.getWindow().setTimeout(() => {\n            delete this._setFocusedTimer;\n            this._isFocused = false;\n            triggerEvent(this._tabster.root.eventTarget, \"blur\", {\n              element,\n              fromAdjacent\n            });\n          }, 0);\n        }\n      }\n    };\n\n    this._onFocus = e => {\n      var _a;\n\n      const win = this._tabster.getWindow();\n\n      if (this._setTabbableTimer) {\n        win.clearTimeout(this._setTabbableTimer);\n        delete this._setTabbableTimer;\n      }\n\n      if (e) {\n        const ctx = RootAPI.getTabsterContext(this._tabster, e);\n\n        if (ctx) {\n          this._setFocused(ctx.root.getElement() === this._element.get());\n        }\n\n        if (!ctx || ctx.uncontrolled || this._tabster.rootDummyInputs) {\n          (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(false);\n          return;\n        }\n      } else {\n        this._setFocused(false);\n      }\n\n      this._setTabbableTimer = win.setTimeout(() => {\n        var _a;\n\n        delete this._setTabbableTimer;\n        (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.setTabbable(true);\n      }, 0);\n    };\n\n    this._onDispose = onDispose;\n    const win = tabster.getWindow;\n    this.uid = getElementUId(win, element);\n    this._sys = sys;\n\n    if (tabster.controlTab || tabster.rootDummyInputs) {\n      this.addDummyInputs();\n    }\n\n    tabster.focusedElement.subscribe(this._onFocus);\n\n    this._add();\n  }\n\n  addDummyInputs() {\n    if (!this._dummyManager) {\n      this._dummyManager = new RootDummyManager(this._tabster, this._element, this._setFocused, this._sys);\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    this._onDispose(this);\n\n    const win = this._tabster.getWindow();\n\n    if (this._setFocusedTimer) {\n      win.clearTimeout(this._setFocusedTimer);\n      delete this._setFocusedTimer;\n    }\n\n    if (this._setTabbableTimer) {\n      win.clearTimeout(this._setTabbableTimer);\n      delete this._setTabbableTimer;\n    }\n\n    (_a = this._dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n\n    this._remove();\n  }\n\n  moveOutWithDefaultAction(isBackward) {\n    const dummyManager = this._dummyManager;\n\n    if (dummyManager) {\n      dummyManager.moveOutWithDefaultAction(isBackward);\n    } else {\n      const el = this.getElement();\n\n      if (el) {\n        RootDummyManager.moveWithPhantomDummy(this._tabster, el, true, isBackward);\n      }\n    }\n  }\n\n  _add() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$3(this._element, false, this.uid);\n    }\n  }\n\n  _remove() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$3(this._element, true);\n    }\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass RootAPI {\n  constructor(tabster, autoRoot) {\n    this._autoRootWaiting = false;\n    this._roots = {};\n    this._forceDummy = false;\n    this.rootById = {};\n\n    this._autoRootCreate = () => {\n      var _a;\n\n      const doc = this._win().document;\n\n      const body = doc.body;\n\n      if (body) {\n        this._autoRootUnwait(doc);\n\n        const props = this._autoRoot;\n\n        if (props) {\n          setTabsterAttribute(body, {\n            root: props\n          }, true);\n          updateTabsterByAttribute(this._tabster, body);\n          return (_a = getTabsterOnElement(this._tabster, body)) === null || _a === void 0 ? void 0 : _a.root;\n        }\n      } else if (!this._autoRootWaiting) {\n        this._autoRootWaiting = true;\n        doc.addEventListener(\"readystatechange\", this._autoRootCreate);\n      }\n\n      return undefined;\n    };\n\n    this._onRootDispose = root => {\n      delete this._roots[root.id];\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._autoRoot = autoRoot;\n    this.eventTarget = createEventTarget(this._win);\n    tabster.queueInit(() => {\n      if (this._autoRoot) {\n        this._autoRootCreate();\n      }\n    });\n  }\n\n  _autoRootUnwait(doc) {\n    doc.removeEventListener(\"readystatechange\", this._autoRootCreate);\n    this._autoRootWaiting = false;\n  }\n\n  dispose() {\n    const win = this._win();\n\n    this._autoRootUnwait(win.document);\n\n    delete this._autoRoot;\n    Object.keys(this._roots).forEach(rootId => {\n      if (this._roots[rootId]) {\n        this._roots[rootId].dispose();\n\n        delete this._roots[rootId];\n      }\n    });\n    this.rootById = {};\n  }\n\n  createRoot(element, props, sys) {\n    if (process.env.NODE_ENV === 'development') ;\n\n    const newRoot = new Root(this._tabster, element, this._onRootDispose, props, sys);\n    this._roots[newRoot.id] = newRoot;\n\n    if (this._forceDummy) {\n      newRoot.addDummyInputs();\n    }\n\n    return newRoot;\n  }\n\n  addDummyInputs() {\n    this._forceDummy = true;\n    const roots = this._roots;\n\n    for (const id of Object.keys(roots)) {\n      roots[id].addDummyInputs();\n    }\n  }\n\n  static getRootByUId(getWindow, id) {\n    const tabster = getWindow().__tabsterInstance;\n\n    return tabster && tabster.root.rootById[id];\n  }\n  /**\r\n   * Fetches the tabster context for an element walking up its ancestors\r\n   *\r\n   * @param tabster Tabster instance\r\n   * @param element The element the tabster context should represent\r\n   * @param options Additional options\r\n   * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations\r\n   */\n\n\n  static getTabsterContext(tabster, element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _a, _b, _c, _d;\n\n    if (!element.ownerDocument) {\n      return undefined;\n    } // Normally, the initialization starts on the next tick after the tabster\n    // instance creation. However, if the application starts using it before\n    // the next tick, we need to make sure the initialization is done.\n\n\n    tabster.drainInitQueue();\n    const checkRtl = options.checkRtl;\n    let root;\n    let modalizer;\n    let groupper;\n    let mover;\n    let isExcludedFromMover = false;\n    let isGroupperFirst;\n    let modalizerInGroupper;\n    let isRtl;\n    let uncontrolled;\n    let curElement = element;\n    const ignoreKeydown = {};\n\n    while (curElement && (!root || checkRtl)) {\n      const tabsterOnElement = getTabsterOnElement(tabster, curElement);\n\n      if (checkRtl && isRtl === undefined) {\n        const dir = curElement.dir;\n\n        if (dir) {\n          isRtl = dir.toLowerCase() === \"rtl\";\n        }\n      }\n\n      if (!tabsterOnElement) {\n        curElement = curElement.parentElement;\n        continue;\n      }\n\n      const tagName = curElement.tagName;\n\n      if (tabsterOnElement.uncontrolled || tagName === \"IFRAME\" || tagName === \"WEBVIEW\") {\n        uncontrolled = curElement;\n      }\n\n      if (!mover && ((_a = tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.excludeFromMover) && !groupper) {\n        isExcludedFromMover = true;\n      }\n\n      const curModalizer = tabsterOnElement.modalizer;\n      const curGroupper = tabsterOnElement.groupper;\n      const curMover = tabsterOnElement.mover;\n\n      if (!modalizer && curModalizer) {\n        modalizer = curModalizer;\n      }\n\n      if (!groupper && curGroupper && (!modalizer || curModalizer)) {\n        if (modalizer) {\n          // Modalizer dominates the groupper when they are on the same node and the groupper is active.\n          if (!curGroupper.isActive() && curGroupper.getProps().tabbability && modalizer.userId !== ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n            modalizer = undefined;\n            groupper = curGroupper;\n          }\n\n          modalizerInGroupper = curGroupper;\n        } else {\n          groupper = curGroupper;\n        }\n      }\n\n      if (!mover && curMover && (!modalizer || curModalizer) && (!curGroupper || curElement !== element)) {\n        mover = curMover;\n        isGroupperFirst = !!groupper && groupper !== curGroupper;\n      }\n\n      if (tabsterOnElement.root) {\n        root = tabsterOnElement.root;\n      }\n\n      if ((_c = tabsterOnElement.focusable) === null || _c === void 0 ? void 0 : _c.ignoreKeydown) {\n        Object.assign(ignoreKeydown, tabsterOnElement.focusable.ignoreKeydown);\n      }\n\n      curElement = curElement.parentElement;\n    } // No root element could be found, try to get an auto root\n\n\n    if (!root) {\n      const rootAPI = tabster.root;\n      const autoRoot = rootAPI._autoRoot;\n\n      if (autoRoot) {\n        if ((_d = element.ownerDocument) === null || _d === void 0 ? void 0 : _d.body) {\n          root = rootAPI._autoRootCreate();\n        }\n      }\n    }\n\n    if (groupper && !mover) {\n      isGroupperFirst = true;\n    }\n\n    if (process.env.NODE_ENV === 'development' && !root) {\n      if (modalizer || groupper || mover) {\n        console.error(\"Tabster Root is required for Mover, Groupper and Modalizer to work.\");\n      }\n    }\n\n    const shouldIgnoreKeydown = event => !!ignoreKeydown[event.key];\n\n    return root ? {\n      root,\n      modalizer,\n      groupper,\n      mover,\n      isGroupperFirst,\n      modalizerInGroupper,\n      isRtl: checkRtl ? !!isRtl : undefined,\n      uncontrolled,\n      isExcludedFromMover,\n      ignoreKeydown: shouldIgnoreKeydown\n    } : undefined;\n  }\n\n  static getRoot(tabster, element) {\n    var _a;\n\n    for (let el = element; el; el = el.parentElement) {\n      const root = (_a = getTabsterOnElement(tabster, el)) === null || _a === void 0 ? void 0 : _a.root;\n\n      if (root) {\n        return root;\n      }\n    }\n\n    return undefined;\n  }\n\n  onRoot(root, removed) {\n    if (removed) {\n      delete this.rootById[root.uid];\n    } else {\n      this.rootById[root.uid] = root;\n    }\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst _containerHistoryLength = 10;\nclass DeloserItemBase {}\nclass DeloserItem extends DeloserItemBase {\n  constructor(tabster, deloser) {\n    super();\n    this.uid = deloser.uid;\n    this._tabster = tabster;\n    this._deloser = deloser;\n  }\n\n  belongsTo(deloser) {\n    return deloser === this._deloser;\n  }\n\n  unshift(element) {\n    this._deloser.unshift(element);\n  }\n\n  async focusAvailable() {\n    const available = this._deloser.findAvailable();\n\n    return available ? this._tabster.focusedElement.focus(available) : false;\n  }\n\n  async resetFocus() {\n    const getWindow = this._tabster.getWindow;\n    return getPromise(getWindow).resolve(this._deloser.resetFocus());\n  }\n\n}\nclass DeloserHistoryByRootBase {\n  constructor(tabster, rootUId) {\n    this._history = [];\n    this._tabster = tabster;\n    this.rootUId = rootUId;\n  }\n\n  getLength() {\n    return this._history.length;\n  }\n\n  removeDeloser(deloser) {\n    this._history = this._history.filter(c => !c.belongsTo(deloser));\n  }\n\n  hasDeloser(deloser) {\n    return this._history.some(d => d.belongsTo(deloser));\n  }\n\n}\n\nclass DeloserHistoryByRoot extends DeloserHistoryByRootBase {\n  unshiftToDeloser(deloser, element) {\n    let item;\n\n    for (let i = 0; i < this._history.length; i++) {\n      if (this._history[i].belongsTo(deloser)) {\n        item = this._history[i];\n\n        this._history.splice(i, 1);\n\n        break;\n      }\n    }\n\n    if (!item) {\n      item = new DeloserItem(this._tabster, deloser);\n    }\n\n    item.unshift(element);\n\n    this._history.unshift(item);\n\n    this._history.splice(_containerHistoryLength, this._history.length - _containerHistoryLength);\n  }\n\n  async focusAvailable(from) {\n    let skip = !!from;\n\n    for (const i of this._history) {\n      if (from && i.belongsTo(from)) {\n        skip = false;\n      }\n\n      if (!skip && (await i.focusAvailable())) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  async resetFocus(from) {\n    let skip = !!from;\n    const resetQueue = {};\n\n    for (const i of this._history) {\n      if (from && i.belongsTo(from)) {\n        skip = false;\n      }\n\n      if (!skip && !resetQueue[i.uid]) {\n        resetQueue[i.uid] = i;\n      }\n    } // Nothing is found, at least try to reset.\n\n\n    for (const id of Object.keys(resetQueue)) {\n      if (await resetQueue[id].resetFocus()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nclass DeloserHistory {\n  constructor(tabster) {\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    this._history = [];\n    this._tabster = tabster;\n  }\n\n  dispose() {\n    this._history = [];\n  }\n\n  process(element) {\n    var _a;\n\n    const ctx = RootAPI.getTabsterContext(this._tabster, element);\n    const rootUId = ctx && ctx.root.uid;\n    const deloser = DeloserAPI.getDeloser(this._tabster, element);\n\n    if (!rootUId || !deloser) {\n      return undefined;\n    }\n\n    const historyByRoot = this.make(rootUId, () => new DeloserHistoryByRoot(this._tabster, rootUId));\n\n    if (!ctx || !ctx.modalizer || ((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.isActive())) {\n      historyByRoot.unshiftToDeloser(deloser, element);\n    }\n\n    return deloser;\n  }\n\n  make(rootUId, createInstance) {\n    let historyByRoot;\n\n    for (let i = 0; i < this._history.length; i++) {\n      const hbr = this._history[i];\n\n      if (hbr.rootUId === rootUId) {\n        historyByRoot = hbr;\n\n        this._history.splice(i, 1);\n\n        break;\n      }\n    }\n\n    if (!historyByRoot) {\n      historyByRoot = createInstance();\n    }\n\n    this._history.unshift(historyByRoot);\n\n    this._history.splice(_containerHistoryLength, this._history.length - _containerHistoryLength);\n\n    return historyByRoot;\n  }\n\n  removeDeloser(deloser) {\n    this._history.forEach(i => {\n      i.removeDeloser(deloser);\n    });\n\n    this._history = this._history.filter(i => i.getLength() > 0);\n  }\n\n  async focusAvailable(from) {\n    let skip = !!from;\n\n    for (const h of this._history) {\n      if (from && h.hasDeloser(from)) {\n        skip = false;\n      }\n\n      if (!skip && (await h.focusAvailable(from))) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  async resetFocus(from) {\n    let skip = !!from;\n\n    for (const h of this._history) {\n      if (from && h.hasDeloser(from)) {\n        skip = false;\n      }\n\n      if (!skip && (await h.resetFocus(from))) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nfunction _setInformativeStyle$2(weakElement, remove, isActive, snapshotIndex) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-deloser\");\n      } else {\n        element.style.setProperty(\"--tabster-deloser\", (isActive ? \"active\" : \"inactive\") + \",\" + (\"snapshot-\" + snapshotIndex));\n      }\n    }\n  }\n}\n\nfunction buildElementSelector(element, withClass, withIndex) {\n  const selector = [];\n  const escapeRegExp = /(:|\\.|\\[|\\]|,|=|@)/g;\n  const escapeReplaceValue = \"\\\\$1\";\n\n  if (element.id) {\n    selector.push(\"#\" + element.id.replace(escapeRegExp, escapeReplaceValue));\n  }\n\n  if (withClass !== false && element.className) {\n    element.className.split(\" \").forEach(cls => {\n      cls = cls.trim();\n\n      if (cls) {\n        selector.push(\".\" + cls.replace(escapeRegExp, escapeReplaceValue));\n      }\n    });\n  }\n\n  let index = 0;\n  let el;\n\n  if (withIndex !== false && selector.length === 0) {\n    el = element;\n\n    while (el) {\n      index++;\n      el = el.previousElementSibling;\n    }\n\n    selector.unshift(\":nth-child(\" + index + \")\");\n  }\n\n  selector.unshift(element.tagName.toLowerCase());\n  return selector.join(\"\");\n}\n\nfunction buildSelector(element) {\n  if (!documentContains(element.ownerDocument, element)) {\n    return undefined;\n  }\n\n  const selector = [buildElementSelector(element)];\n  let el = element.parentElement;\n\n  while (el) {\n    const isBody = el.tagName === \"BODY\";\n    selector.unshift(buildElementSelector(el, false, !isBody));\n\n    if (isBody) {\n      break;\n    }\n\n    el = el.parentElement;\n  }\n\n  return selector.join(\" \");\n}\n\nclass Deloser extends TabsterPart {\n  constructor(tabster, element, onDispose, props) {\n    super(tabster, element, props);\n    this._isActive = false;\n    this._history = [[]];\n    this._snapshotIndex = 0;\n\n    this.isActive = () => {\n      return this._isActive;\n    };\n\n    this.setSnapshot = index => {\n      this._snapshotIndex = index;\n\n      if (this._history.length > index + 1) {\n        this._history.splice(index + 1, this._history.length - index - 1);\n      }\n\n      if (!this._history[index]) {\n        this._history[index] = [];\n      }\n\n      if (process.env.NODE_ENV === 'development') {\n        _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n      }\n    };\n\n    this.focusFirst = () => {\n      const e = this._element.get();\n\n      return !!e && this._tabster.focusedElement.focusFirst({\n        container: e\n      });\n    };\n\n    this.focusDefault = () => {\n      const e = this._element.get();\n\n      return !!e && this._tabster.focusedElement.focusDefault(e);\n    };\n\n    this.resetFocus = () => {\n      const e = this._element.get();\n\n      return !!e && this._tabster.focusedElement.resetFocus(e);\n    };\n\n    this.clearHistory = preserveExisting => {\n      const element = this._element.get();\n\n      if (!element) {\n        this._history[this._snapshotIndex] = [];\n        return;\n      }\n\n      this._history[this._snapshotIndex] = this._history[this._snapshotIndex].filter(we => {\n        const e = we.get();\n        return e && preserveExisting ? element.contains(e) : false;\n      });\n    };\n\n    this.uid = getElementUId(tabster.getWindow, element);\n    this._onDispose = onDispose;\n\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n    }\n  }\n\n  dispose() {\n    this._remove();\n\n    this._onDispose(this);\n\n    this._isActive = false;\n    this._snapshotIndex = 0;\n    this._props = {};\n    this._history = [];\n  }\n\n  setActive(active) {\n    this._isActive = active;\n\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$2(this._element, false, this._isActive, this._snapshotIndex);\n    }\n  }\n\n  getActions() {\n    return {\n      focusDefault: this.focusDefault,\n      focusFirst: this.focusFirst,\n      resetFocus: this.resetFocus,\n      clearHistory: this.clearHistory,\n      setSnapshot: this.setSnapshot,\n      isActive: this.isActive\n    };\n  }\n\n  unshift(element) {\n    let cur = this._history[this._snapshotIndex];\n    cur = this._history[this._snapshotIndex] = cur.filter(we => {\n      const e = we.get();\n      return e && e !== element;\n    });\n    cur.unshift(new WeakHTMLElement(this._tabster.getWindow, element, buildSelector(element)));\n\n    while (cur.length > _containerHistoryLength) {\n      cur.pop();\n    }\n  }\n\n  findAvailable() {\n    const element = this._element.get();\n\n    if (!element || !this._tabster.focusable.isVisible(element)) {\n      return null;\n    }\n\n    let restoreFocusOrder = this._props.restoreFocusOrder;\n    let available = null;\n    const ctx = RootAPI.getTabsterContext(this._tabster, element);\n\n    if (!ctx) {\n      return null;\n    }\n\n    const root = ctx.root;\n    const rootElement = root.getElement();\n\n    if (!rootElement) {\n      return null;\n    }\n\n    if (restoreFocusOrder === undefined) {\n      restoreFocusOrder = root.getProps().restoreFocusOrder;\n    }\n\n    if (restoreFocusOrder === RestoreFocusOrders.RootDefault) {\n      available = this._tabster.focusable.findDefault({\n        container: rootElement\n      });\n    }\n\n    if (!available && restoreFocusOrder === RestoreFocusOrders.RootFirst) {\n      available = this._findFirst(rootElement);\n    }\n\n    if (available) {\n      return available;\n    }\n\n    const availableInHistory = this._findInHistory();\n\n    const availableDefault = this._tabster.focusable.findDefault({\n      container: element\n    });\n\n    const availableFirst = this._findFirst(element);\n\n    if (availableInHistory && restoreFocusOrder === RestoreFocusOrders.History) {\n      return availableInHistory;\n    }\n\n    if (availableDefault && restoreFocusOrder === RestoreFocusOrders.DeloserDefault) {\n      return availableDefault;\n    }\n\n    if (availableFirst && restoreFocusOrder === RestoreFocusOrders.DeloserFirst) {\n      return availableFirst;\n    }\n\n    return availableDefault || availableInHistory || availableFirst || null;\n  }\n\n  customFocusLostHandler(element) {\n    return triggerEvent(element, DeloserEventName, this.getActions());\n  }\n\n  _findInHistory() {\n    const cur = this._history[this._snapshotIndex].slice(0);\n\n    this.clearHistory(true);\n\n    for (let i = 0; i < cur.length; i++) {\n      const we = cur[i];\n      const e = we.get();\n\n      const element = this._element.get();\n\n      if (e && element && element.contains(e)) {\n        if (this._tabster.focusable.isFocusable(e)) {\n          return e;\n        }\n      } else if (!this._props.noSelectorCheck) {\n        // Element is not in the DOM, try to locate the node by it's\n        // selector. This might return not exactly the right node,\n        // but it would be easily fixable by having more detailed selectors.\n        const selector = we.getData();\n\n        if (selector && element) {\n          let els;\n\n          try {\n            els = element.ownerDocument.querySelectorAll(selector);\n          } catch (e) {\n            if (process.env.NODE_ENV === 'development') {\n              // This should never happen, unless there is some bug in buildElementSelector().\n              console.error(`Failed to querySelectorAll('${selector}')`);\n            }\n\n            continue;\n          }\n\n          for (let i = 0; i < els.length; i++) {\n            const el = els[i];\n\n            if (el && this._tabster.focusable.isFocusable(el)) {\n              return el;\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  _findFirst(element) {\n    if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n      const first = this._tabster.focusable.findFirst({\n        container: element,\n        ignoreUncontrolled: true,\n        useActiveModalizer: true\n      });\n\n      if (first) {\n        return first;\n      }\n    }\n\n    return null;\n  }\n\n  _remove() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$2(this._element, true);\n    }\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass DeloserAPI {\n  constructor(tabster, props) {\n    /**\r\n     * Tracks if focus is inside a deloser\r\n     */\n    this._inDeloser = false;\n    this._isRestoringFocus = false;\n    this._isPaused = false;\n\n    this._onFocus = e => {\n      if (this._restoreFocusTimer) {\n        this._win().clearTimeout(this._restoreFocusTimer);\n\n        this._restoreFocusTimer = undefined;\n      }\n\n      if (!e) {\n        this._scheduleRestoreFocus();\n\n        return;\n      }\n\n      const deloser = this._history.process(e);\n\n      if (deloser) {\n        this._activate(deloser);\n      } else {\n        this._deactivate();\n      }\n    };\n\n    this._onDeloserDispose = deloser => {\n      this._history.removeDeloser(deloser);\n\n      if (deloser.isActive()) {\n        this._scheduleRestoreFocus();\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._history = new DeloserHistory(tabster);\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    });\n    const autoDeloser = props === null || props === void 0 ? void 0 : props.autoDeloser;\n\n    if (autoDeloser) {\n      this._autoDeloser = autoDeloser;\n    }\n  }\n\n  dispose() {\n    const win = this._win();\n\n    if (this._restoreFocusTimer) {\n      win.clearTimeout(this._restoreFocusTimer);\n      this._restoreFocusTimer = undefined;\n    }\n\n    if (this._autoDeloserInstance) {\n      this._autoDeloserInstance.dispose();\n\n      delete this._autoDeloserInstance;\n      delete this._autoDeloser;\n    }\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    this._history.dispose();\n\n    delete this._curDeloser;\n  }\n\n  createDeloser(element, props) {\n    var _a;\n\n    if (process.env.NODE_ENV === 'development') ;\n\n    const deloser = new Deloser(this._tabster, element, this._onDeloserDispose, props);\n\n    if (element.contains((_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null)) {\n      this._activate(deloser);\n    }\n\n    return deloser;\n  }\n\n  getActions(element) {\n    for (let e = element; e; e = e.parentElement) {\n      const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n      if (tabsterOnElement && tabsterOnElement.deloser) {\n        return tabsterOnElement.deloser.getActions();\n      }\n    }\n\n    return undefined;\n  }\n\n  pause() {\n    this._isPaused = true;\n\n    if (this._restoreFocusTimer) {\n      this._win().clearTimeout(this._restoreFocusTimer);\n\n      this._restoreFocusTimer = undefined;\n    }\n  }\n\n  resume(restore) {\n    this._isPaused = false;\n\n    if (restore) {\n      this._scheduleRestoreFocus();\n    }\n  }\n  /**\r\n   * Activates and sets the current deloser\r\n   */\n\n\n  _activate(deloser) {\n    const curDeloser = this._curDeloser;\n\n    if (curDeloser !== deloser) {\n      this._inDeloser = true;\n      curDeloser === null || curDeloser === void 0 ? void 0 : curDeloser.setActive(false);\n      deloser.setActive(true);\n      this._curDeloser = deloser;\n    }\n  }\n  /**\r\n   * Called when focus should no longer be in a deloser\r\n   */\n\n\n  _deactivate() {\n    var _a;\n\n    this._inDeloser = false;\n    (_a = this._curDeloser) === null || _a === void 0 ? void 0 : _a.setActive(false);\n    this._curDeloser = undefined;\n  }\n\n  _scheduleRestoreFocus(force) {\n    if (this._isPaused || this._isRestoringFocus) {\n      return;\n    }\n\n    const restoreFocus = async () => {\n      this._restoreFocusTimer = undefined;\n\n      const lastFocused = this._tabster.focusedElement.getLastFocusedElement();\n\n      if (!force && (this._isRestoringFocus || !this._inDeloser || !!(lastFocused === null || lastFocused === void 0 ? void 0 : lastFocused.offsetParent))) {\n        return;\n      }\n\n      const curDeloser = this._curDeloser;\n\n      if (curDeloser) {\n        if (lastFocused && curDeloser.customFocusLostHandler(lastFocused)) {\n          return;\n        }\n\n        const el = curDeloser.findAvailable();\n\n        if (el && this._tabster.focusedElement.focus(el)) {\n          return;\n        }\n      }\n\n      this._deactivate();\n\n      this._isRestoringFocus = true;\n\n      if (!(await this._history.focusAvailable(null))) {\n        await this._history.resetFocus(null);\n      }\n\n      this._isRestoringFocus = false;\n    };\n\n    if (force) {\n      restoreFocus();\n    } else {\n      this._restoreFocusTimer = this._win().setTimeout(restoreFocus, 100);\n    }\n  }\n\n  static getDeloser(tabster, element) {\n    var _a;\n\n    let root;\n\n    for (let e = element; e; e = e.parentElement) {\n      const tabsterOnElement = getTabsterOnElement(tabster, e);\n\n      if (tabsterOnElement) {\n        if (!root) {\n          root = tabsterOnElement.root;\n        }\n\n        const deloser = tabsterOnElement.deloser;\n\n        if (deloser) {\n          return deloser;\n        }\n      }\n    }\n\n    const deloserAPI = tabster.deloser && tabster.deloser;\n\n    if (deloserAPI) {\n      if (deloserAPI._autoDeloserInstance) {\n        return deloserAPI._autoDeloserInstance;\n      }\n\n      const autoDeloserProps = deloserAPI._autoDeloser;\n\n      if (root && !deloserAPI._autoDeloserInstance && autoDeloserProps) {\n        const body = (_a = element.ownerDocument) === null || _a === void 0 ? void 0 : _a.body;\n\n        if (body) {\n          deloserAPI._autoDeloserInstance = new Deloser(tabster, body, tabster.deloser._onDeloserDispose, autoDeloserProps);\n        }\n      }\n\n      return deloserAPI._autoDeloserInstance;\n    }\n\n    return undefined;\n  }\n\n  static getHistory(instance) {\n    return instance._history;\n  }\n\n  static forceRestoreFocus(instance) {\n    instance._scheduleRestoreFocus(true);\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass Subscribable {\n  constructor() {\n    this._callbacks = [];\n  }\n\n  dispose() {\n    this._callbacks = [];\n    delete this._val;\n  }\n\n  subscribe(callback) {\n    const callbacks = this._callbacks;\n    const index = callbacks.indexOf(callback);\n\n    if (index < 0) {\n      callbacks.push(callback);\n    }\n  }\n\n  subscribeFirst(callback) {\n    const callbacks = this._callbacks;\n    const index = callbacks.indexOf(callback);\n\n    if (index >= 0) {\n      callbacks.splice(index, 1);\n    }\n\n    callbacks.unshift(callback);\n  }\n\n  unsubscribe(callback) {\n    const index = this._callbacks.indexOf(callback);\n\n    if (index >= 0) {\n      this._callbacks.splice(index, 1);\n    }\n  }\n\n  setVal(val, details) {\n    if (this._val === val) {\n      return;\n    }\n\n    this._val = val;\n\n    this._callCallbacks(val, details);\n  }\n\n  getVal() {\n    return this._val;\n  }\n\n  trigger(val, details) {\n    this._callCallbacks(val, details);\n  }\n\n  _callCallbacks(val, details) {\n    this._callbacks.forEach(callback => callback(val, details));\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst _transactionTimeout = 1500;\nconst _pingTimeout = 3000;\nconst _targetIdUp = \"up\";\nconst CrossOriginTransactionTypes = {\n  Bootstrap: 1,\n  FocusElement: 2,\n  State: 3,\n  GetElement: 4,\n  RestoreFocusInDeloser: 5,\n  Ping: 6\n};\n\nclass CrossOriginDeloserItem extends DeloserItemBase {\n  constructor(tabster, deloser, trasactions) {\n    super();\n    this._deloser = deloser;\n    this._transactions = trasactions;\n  }\n\n  belongsTo(deloser) {\n    return deloser.deloserUId === this._deloser.deloserUId;\n  }\n\n  async focusAvailable() {\n    const data = { ...this._deloser,\n      reset: false\n    };\n    return this._transactions.beginTransaction(RestoreFocusInDeloserTransaction, data).then(value => !!value);\n  }\n\n  async resetFocus() {\n    const data = { ...this._deloser,\n      reset: true\n    };\n    return this._transactions.beginTransaction(RestoreFocusInDeloserTransaction, data).then(value => !!value);\n  }\n\n}\n\nclass CrossOriginDeloserHistoryByRoot extends DeloserHistoryByRootBase {\n  constructor(tabster, rootUId, transactions) {\n    super(tabster, rootUId);\n    this._transactions = transactions;\n  }\n\n  unshift(deloser) {\n    let item;\n\n    for (let i = 0; i < this._history.length; i++) {\n      if (this._history[i].belongsTo(deloser)) {\n        item = this._history[i];\n\n        this._history.splice(i, 1);\n\n        break;\n      }\n    }\n\n    if (!item) {\n      item = new CrossOriginDeloserItem(this._tabster, deloser, this._transactions);\n    }\n\n    this._history.unshift(item);\n\n    this._history.splice(10, this._history.length - 10);\n  }\n\n  async focusAvailable() {\n    for (const i of this._history) {\n      if (await i.focusAvailable()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  async resetFocus() {\n    for (const i of this._history) {\n      if (await i.resetFocus()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nclass CrossOriginTransaction {\n  constructor(tabster, getOwner, knownTargets, value, timeout, sentTo, targetId, sendUp) {\n    this._inProgress = {};\n    this._isDone = false;\n    this._isSelfResponding = false;\n    this._sentCount = 0;\n    this.tabster = tabster;\n    this.owner = getOwner;\n    this.ownerId = getWindowUId(getOwner());\n    this.id = getUId(getOwner());\n    this.beginData = value;\n    this._knownTargets = knownTargets;\n    this._sentTo = sentTo || {\n      [this.ownerId]: true\n    };\n    this.targetId = targetId;\n    this.sendUp = sendUp;\n    this.timeout = timeout;\n    this._promise = new (getPromise(getOwner))((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  getTargets(knownTargets) {\n    return this.targetId === _targetIdUp ? this.sendUp ? {\n      [_targetIdUp]: {\n        send: this.sendUp\n      }\n    } : null : this.targetId ? knownTargets[this.targetId] ? {\n      [this.targetId]: {\n        send: knownTargets[this.targetId].send\n      }\n    } : null : Object.keys(knownTargets).length === 0 && this.sendUp ? {\n      [_targetIdUp]: {\n        send: this.sendUp\n      }\n    } : Object.keys(knownTargets).length > 0 ? knownTargets : null;\n  }\n\n  begin(selfResponse) {\n    const targets = this.getTargets(this._knownTargets);\n    const sentTo = { ...this._sentTo\n    };\n\n    if (targets) {\n      for (const id of Object.keys(targets)) {\n        sentTo[id] = true;\n      }\n    }\n\n    const data = {\n      transaction: this.id,\n      type: this.type,\n      isResponse: false,\n      timestamp: Date.now(),\n      owner: this.ownerId,\n      sentto: sentTo,\n      timeout: this.timeout,\n      beginData: this.beginData\n    };\n\n    if (this.targetId) {\n      data.target = this.targetId;\n    }\n\n    if (selfResponse) {\n      this._isSelfResponding = true;\n      selfResponse(data).then(value => {\n        this._isSelfResponding = false;\n\n        if (value !== undefined) {\n          if (!this.endData) {\n            this.endData = value;\n          }\n        }\n\n        if (this.endData || this._sentCount === 0) {\n          this.end();\n        }\n      });\n    }\n\n    if (targets) {\n      for (const id of Object.keys(targets)) {\n        if (!(id in this._sentTo)) {\n          this._send(targets[id].send, id, data);\n        }\n      }\n    }\n\n    if (this._sentCount === 0 && !this._isSelfResponding) {\n      this.end();\n    }\n\n    return this._promise;\n  }\n\n  _send(send, targetId, data) {\n    if (this._inProgress[targetId] === undefined) {\n      this._inProgress[targetId] = true;\n      this._sentCount++;\n      send(data);\n    }\n  }\n\n  end(error) {\n    if (this._isDone) {\n      return;\n    }\n\n    this._isDone = true;\n\n    if (this.endData === undefined && error) {\n      if (this._reject) {\n        this._reject(error);\n      }\n    } else if (this._resolve) {\n      this._resolve(this.endData);\n    }\n  }\n\n  onResponse(data) {\n    const endData = data.endData;\n\n    if (endData !== undefined && !this.endData) {\n      this.endData = endData;\n    }\n\n    const inProgressId = data.target === _targetIdUp ? _targetIdUp : data.owner;\n\n    if (this._inProgress[inProgressId]) {\n      this._inProgress[inProgressId] = false;\n      this._sentCount--;\n\n      if (this.endData || this._sentCount === 0 && !this._isSelfResponding) {\n        this.end();\n      }\n    }\n  }\n\n}\n\nclass BootstrapTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.Bootstrap;\n  }\n\n  static shouldForward() {\n    return false;\n  }\n\n  static async makeResponse(tabster) {\n    return {\n      isNavigatingWithKeyboard: tabster.keyboardNavigation.isNavigatingWithKeyboard()\n    };\n  }\n\n}\n\nclass FocusElementTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.FocusElement;\n  }\n\n  static shouldSelfRespond() {\n    return true;\n  }\n\n  static shouldForward(tabster, data, getOwner) {\n    const el = GetElementTransaction.findElement(tabster, getOwner, data.beginData);\n    return !el || !tabster.focusable.isFocusable(el);\n  }\n\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult) {\n    const el = GetElementTransaction.findElement(tabster, getOwner, data.beginData);\n    return !!el && tabster.focusedElement.focus(el, true) || !!(await forwardResult);\n  }\n\n}\n\nconst CrossOriginStates = {\n  Focused: 1,\n  Blurred: 2,\n  Observed: 3,\n  DeadWindow: 4,\n  KeyboardNavigation: 5,\n  Outline: 6\n};\n\nclass StateTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.State;\n  }\n\n  static shouldSelfRespond(tabster, data) {\n    return data.state !== CrossOriginStates.DeadWindow && data.state !== CrossOriginStates.KeyboardNavigation;\n  }\n\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult, isSelfResponse) {\n    const timestamp = data.timestamp;\n    const beginData = data.beginData;\n\n    if (timestamp && beginData) {\n      switch (beginData.state) {\n        case CrossOriginStates.Focused:\n          return StateTransaction._makeFocusedResponse(tabster, timestamp, beginData, transactions, isSelfResponse);\n\n        case CrossOriginStates.Blurred:\n          return StateTransaction._makeBlurredResponse(tabster, timestamp, beginData, transactions.ctx);\n\n        case CrossOriginStates.Observed:\n          return StateTransaction._makeObservedResponse(tabster, beginData);\n\n        case CrossOriginStates.DeadWindow:\n          return StateTransaction._makeDeadWindowResponse(tabster, beginData, transactions, forwardResult);\n\n        case CrossOriginStates.KeyboardNavigation:\n          return StateTransaction._makeKeyboardNavigationResponse(tabster, transactions.ctx, beginData.isNavigatingWithKeyboard);\n\n        case CrossOriginStates.Outline:\n          return StateTransaction._makeOutlineResponse(tabster, transactions.ctx, beginData.outline);\n      }\n    }\n\n    return true;\n  }\n\n  static createElement(tabster, beginData) {\n    return beginData.uid ? new CrossOriginElement(tabster, beginData.uid, beginData.ownerUId, beginData.id, beginData.rootUId, beginData.observedName, beginData.observedDetails) : null;\n  }\n\n  static async _makeFocusedResponse(tabster, timestamp, beginData, transactions, isSelfResponse) {\n    const element = StateTransaction.createElement(tabster, beginData);\n\n    if (beginData && beginData.ownerUId && element) {\n      transactions.ctx.focusOwner = beginData.ownerUId;\n      transactions.ctx.focusOwnerTimestamp = timestamp;\n\n      if (!isSelfResponse && beginData.rootUId && beginData.deloserUId) {\n        const deloserAPI = tabster.deloser;\n\n        if (deloserAPI) {\n          const history = DeloserAPI.getHistory(deloserAPI);\n          const deloser = {\n            ownerUId: beginData.ownerUId,\n            deloserUId: beginData.deloserUId,\n            rootUId: beginData.rootUId\n          };\n          const historyItem = history.make(beginData.rootUId, () => new CrossOriginDeloserHistoryByRoot(tabster, deloser.rootUId, transactions));\n          historyItem.unshift(deloser);\n        }\n      }\n\n      CrossOriginFocusedElementState.setVal( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.focusedElement, element, {\n        isFocusedProgrammatically: beginData.isFocusedProgrammatically\n      });\n    }\n\n    return true;\n  }\n\n  static async _makeBlurredResponse(tabster, timestamp, beginData, context) {\n    if (beginData && (beginData.ownerUId === context.focusOwner || beginData.force) && (!context.focusOwnerTimestamp || context.focusOwnerTimestamp < timestamp)) {\n      CrossOriginFocusedElementState.setVal( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.focusedElement, undefined, {});\n    }\n\n    return true;\n  }\n\n  static async _makeObservedResponse(tabster, beginData) {\n    const name = beginData.observedName;\n    const element = StateTransaction.createElement(tabster, beginData);\n\n    if (name && element) {\n      CrossOriginObservedElementState.trigger( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.crossOrigin.observedElement, element, {\n        names: [name],\n        details: beginData.observedDetails\n      });\n    }\n\n    return true;\n  }\n\n  static async _makeDeadWindowResponse(tabster, beginData, transactions, forwardResult) {\n    const deadUId = beginData && beginData.ownerUId;\n\n    if (deadUId) {\n      transactions.removeTarget(deadUId);\n    }\n\n    return forwardResult.then(() => {\n      if (deadUId === transactions.ctx.focusOwner) {\n        const deloserAPI = tabster.deloser;\n\n        if (deloserAPI) {\n          DeloserAPI.forceRestoreFocus(deloserAPI);\n        }\n      }\n\n      return true;\n    });\n  }\n\n  static async _makeKeyboardNavigationResponse(tabster, context, isNavigatingWithKeyboard) {\n    if (isNavigatingWithKeyboard !== undefined && tabster.keyboardNavigation.isNavigatingWithKeyboard() !== isNavigatingWithKeyboard) {\n      context.ignoreKeyboardNavigationStateUpdate = true;\n      tabster.keyboardNavigation.setNavigatingWithKeyboard(isNavigatingWithKeyboard);\n      context.ignoreKeyboardNavigationStateUpdate = false;\n    }\n\n    return true;\n  }\n\n  static async _makeOutlineResponse(tabster, context, props) {\n    if (context.origOutlineSetup) {\n      context.origOutlineSetup.call( // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      tabster.outline, props);\n    }\n\n    return true;\n  }\n\n}\n\nclass GetElementTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.GetElement;\n  }\n\n  static shouldSelfRespond() {\n    return true;\n  }\n\n  static findElement(tabster, getOwner, data) {\n    let element;\n\n    if (data && (!data.ownerId || data.ownerId === getWindowUId(getOwner()))) {\n      if (data.id) {\n        element = getOwner().document.getElementById(data.id);\n\n        if (element && data.rootId) {\n          const ctx = RootAPI.getTabsterContext(tabster, element);\n\n          if (!ctx || ctx.root.uid !== data.rootId) {\n            return null;\n          }\n        }\n      } else if (data.uid) {\n        const ref = getInstanceContext(getOwner).elementByUId[data.uid];\n        element = ref && ref.get();\n      } else if (data.observedName) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        element = tabster.observedElement.getElement(data.observedName);\n      }\n    }\n\n    return element || null;\n  }\n\n  static getElementData(tabster, element, getOwner, context, ownerUId) {\n    const deloser = DeloserAPI.getDeloser(tabster, element);\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    const tabsterOnElement = getTabsterOnElement(tabster, element);\n    const observed = tabsterOnElement && tabsterOnElement.observed;\n    return {\n      uid: getElementUId(getOwner, element),\n      ownerUId,\n      id: element.id || undefined,\n      rootUId: ctx ? ctx.root.uid : undefined,\n      deloserUId: deloser ? getDeloserUID(getOwner, context, deloser) : undefined,\n      observedName: observed && observed.names && observed.names[0],\n      observedDetails: observed && observed.details\n    };\n  }\n\n  static async makeResponse(tabster, data, getOwner, ownerUId, transactions, forwardResult) {\n    const beginData = data.beginData;\n    let element;\n    let dataOut;\n\n    if (beginData === undefined) {\n      element = tabster.focusedElement.getFocusedElement();\n    } else if (beginData) {\n      element = GetElementTransaction.findElement(tabster, getOwner, beginData) || undefined;\n    }\n\n    if (!element && beginData) {\n      const name = beginData.observedName;\n      const timeout = data.timeout;\n      const accessibility = beginData.accessibility;\n\n      if (name && timeout) {\n        const e = await new (getPromise(getOwner))(resolve => {\n          let isWaitElementResolved = false;\n          let isForwardResolved = false;\n          let isResolved = false; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n          tabster.observedElement.waitElement(name, timeout, accessibility).result.then(value => {\n            isWaitElementResolved = true;\n\n            if (!isResolved && (value || isForwardResolved)) {\n              isResolved = true;\n              resolve({\n                element: value\n              });\n            }\n          });\n          forwardResult.then(value => {\n            isForwardResolved = true;\n\n            if (!isResolved && (value || isWaitElementResolved)) {\n              isResolved = true;\n              resolve({\n                crossOrigin: value\n              });\n            }\n          });\n        });\n\n        if (e.element) {\n          element = e.element;\n        } else if (e.crossOrigin) {\n          dataOut = e.crossOrigin;\n        }\n      }\n    }\n\n    return element ? GetElementTransaction.getElementData(tabster, element, getOwner, transactions.ctx, ownerUId) : dataOut;\n  }\n\n}\n\nclass RestoreFocusInDeloserTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.RestoreFocusInDeloser;\n  }\n\n  static async makeResponse(tabster, data, getOwner, ownerId, transactions, forwardResult) {\n    const forwardRet = await forwardResult;\n    const begin = !forwardRet && data.beginData;\n    const uid = begin && begin.deloserUId;\n    const deloser = uid && transactions.ctx.deloserByUId[uid];\n    const deloserAPI = tabster.deloser;\n\n    if (begin && deloser && deloserAPI) {\n      const history = DeloserAPI.getHistory(deloserAPI);\n      return begin.reset ? history.resetFocus(deloser) : history.focusAvailable(deloser);\n    }\n\n    return !!forwardRet;\n  }\n\n}\n\nclass PingTransaction extends CrossOriginTransaction {\n  constructor() {\n    super(...arguments);\n    this.type = CrossOriginTransactionTypes.Ping;\n  }\n\n  static shouldForward() {\n    return false;\n  }\n\n  static async makeResponse() {\n    return true;\n  }\n\n}\n\nclass CrossOriginTransactions {\n  constructor(tabster, getOwner, context) {\n    this._knownTargets = {};\n    this._transactions = {};\n    this._isDefaultSendUp = false;\n    this.isSetUp = false;\n\n    this._onMessage = e => {\n      if (e.data.owner === this._ownerUId || !this._tabster) {\n        return;\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      const data = e.data;\n      let transactionId;\n\n      if (!data || !(transactionId = data.transaction) || !data.type || !data.timestamp || !data.owner || !data.sentto) {\n        return;\n      }\n\n      let knownTarget = this._knownTargets[data.owner];\n\n      if (!knownTarget && e.send && data.owner !== this._ownerUId) {\n        knownTarget = this._knownTargets[data.owner] = {\n          send: e.send\n        };\n      }\n\n      if (knownTarget) {\n        knownTarget.last = Date.now();\n      }\n\n      if (data.isResponse) {\n        const t = this._transactions[transactionId];\n\n        if (t && t.transaction && t.transaction.type === data.type) {\n          t.transaction.onResponse(data);\n        }\n      } else {\n        const Transaction = this._getTransactionClass(data.type);\n\n        const forwardResult = this.forwardTransaction(data);\n\n        if (Transaction && e.send) {\n          Transaction.makeResponse(this._tabster, data, this._owner, this._ownerUId, this, forwardResult, false).then(r => {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const response = {\n              transaction: data.transaction,\n              type: data.type,\n              isResponse: true,\n              timestamp: Date.now(),\n              owner: this._ownerUId,\n              timeout: data.timeout,\n              sentto: {},\n              target: data.target === _targetIdUp ? _targetIdUp : data.owner,\n              endData: r\n            };\n            e.send(response);\n          });\n        }\n      }\n    };\n\n    this._onPageHide = () => {\n      this._dead();\n    };\n\n    this._onBrowserMessage = e => {\n      if (e.source === this._owner()) {\n        return;\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      const send = data => {\n        if (e.source && e.source.postMessage) {\n          // eslint-disable-next-line @typescript-eslint/ban-types\n          e.source.postMessage(JSON.stringify(data), \"*\");\n        }\n      };\n\n      try {\n        this._onMessage({\n          data: JSON.parse(e.data),\n          send\n        });\n      } catch (e) {\n        /* Ignore */\n      }\n    };\n\n    this._tabster = tabster;\n    this._owner = getOwner;\n    this._ownerUId = getWindowUId(getOwner());\n    this.ctx = context;\n  }\n\n  setup(sendUp) {\n    if (this.isSetUp) {\n      if (process.env.NODE_ENV === 'development') {\n        console.error(\"CrossOrigin is already set up.\");\n      }\n    } else {\n      this.isSetUp = true;\n      this.setSendUp(sendUp);\n\n      this._owner().addEventListener(\"pagehide\", this._onPageHide);\n\n      this._ping();\n    }\n\n    return this._onMessage;\n  }\n\n  setSendUp(sendUp) {\n    if (!this.isSetUp) {\n      throw new Error(\"CrossOrigin is not set up.\");\n    }\n\n    this.sendUp = sendUp || undefined;\n\n    const owner = this._owner();\n\n    if (sendUp === undefined) {\n      if (!this._isDefaultSendUp) {\n        if (owner.document) {\n          this._isDefaultSendUp = true;\n\n          if (owner.parent && owner.parent !== owner && owner.parent.postMessage) {\n            this.sendUp = ( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            data) => {\n              owner.parent.postMessage(JSON.stringify(data), \"*\");\n            };\n          }\n\n          owner.addEventListener(\"message\", this._onBrowserMessage);\n        }\n      }\n    } else if (this._isDefaultSendUp) {\n      owner.removeEventListener(\"message\", this._onBrowserMessage);\n      this._isDefaultSendUp = false;\n    }\n\n    return this._onMessage;\n  }\n\n  async dispose() {\n    const owner = this._owner();\n\n    if (this._pingTimer) {\n      owner.clearTimeout(this._pingTimer);\n      this._pingTimer = undefined;\n    }\n\n    owner.removeEventListener(\"message\", this._onBrowserMessage);\n    owner.removeEventListener(\"pagehide\", this._onPageHide);\n    await this._dead();\n    delete this._deadPromise;\n\n    for (const id of Object.keys(this._transactions)) {\n      const t = this._transactions[id];\n\n      if (t.timer) {\n        owner.clearTimeout(t.timer);\n        delete t.timer;\n      }\n\n      t.transaction.end();\n    }\n\n    this._knownTargets = {};\n    delete this.sendUp;\n  }\n\n  beginTransaction(Transaction, value, timeout, sentTo, targetId, withReject) {\n    if (!this._owner) {\n      return getPromise(this._owner).reject();\n    }\n\n    const transaction = new Transaction(this._tabster, this._owner, this._knownTargets, value, timeout, sentTo, targetId, this.sendUp);\n    let selfResponse;\n\n    if (Transaction.shouldSelfRespond && Transaction.shouldSelfRespond(this._tabster, value, this._owner, this._ownerUId)) {\n      selfResponse = data => {\n        return Transaction.makeResponse(this._tabster, data, this._owner, this._ownerUId, this, getPromise(this._owner).resolve(undefined), true);\n      };\n    }\n\n    return this._beginTransaction(transaction, timeout, selfResponse, withReject);\n  }\n\n  removeTarget(uid) {\n    delete this._knownTargets[uid];\n  }\n\n  _beginTransaction(transaction, timeout, selfResponse, withReject) {\n    const owner = this._owner();\n\n    const wrapper = {\n      transaction,\n      timer: owner.setTimeout(() => {\n        delete wrapper.timer;\n        transaction.end(\"Cross origin transaction timed out.\");\n      }, _transactionTimeout + (timeout || 0))\n    };\n    this._transactions[transaction.id] = wrapper;\n    const ret = transaction.begin(selfResponse);\n    ret.catch(() => {\n      /**/\n    }).finally(() => {\n      if (wrapper.timer) {\n        owner.clearTimeout(wrapper.timer);\n      }\n\n      delete this._transactions[transaction.id];\n    });\n    return ret.then(value => value, withReject ? undefined : () => undefined);\n  }\n\n  forwardTransaction( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    const owner = this._owner;\n    let targetId = data.target;\n\n    if (targetId === this._ownerUId) {\n      return getPromise(owner).resolve();\n    }\n\n    const Transaction = this._getTransactionClass(data.type);\n\n    if (Transaction) {\n      if (Transaction.shouldForward === undefined || Transaction.shouldForward(this._tabster, data, owner, this._ownerUId)) {\n        const sentTo = data.sentto;\n\n        if (targetId === _targetIdUp) {\n          targetId = undefined;\n          sentTo[this._ownerUId] = true;\n        }\n\n        delete sentTo[_targetIdUp];\n        return this._beginTransaction(new Transaction(this._tabster, owner, this._knownTargets, data.beginData, data.timeout, sentTo, targetId, this.sendUp), data.timeout);\n      } else {\n        return getPromise(owner).resolve();\n      }\n    }\n\n    return getPromise(owner).reject(`Unknown transaction type ${data.type}`);\n  }\n\n  _getTransactionClass(type // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    switch (type) {\n      case CrossOriginTransactionTypes.Bootstrap:\n        return BootstrapTransaction;\n\n      case CrossOriginTransactionTypes.FocusElement:\n        return FocusElementTransaction;\n\n      case CrossOriginTransactionTypes.State:\n        return StateTransaction;\n\n      case CrossOriginTransactionTypes.GetElement:\n        return GetElementTransaction;\n\n      case CrossOriginTransactionTypes.RestoreFocusInDeloser:\n        return RestoreFocusInDeloserTransaction;\n\n      case CrossOriginTransactionTypes.Ping:\n        return PingTransaction;\n\n      default:\n        return null;\n    }\n  }\n\n  async _dead() {\n    if (!this._deadPromise && this.ctx.focusOwner === this._ownerUId) {\n      this._deadPromise = this.beginTransaction(StateTransaction, {\n        ownerUId: this._ownerUId,\n        state: CrossOriginStates.DeadWindow\n      });\n    }\n\n    if (this._deadPromise) {\n      await this._deadPromise;\n    }\n  }\n\n  async _ping() {\n    if (this._pingTimer) {\n      return;\n    }\n\n    let deadWindows;\n    const now = Date.now();\n    const targets = Object.keys(this._knownTargets).filter(uid => now - (this._knownTargets[uid].last || 0) > _pingTimeout);\n\n    if (this.sendUp) {\n      targets.push(_targetIdUp);\n    }\n\n    if (targets.length) {\n      await getPromise(this._owner).all(targets.map(uid => this.beginTransaction(PingTransaction, undefined, undefined, undefined, uid, true).then(() => true, () => {\n        if (uid !== _targetIdUp) {\n          if (!deadWindows) {\n            deadWindows = {};\n          }\n\n          deadWindows[uid] = true;\n          delete this._knownTargets[uid];\n        }\n\n        return false;\n      })));\n    }\n\n    if (deadWindows) {\n      const focused = await this.beginTransaction(GetElementTransaction, undefined);\n\n      if (!focused && this.ctx.focusOwner && this.ctx.focusOwner in deadWindows) {\n        await this.beginTransaction(StateTransaction, {\n          ownerUId: this._ownerUId,\n          state: CrossOriginStates.Blurred,\n          force: true\n        });\n        const deloserAPI = this._tabster.deloser;\n\n        if (deloserAPI) {\n          DeloserAPI.forceRestoreFocus(deloserAPI);\n        }\n      }\n    }\n\n    this._pingTimer = this._owner().setTimeout(() => {\n      this._pingTimer = undefined;\n\n      this._ping();\n    }, _pingTimeout);\n  }\n\n}\n\nclass CrossOriginElement {\n  constructor(tabster, uid, ownerId, id, rootId, observedName, observedDetails) {\n    this._tabster = tabster;\n    this.uid = uid;\n    this.ownerId = ownerId;\n    this.id = id;\n    this.rootId = rootId;\n    this.observedName = observedName;\n    this.observedDetails = observedDetails;\n  }\n\n  focus(noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._tabster.crossOrigin.focusedElement.focus(this, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n\n}\nclass CrossOriginFocusedElementState extends Subscribable {\n  constructor(transactions) {\n    super();\n    this._transactions = transactions;\n  }\n\n  async focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      uid: element.uid,\n      id: element.id,\n      rootId: element.rootId,\n      ownerId: element.ownerId,\n      observedName: element.observedName\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n\n  async focusById(elementId, rootId, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      id: elementId,\n      rootId\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck);\n  }\n\n  async focusByObservedName(observedName, timeout, rootId, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    return this._focus({\n      observedName,\n      rootId\n    }, noFocusedProgrammaticallyFlag, noAccessibleCheck, timeout);\n  }\n\n  async _focus(elementData, noFocusedProgrammaticallyFlag, noAccessibleCheck, timeout) {\n    return this._transactions.beginTransaction(FocusElementTransaction, { ...elementData,\n      noFocusedProgrammaticallyFlag,\n      noAccessibleCheck\n    }, timeout).then(value => !!value);\n  }\n\n  static setVal(instance, val, details) {\n    instance.setVal(val, details);\n  }\n\n}\nclass CrossOriginObservedElementState extends Subscribable {\n  constructor(tabster, transactions) {\n    super();\n    this._lastRequestFocusId = 0;\n    this._tabster = tabster;\n    this._transactions = transactions;\n  }\n\n  async getElement(observedName, accessibility) {\n    return this.waitElement(observedName, 0, accessibility);\n  }\n\n  async waitElement(observedName, timeout, accessibility) {\n    return this._transactions.beginTransaction(GetElementTransaction, {\n      observedName,\n      accessibility\n    }, timeout).then(value => value ? StateTransaction.createElement(this._tabster, value) : null);\n  }\n\n  async requestFocus(observedName, timeout) {\n    const requestId = ++this._lastRequestFocusId;\n    return this.waitElement(observedName, timeout, ObservedElementAccesibilities.Focusable).then(element => this._lastRequestFocusId === requestId && element ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this._tabster.crossOrigin.focusedElement.focus(element, true) : false);\n  }\n\n  static trigger(instance, element, details) {\n    instance.trigger(element, details);\n  }\n\n}\nclass CrossOriginAPI {\n  constructor(tabster) {\n    this._init = () => {\n      const tabster = this._tabster;\n      tabster.keyboardNavigation.subscribe(this._onKeyboardNavigationStateChanged);\n      tabster.focusedElement.subscribe(this._onFocus); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      tabster.observedElement.subscribe(this._onObserved);\n\n      if (!this._ctx.origOutlineSetup) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this._ctx.origOutlineSetup = tabster.outline.setup; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        tabster.outline.setup = this._outlineSetup;\n      }\n\n      this._transactions.beginTransaction(BootstrapTransaction, undefined, undefined, undefined, _targetIdUp).then(data => {\n        if (data && this._tabster.keyboardNavigation.isNavigatingWithKeyboard() !== data.isNavigatingWithKeyboard) {\n          this._ctx.ignoreKeyboardNavigationStateUpdate = true;\n\n          this._tabster.keyboardNavigation.setNavigatingWithKeyboard(data.isNavigatingWithKeyboard);\n\n          this._ctx.ignoreKeyboardNavigationStateUpdate = false;\n        }\n      });\n    };\n\n    this._onKeyboardNavigationStateChanged = value => {\n      if (!this._ctx.ignoreKeyboardNavigationStateUpdate) {\n        this._transactions.beginTransaction(StateTransaction, {\n          state: CrossOriginStates.KeyboardNavigation,\n          ownerUId: getWindowUId(this._win()),\n          isNavigatingWithKeyboard: value\n        });\n      }\n    };\n\n    this._onFocus = element => {\n      const win = this._win();\n\n      const ownerUId = getWindowUId(win);\n\n      if (this._blurTimer) {\n        win.clearTimeout(this._blurTimer);\n        this._blurTimer = undefined;\n      }\n\n      if (element) {\n        this._transactions.beginTransaction(StateTransaction, { ...GetElementTransaction.getElementData(this._tabster, element, this._win, this._ctx, ownerUId),\n          state: CrossOriginStates.Focused\n        });\n      } else {\n        this._blurTimer = win.setTimeout(() => {\n          this._blurTimer = undefined;\n\n          if (this._ctx.focusOwner && this._ctx.focusOwner === ownerUId) {\n            this._transactions.beginTransaction(GetElementTransaction, undefined).then(value => {\n              if (!value && this._ctx.focusOwner === ownerUId) {\n                this._transactions.beginTransaction(StateTransaction, {\n                  ownerUId,\n                  state: CrossOriginStates.Blurred,\n                  force: false\n                });\n              }\n            });\n          }\n        }, 0);\n      }\n    };\n\n    this._onObserved = (element, details) => {\n      var _a;\n\n      const d = GetElementTransaction.getElementData(this._tabster, element, this._win, this._ctx, getWindowUId(this._win()));\n      d.state = CrossOriginStates.Observed;\n      d.observedName = (_a = details.names) === null || _a === void 0 ? void 0 : _a[0];\n      d.observedDetails = details.details;\n\n      this._transactions.beginTransaction(StateTransaction, d);\n    };\n\n    this._outlineSetup = props => {\n      this._transactions.beginTransaction(StateTransaction, {\n        state: CrossOriginStates.Outline,\n        ownerUId: getWindowUId(this._win()),\n        outline: props\n      });\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._ctx = {\n      ignoreKeyboardNavigationStateUpdate: false,\n      deloserByUId: {}\n    };\n    this._transactions = new CrossOriginTransactions(tabster, this._win, this._ctx);\n    this.focusedElement = new CrossOriginFocusedElementState(this._transactions);\n    this.observedElement = new CrossOriginObservedElementState(tabster, this._transactions);\n  }\n\n  setup(sendUp) {\n    if (this.isSetUp()) {\n      return this._transactions.setSendUp(sendUp);\n    } else {\n      this._tabster.queueInit(this._init);\n\n      return this._transactions.setup(sendUp);\n    }\n  }\n\n  isSetUp() {\n    return this._transactions.isSetUp;\n  }\n\n  dispose() {\n    var _a;\n\n    const tabster = this._tabster;\n    tabster.keyboardNavigation.unsubscribe(this._onKeyboardNavigationStateChanged);\n    tabster.focusedElement.unsubscribe(this._onFocus);\n    (_a = tabster.observedElement) === null || _a === void 0 ? void 0 : _a.unsubscribe(this._onObserved);\n\n    this._transactions.dispose();\n\n    this.focusedElement.dispose();\n    this.observedElement.dispose();\n    this._ctx.deloserByUId = {};\n  }\n\n}\n\nfunction getDeloserUID(getWindow, context, deloser) {\n  const deloserElement = deloser.getElement();\n\n  if (deloserElement) {\n    const uid = getElementUId(getWindow, deloserElement);\n\n    if (!context.deloserByUId[uid]) {\n      context.deloserByUId[uid] = deloser;\n    }\n\n    return uid;\n  }\n\n  return undefined;\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nconst _focusableSelector = /*#__PURE__*/[\"a[href]\", \"button:not([disabled])\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\", \"*[tabindex]\", \"*[contenteditable]\"].join(\", \");\n\nclass FocusableAPI {\n  constructor(tabster) {\n    this._tabster = tabster;\n  }\n\n  dispose() {\n    /**/\n  }\n\n  getProps(element) {\n    const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n    return tabsterOnElement && tabsterOnElement.focusable || {};\n  }\n\n  isFocusable(el, includeProgrammaticallyFocusable, noVisibleCheck, noAccessibleCheck) {\n    if (matchesSelector(el, _focusableSelector) && (includeProgrammaticallyFocusable || el.tabIndex !== -1)) {\n      return (noVisibleCheck || this.isVisible(el)) && (noAccessibleCheck || this.isAccessible(el));\n    }\n\n    return false;\n  }\n\n  isVisible(el) {\n    if (!el.ownerDocument) {\n      return false;\n    }\n\n    if (el.offsetParent === null && el.ownerDocument.body !== el) {\n      return false;\n    }\n\n    const win = el.ownerDocument.defaultView;\n\n    if (!win) {\n      return false;\n    }\n\n    const rect = el.ownerDocument.body.getBoundingClientRect();\n\n    if (rect.width === 0 && rect.height === 0) {\n      // This might happen, for example, if our <body> is in hidden <iframe>.\n      return false;\n    }\n\n    const computedStyle = win.getComputedStyle(el);\n\n    if (computedStyle.visibility === \"hidden\") {\n      return false;\n    }\n\n    return true;\n  }\n\n  isAccessible(el) {\n    var _a;\n\n    for (let e = el; e; e = e.parentElement) {\n      const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n      if (this._isHidden(e)) {\n        return false;\n      }\n\n      const ignoreDisabled = (_a = tabsterOnElement === null || tabsterOnElement === void 0 ? void 0 : tabsterOnElement.focusable) === null || _a === void 0 ? void 0 : _a.ignoreAriaDisabled;\n\n      if (!ignoreDisabled && this._isDisabled(e)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _isDisabled(el) {\n    return el.hasAttribute(\"disabled\");\n  }\n\n  _isHidden(el) {\n    var _a;\n\n    const attrVal = el.getAttribute(\"aria-hidden\");\n\n    if (attrVal && attrVal.toLowerCase() === \"true\") {\n      if (!((_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.isAugmented(el))) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  findFirst(options) {\n    return this.findElement({ ...options\n    });\n  }\n\n  findLast(options) {\n    return this.findElement({\n      isBackward: true,\n      ...options\n    });\n  }\n\n  findNext(options) {\n    return this.findElement({ ...options\n    });\n  }\n\n  findPrev(options) {\n    return this.findElement({\n      isBackward: true,\n      ...options\n    });\n  }\n\n  findDefault(options) {\n    return this.findElement({ ...options,\n      acceptCondition: el => this._tabster.focusable.isFocusable(el, options.includeProgrammaticallyFocusable) && !!this.getProps(el).isDefault\n    }) || null;\n  }\n\n  findAll(options) {\n    return this._findElements(true, options) || [];\n  }\n\n  findElement(options) {\n    const found = this._findElements(false, options);\n\n    return found ? found[0] : found;\n  }\n\n  _findElements(findAll, options) {\n    var _a, _b, _c;\n\n    const {\n      container,\n      currentElement = null,\n      includeProgrammaticallyFocusable,\n      useActiveModalizer,\n      ignoreUncontrolled,\n      ignoreAccessibility,\n      modalizerId,\n      isBackward,\n      onUncontrolled,\n      onElement\n    } = options;\n    const elements = [];\n    let {\n      acceptCondition\n    } = options;\n\n    if (!container) {\n      return null;\n    }\n\n    if (!acceptCondition) {\n      acceptCondition = el => this._tabster.focusable.isFocusable(el, includeProgrammaticallyFocusable, false, ignoreAccessibility);\n    }\n\n    const acceptElementState = {\n      container,\n      modalizerUserId: modalizerId === undefined && useActiveModalizer ? (_a = this._tabster.modalizer) === null || _a === void 0 ? void 0 : _a.activeId : modalizerId || ((_c = (_b = RootAPI.getTabsterContext(this._tabster, container)) === null || _b === void 0 ? void 0 : _b.modalizer) === null || _c === void 0 ? void 0 : _c.userId),\n      from: currentElement || container,\n      isBackward,\n      acceptCondition,\n      includeProgrammaticallyFocusable,\n      ignoreUncontrolled,\n      ignoreAccessibility,\n      cachedGrouppers: {}\n    };\n    const walker = createElementTreeWalker(container.ownerDocument, container, node => this._acceptElement(node, acceptElementState));\n\n    if (!walker) {\n      return null;\n    }\n\n    const prepareForNextElement = shouldContinueIfNotFound => {\n      const foundElement = acceptElementState.foundElement;\n\n      if (foundElement) {\n        elements.push(foundElement);\n      }\n\n      if (findAll) {\n        if (foundElement) {\n          acceptElementState.found = false;\n          delete acceptElementState.foundElement;\n          delete acceptElementState.fromCtx;\n          acceptElementState.from = foundElement;\n\n          if (onElement && !onElement(foundElement)) {\n            return false;\n          }\n        }\n\n        return !!(foundElement || shouldContinueIfNotFound);\n      } else {\n        return !!(shouldContinueIfNotFound && !foundElement);\n      }\n    };\n\n    if (currentElement) {\n      walker.currentNode = currentElement;\n    } else if (isBackward) {\n      const lastChild = getLastChild(container);\n\n      if (!lastChild) {\n        return null;\n      }\n\n      if (this._acceptElement(lastChild, acceptElementState) === NodeFilter.FILTER_ACCEPT && !prepareForNextElement(true)) {\n        return elements;\n      }\n\n      walker.currentNode = lastChild;\n    }\n\n    let foundElement;\n\n    do {\n      foundElement = (isBackward ? walker.previousNode() : walker.nextNode()) || undefined;\n    } while (prepareForNextElement());\n\n    if (!findAll) {\n      const nextUncontrolled = acceptElementState.nextUncontrolled;\n\n      if (nextUncontrolled) {\n        if (onUncontrolled) {\n          onUncontrolled(nextUncontrolled);\n        }\n\n        if (foundElement) {\n          // We have an uncontrolled area and there is a controlled element after it.\n          // Return undefined for the default Tab action.\n          return undefined;\n        } else {\n          // Otherwise, return null to moveOutWithDefaultAction().\n          return null;\n        }\n      }\n    }\n\n    return elements.length ? elements : null;\n  }\n\n  _acceptElement(element, state) {\n    var _a, _b, _c, _d, _e;\n\n    if (state.found) {\n      return NodeFilter.FILTER_ACCEPT;\n    }\n\n    const container = state.container;\n\n    if (element === container) {\n      return NodeFilter.FILTER_SKIP;\n    }\n\n    if (!container.contains(element)) {\n      return NodeFilter.FILTER_REJECT;\n    }\n\n    if (element.__tabsterDummyContainer) {\n      return NodeFilter.FILTER_REJECT;\n    }\n\n    let lastToIgnore = state.lastToIgnore;\n\n    if (lastToIgnore) {\n      if (lastToIgnore.contains(element)) {\n        return NodeFilter.FILTER_REJECT;\n      } else {\n        lastToIgnore = state.lastToIgnore = undefined;\n      }\n    }\n\n    const ctx = state.currentCtx = RootAPI.getTabsterContext(this._tabster, element); // Tabster is opt in, if it is not managed, don't try and get do anything special\n\n    if (!ctx) {\n      return NodeFilter.FILTER_SKIP;\n    }\n\n    if (state.ignoreUncontrolled) {\n      if (shouldIgnoreFocus(element)) {\n        return NodeFilter.FILTER_SKIP;\n      }\n    } else if (ctx.uncontrolled && !state.nextUncontrolled && this._tabster.focusable.isFocusable(element, undefined, true, true)) {\n      if (!ctx.groupper && !ctx.mover) {\n        if (((_a = ctx.modalizer) === null || _a === void 0 ? void 0 : _a.userId) === ((_b = this._tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n          if (this.isVisible(ctx.uncontrolled)) {\n            state.nextUncontrolled = ctx.uncontrolled;\n          }\n\n          return NodeFilter.FILTER_REJECT;\n        }\n      }\n    } // We assume iframes are focusable because native tab behaviour would tab inside\n\n\n    if (element.tagName === \"IFRAME\" || element.tagName === \"WEBVIEW\") {\n      if (((_c = ctx.modalizer) === null || _c === void 0 ? void 0 : _c.userId) === ((_d = this._tabster.modalizer) === null || _d === void 0 ? void 0 : _d.activeId)) {\n        state.found = true;\n        state.lastToIgnore = state.foundElement = element;\n        return NodeFilter.FILTER_ACCEPT;\n      } else {\n        return NodeFilter.FILTER_REJECT;\n      }\n    }\n\n    if (!state.ignoreAccessibility && !this.isAccessible(element)) {\n      return NodeFilter.FILTER_REJECT;\n    }\n\n    let result;\n    let fromCtx = state.fromCtx;\n\n    if (!fromCtx) {\n      fromCtx = state.fromCtx = RootAPI.getTabsterContext(this._tabster, state.from);\n    }\n\n    const fromMover = fromCtx === null || fromCtx === void 0 ? void 0 : fromCtx.mover;\n    let groupper = ctx.groupper;\n    let mover = ctx.mover;\n    result = (_e = this._tabster.modalizer) === null || _e === void 0 ? void 0 : _e.acceptElement(element, state);\n\n    if (result === undefined && (groupper || mover || fromMover)) {\n      const groupperElement = groupper === null || groupper === void 0 ? void 0 : groupper.getElement();\n      const fromMoverElement = fromMover === null || fromMover === void 0 ? void 0 : fromMover.getElement();\n      let moverElement = mover === null || mover === void 0 ? void 0 : mover.getElement();\n\n      if (moverElement && fromMoverElement && container.contains(fromMoverElement) && (!groupperElement || !mover || fromMoverElement.contains(groupperElement))) {\n        mover = fromMover;\n        moverElement = fromMoverElement;\n      }\n\n      if (groupperElement && (groupperElement === container || !container.contains(groupperElement))) {\n        groupper = undefined;\n      }\n\n      if (moverElement && !container.contains(moverElement)) {\n        mover = undefined;\n      }\n\n      if (groupper && mover) {\n        if (moverElement && groupperElement && !groupperElement.contains(moverElement)) {\n          mover = undefined;\n        } else {\n          groupper = undefined;\n        }\n      }\n\n      if (groupper) {\n        result = groupper.acceptElement(element, state);\n      }\n\n      if (mover) {\n        result = mover.acceptElement(element, state);\n      }\n    }\n\n    if (result === undefined) {\n      result = state.acceptCondition(element) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n\n    if (result === NodeFilter.FILTER_ACCEPT && !state.found) {\n      state.found = true;\n      state.foundElement = element;\n    }\n\n    return result;\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst Keys = {\n  Tab: 9,\n  Enter: 13,\n  Esc: 27,\n  Space: 32,\n  PageUp: 33,\n  PageDown: 34,\n  End: 35,\n  Home: 36,\n  Left: 37,\n  Up: 38,\n  Right: 39,\n  Down: 40\n};\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass FocusedElementState extends Subscribable {\n  constructor(tabster, getWindow) {\n    super();\n\n    this._init = () => {\n      const win = this._win();\n\n      const doc = win.document; // Add these event listeners as capture - we want Tabster to run before user event handlers\n\n      doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);\n      doc.addEventListener(\"focusout\", this._onFocusOut, true);\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n      const activeElement = doc.activeElement;\n\n      if (activeElement && activeElement !== doc.body) {\n        this._setFocusedElement(activeElement);\n      }\n\n      this.subscribe(this._onChanged);\n    };\n\n    this._onFocusIn = e => {\n      this._setFocusedElement(e.target, e.details.relatedTarget, e.details.isFocusedProgrammatically);\n    };\n\n    this._onFocusOut = e => {\n      this._setFocusedElement(undefined, e.relatedTarget);\n    }; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    this._validateFocusedElement = element => {// TODO: Make sure this is not needed anymore and write tests.\n    };\n\n    this._onKeyDown = e => {\n      var _a, _b, _c, _d, _e, _f;\n\n      if (e.keyCode !== Keys.Tab || e.ctrlKey) {\n        return;\n      }\n\n      const currentElement = this.getVal();\n\n      if (!currentElement || !currentElement.ownerDocument || currentElement.contentEditable === \"true\") {\n        return;\n      }\n\n      const tabster = this._tabster;\n      const controlTab = tabster.controlTab;\n      const ctx = RootAPI.getTabsterContext(tabster, currentElement);\n\n      if (!ctx || ctx.ignoreKeydown(e)) {\n        return;\n      }\n\n      const isBackward = e.shiftKey;\n      const next = FocusedElementState.findNextTabbable(tabster, ctx, undefined, currentElement, isBackward, undefined, true);\n      let nextElement;\n\n      if (next) {\n        let uncontrolled = next.uncontrolled;\n\n        if (uncontrolled) {\n          const isGroupperFirst = ctx.isGroupperFirst;\n          let moveOutside = false;\n\n          if (isGroupperFirst !== undefined) {\n            const groupper = (_a = ctx.groupper) === null || _a === void 0 ? void 0 : _a.getElement();\n            const mover = (_b = ctx.mover) === null || _b === void 0 ? void 0 : _b.getElement();\n            let moveFrom;\n\n            if (isGroupperFirst && groupper && uncontrolled.contains(groupper)) {\n              moveFrom = groupper;\n            } else if (!isGroupperFirst && mover && uncontrolled.contains(mover)) {\n              moveFrom = mover;\n            }\n\n            if (moveFrom) {\n              uncontrolled = moveFrom;\n              moveOutside = true;\n            }\n          }\n\n          if (uncontrolled && ctx.uncontrolled !== uncontrolled) {\n            // We have met an uncontrolled area, just allow default action.\n            DummyInputManager.moveWithPhantomDummy(this._tabster, uncontrolled, moveOutside, isBackward);\n          }\n\n          return;\n        }\n\n        nextElement = next.element;\n      }\n\n      if (nextElement) {\n        const preventDefault = () => {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n        }; // For iframes just allow normal Tab behaviour\n\n\n        if (!controlTab) {\n          const lastMoverOrGroupper = next === null || next === void 0 ? void 0 : next.lastMoverOrGroupper;\n          let outOfDOMOrder = next === null || next === void 0 ? void 0 : next.outOfDOMOrder;\n\n          if (!outOfDOMOrder && currentElement.compareDocumentPosition(nextElement) & (isBackward ? document.DOCUMENT_POSITION_FOLLOWING : document.DOCUMENT_POSITION_PRECEDING)) {\n            outOfDOMOrder = true;\n          }\n\n          if (outOfDOMOrder) {\n            // The next element is out of DOM order (for example because of a trapped groupper),\n            // do not let the browser to move focus.\n            preventDefault();\n            nativeFocus(nextElement);\n          } else if (lastMoverOrGroupper) {\n            (_c = lastMoverOrGroupper.dummyManager) === null || _c === void 0 ? void 0 : _c.moveOutWithDefaultAction(isBackward);\n          } else if (ctx.modalizer) {\n            const nextElementCtx = RootAPI.getTabsterContext(tabster, nextElement);\n\n            if ((!nextElementCtx || ctx.root.uid !== nextElementCtx.root.uid || !((_d = nextElementCtx.modalizer) === null || _d === void 0 ? void 0 : _d.isActive())) && ctx.modalizer.triggerFocusEvent(ModalizerBeforeFocusOutEventName, true)) {\n              preventDefault();\n            } else if (!((_e = ctx.modalizer.getElement()) === null || _e === void 0 ? void 0 : _e.contains(nextElement))) {\n              preventDefault();\n              (_f = ctx.modalizer.dummyManager) === null || _f === void 0 ? void 0 : _f.moveOut(isBackward);\n            }\n          }\n        } else if (nextElement.tagName !== \"IFRAME\") {\n          preventDefault();\n          nativeFocus(nextElement);\n        }\n      } else {\n        ctx.root.moveOutWithDefaultAction(isBackward);\n      }\n    };\n\n    this._onChanged = (element, details) => {\n      var _a, _b;\n\n      if (element) {\n        triggerEvent(element, FocusInEventName, details);\n      } else {\n        const last = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();\n\n        if (last) {\n          const d = { ...details\n          };\n          const lastCtx = RootAPI.getTabsterContext(this._tabster, last);\n          const modalizerId = (_b = lastCtx === null || lastCtx === void 0 ? void 0 : lastCtx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;\n\n          if (modalizerId) {\n            d.modalizerId = modalizerId;\n          }\n\n          triggerEvent(last, FocusOutEventName, d);\n        }\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = getWindow;\n    tabster.queueInit(this._init);\n  }\n\n  dispose() {\n    super.dispose();\n\n    const win = this._win();\n\n    win.document.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);\n    win.document.removeEventListener(\"focusout\", this._onFocusOut, true);\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    this.unsubscribe(this._onChanged);\n    delete FocusedElementState._lastResetElement;\n    delete this._nextVal;\n    delete this._lastVal;\n  }\n\n  static forgetMemorized(instance, parent) {\n    var _a, _b;\n\n    let wel = FocusedElementState._lastResetElement;\n    let el = wel && wel.get();\n\n    if (el && parent.contains(el)) {\n      delete FocusedElementState._lastResetElement;\n    }\n\n    el = (_b = (_a = instance._nextVal) === null || _a === void 0 ? void 0 : _a.element) === null || _b === void 0 ? void 0 : _b.get();\n\n    if (el && parent.contains(el)) {\n      delete instance._nextVal;\n    }\n\n    wel = instance._lastVal;\n    el = wel && wel.get();\n\n    if (el && parent.contains(el)) {\n      delete instance._lastVal;\n    }\n  }\n\n  getFocusedElement() {\n    return this.getVal();\n  }\n\n  getLastFocusedElement() {\n    var _a;\n\n    let el = (_a = this._lastVal) === null || _a === void 0 ? void 0 : _a.get();\n\n    if (!el || el && !documentContains(el.ownerDocument, el)) {\n      this._lastVal = el = undefined;\n    }\n\n    return el;\n  }\n\n  focus(element, noFocusedProgrammaticallyFlag, noAccessibleCheck) {\n    if (!this._tabster.focusable.isFocusable(element, noFocusedProgrammaticallyFlag, false, noAccessibleCheck)) {\n      return false;\n    }\n\n    element.focus();\n    return true;\n  }\n\n  focusDefault(container) {\n    const el = this._tabster.focusable.findDefault({\n      container\n    });\n\n    if (el) {\n      this._tabster.focusedElement.focus(el);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  getFirstOrLastTabbable(isFirst, props) {\n    const tabsterFocusable = this._tabster.focusable;\n    const {\n      container,\n      ignoreAccessibility\n    } = props;\n    let uncontrolled;\n    let toFocus;\n\n    if (container) {\n      const ctx = RootAPI.getTabsterContext(this._tabster, container);\n\n      if (ctx) {\n        let next = FocusedElementState.findNextTabbable(this._tabster, ctx, container, undefined, !isFirst, undefined, ignoreAccessibility);\n\n        if (next) {\n          toFocus = next.element;\n          uncontrolled = next.uncontrolled;\n\n          while (!toFocus && uncontrolled) {\n            if (tabsterFocusable.isFocusable(uncontrolled, false, true, true)) {\n              toFocus = uncontrolled;\n            } else {\n              toFocus = tabsterFocusable[isFirst ? \"findFirst\" : \"findLast\"]({\n                container: uncontrolled,\n                ignoreUncontrolled: true,\n                ignoreAccessibility,\n                useActiveModalizer: true\n              });\n            }\n\n            if (!toFocus) {\n              next = FocusedElementState.findNextTabbable(this._tabster, ctx, uncontrolled, undefined, !isFirst, undefined, ignoreAccessibility);\n\n              if (next) {\n                toFocus = next.element;\n                uncontrolled = next.uncontrolled;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (toFocus && !(container === null || container === void 0 ? void 0 : container.contains(toFocus))) {\n      toFocus = undefined;\n    }\n\n    return toFocus || undefined;\n  }\n\n  _focusFirstOrLast(isFirst, props) {\n    const toFocus = this.getFirstOrLastTabbable(isFirst, props);\n\n    if (toFocus) {\n      this.focus(toFocus, false, true);\n      return true;\n    }\n\n    return false;\n  }\n\n  focusFirst(props) {\n    return this._focusFirstOrLast(true, props);\n  }\n\n  focusLast(props) {\n    return this._focusFirstOrLast(false, props);\n  }\n\n  resetFocus(container) {\n    if (!this._tabster.focusable.isVisible(container)) {\n      return false;\n    }\n\n    if (!this._tabster.focusable.isFocusable(container, true, true, true)) {\n      const prevTabIndex = container.getAttribute(\"tabindex\");\n      const prevAriaHidden = container.getAttribute(\"aria-hidden\");\n      container.tabIndex = -1;\n      container.setAttribute(\"aria-hidden\", \"true\");\n      FocusedElementState._lastResetElement = new WeakHTMLElement(this._win, container);\n      this.focus(container, true, true);\n\n      this._setOrRemoveAttribute(container, \"tabindex\", prevTabIndex);\n\n      this._setOrRemoveAttribute(container, \"aria-hidden\", prevAriaHidden);\n    } else {\n      this.focus(container);\n    }\n\n    return true;\n  }\n\n  _setOrRemoveAttribute(element, name, value) {\n    if (value === null) {\n      element.removeAttribute(name);\n    } else {\n      element.setAttribute(name, value);\n    }\n  }\n\n  _setFocusedElement(element, relatedTarget, isFocusedProgrammatically) {\n    var _a, _b;\n\n    if (this._tabster._noop) {\n      return;\n    }\n\n    const details = {\n      relatedTarget\n    };\n\n    if (element) {\n      const lastResetElement = (_a = FocusedElementState._lastResetElement) === null || _a === void 0 ? void 0 : _a.get();\n      FocusedElementState._lastResetElement = undefined;\n\n      if (lastResetElement === element || shouldIgnoreFocus(element)) {\n        return;\n      }\n\n      details.isFocusedProgrammatically = isFocusedProgrammatically;\n      const ctx = RootAPI.getTabsterContext(this._tabster, element);\n      const modalizerId = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer) === null || _b === void 0 ? void 0 : _b.userId;\n\n      if (modalizerId) {\n        details.modalizerId = modalizerId;\n      }\n    }\n\n    const nextVal = this._nextVal = {\n      element: element ? new WeakHTMLElement(this._win, element) : undefined,\n      details\n    };\n\n    if (element && element !== this._val) {\n      this._validateFocusedElement(element);\n    } // _validateFocusedElement() might cause the refocus which will trigger\n    // another call to this function. Making sure that the value is correct.\n\n\n    if (this._nextVal === nextVal) {\n      this.setVal(element, details);\n    }\n\n    this._nextVal = undefined;\n  }\n\n  setVal(val, details) {\n    super.setVal(val, details);\n\n    if (val) {\n      this._lastVal = new WeakHTMLElement(this._win, val);\n    }\n  }\n\n  static findNextTabbable(tabster, ctx, container, currentElement, isBackward, ignoreUncontrolled, ignoreAccessibility) {\n    const actualContainer = container || ctx.root.getElement();\n\n    if (!actualContainer) {\n      return null;\n    }\n\n    let next = null;\n    const isTabbingTimer = FocusedElementState._isTabbingTimer;\n    const win = tabster.getWindow();\n\n    if (isTabbingTimer) {\n      win.clearTimeout(isTabbingTimer);\n    }\n\n    FocusedElementState.isTabbing = true;\n    FocusedElementState._isTabbingTimer = win.setTimeout(() => {\n      delete FocusedElementState._isTabbingTimer;\n      FocusedElementState.isTabbing = false;\n    }, 0);\n\n    const callFindNext = (what, cur) => {\n      next = what.findNextTabbable(cur || currentElement, isBackward, ignoreUncontrolled, ignoreAccessibility);\n      const lastMoverOrGroupper = next === null || next === void 0 ? void 0 : next.lastMoverOrGroupper;\n\n      if (lastMoverOrGroupper && !(next === null || next === void 0 ? void 0 : next.element) && !(next === null || next === void 0 ? void 0 : next.uncontrolled)) {\n        // Handling nested Movers and Grouppers. If not found in the current one,\n        // try the parent one.\n        const lastMoverOrGroupperElement = lastMoverOrGroupper.getElement();\n        const parentElement = lastMoverOrGroupperElement === null || lastMoverOrGroupperElement === void 0 ? void 0 : lastMoverOrGroupperElement.parentElement;\n        const parentCtx = parentElement && RootAPI.getTabsterContext(tabster, parentElement);\n\n        if (parentCtx) {\n          const isGroupperFirst = parentCtx.isGroupperFirst;\n          const parentMoverOrGroupper = isGroupperFirst ? parentCtx.groupper : parentCtx.mover;\n\n          if (parentMoverOrGroupper) {\n            const newCurrent = isBackward ? lastMoverOrGroupperElement : getLastChild(lastMoverOrGroupperElement);\n            callFindNext(parentMoverOrGroupper, newCurrent);\n\n            if (next) {\n              next.outOfDOMOrder = true;\n            }\n          }\n        }\n      }\n    };\n\n    const modalizer = ctx.modalizer;\n    const groupper = ctx.groupper;\n    const mover = ctx.mover;\n\n    if (groupper && mover) {\n      callFindNext(ctx.isGroupperFirst ? groupper : mover);\n    } else if (groupper) {\n      callFindNext(groupper);\n    } else if (mover) {\n      callFindNext(mover);\n    } else if (modalizer) {\n      callFindNext(modalizer);\n    } else {\n      let uncontrolled;\n\n      const onUncontrolled = el => {\n        uncontrolled = el;\n      };\n\n      const nextElement = isBackward ? tabster.focusable.findPrev({\n        container: actualContainer,\n        currentElement,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      }) : tabster.focusable.findNext({\n        container: actualContainer,\n        currentElement,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      });\n      next = {\n        element: uncontrolled ? undefined : nextElement,\n        uncontrolled\n      };\n    }\n\n    const lastMoverOrGroupper = next === null || next === void 0 ? void 0 : next.lastMoverOrGroupper;\n    const lastMoverOrGroupperElement = lastMoverOrGroupper === null || lastMoverOrGroupper === void 0 ? void 0 : lastMoverOrGroupper.getElement();\n\n    if (lastMoverOrGroupperElement) {\n      next = null;\n      const adjacentElement = getAdjacentElement(lastMoverOrGroupperElement, isBackward);\n\n      if (adjacentElement) {\n        const adjacentCtx = RootAPI.getTabsterContext(tabster, adjacentElement, {\n          checkRtl: true\n        });\n\n        if (adjacentCtx) {\n          let adjacentFrom = getAdjacentElement(adjacentElement, !isBackward);\n\n          if (adjacentFrom) {\n            if (!isBackward) {\n              adjacentFrom = getLastChild(adjacentFrom) || adjacentFrom;\n            }\n\n            next = FocusedElementState.findNextTabbable(tabster, adjacentCtx, actualContainer, adjacentFrom, isBackward, ignoreUncontrolled, ignoreAccessibility);\n\n            if (next && !next.lastMoverOrGroupper) {\n              next.lastMoverOrGroupper = lastMoverOrGroupper;\n            }\n          }\n        }\n      }\n    }\n\n    return next;\n  }\n\n}\nFocusedElementState.isTabbing = false;\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nclass GroupperDummyManager extends DummyInputManager {\n  constructor(element, groupper, tabster, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Groupper, sys, true);\n\n    this._setHandlers((dummyInput, isBackward, relatedTarget) => {\n      var _a, _b;\n\n      const container = element.get();\n      const input = dummyInput.input;\n\n      if (container && input) {\n        const ctx = RootAPI.getTabsterContext(tabster, input);\n\n        if (ctx) {\n          let next;\n          next = (_a = groupper.findNextTabbable(relatedTarget || undefined, isBackward, true, true)) === null || _a === void 0 ? void 0 : _a.element;\n\n          if (!next) {\n            next = (_b = FocusedElementState.findNextTabbable(tabster, ctx, undefined, dummyInput.isOutside ? input : getAdjacentElement(container, !isBackward), isBackward, true, true)) === null || _b === void 0 ? void 0 : _b.element;\n          }\n\n          if (next) {\n            nativeFocus(next);\n          }\n        }\n      }\n    });\n  }\n\n}\n\nclass Groupper extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    super(tabster, element, props);\n    this._shouldTabInside = false;\n    this.makeTabbable(false);\n    this._onDispose = onDispose;\n\n    if (!tabster.controlTab) {\n      this.dummyManager = new GroupperDummyManager(this._element, this, tabster, sys);\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    this._onDispose(this);\n\n    const element = this._element.get();\n\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n\n    if (element) {\n      if (process.env.NODE_ENV === 'development') {\n        _setInformativeStyle$1(this._element, true);\n      }\n    }\n\n    delete this._first;\n  }\n\n  findNextTabbable(currentElement, isBackward, ignoreUncontrolled, ignoreAccessibility) {\n    var _a;\n\n    const groupperElement = this.getElement();\n\n    if (!groupperElement) {\n      return null;\n    }\n\n    const currentIsDummy = ((_a = currentElement === null || currentElement === void 0 ? void 0 : currentElement.__tabsterDummyContainer) === null || _a === void 0 ? void 0 : _a.get()) === groupperElement;\n\n    if (!this._shouldTabInside && currentElement && groupperElement.contains(currentElement) && !currentIsDummy) {\n      return {\n        element: undefined,\n        lastMoverOrGroupper: this\n      };\n    }\n\n    const groupperFirstFocusable = this.getFirst(true);\n\n    if (!currentElement || !groupperElement.contains(currentElement) || currentIsDummy) {\n      return {\n        element: groupperFirstFocusable,\n        lastMoverOrGroupper: groupperFirstFocusable ? undefined : this\n      };\n    }\n\n    const tabster = this._tabster;\n    let next = null;\n    let uncontrolled;\n\n    const onUncontrolled = el => {\n      uncontrolled = el;\n    };\n\n    if (this._shouldTabInside && groupperFirstFocusable) {\n      next = isBackward ? tabster.focusable.findPrev({\n        container: groupperElement,\n        currentElement,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      }) : tabster.focusable.findNext({\n        container: groupperElement,\n        currentElement,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      });\n\n      if (!uncontrolled && !next && this._props.tabbability === GroupperTabbabilities.LimitedTrapFocus) {\n        next = isBackward ? tabster.focusable.findLast({\n          container: groupperElement,\n          ignoreUncontrolled: true,\n          ignoreAccessibility,\n          useActiveModalizer: true\n        }) : tabster.focusable.findFirst({\n          container: groupperElement,\n          ignoreUncontrolled: true,\n          ignoreAccessibility,\n          useActiveModalizer: true\n        });\n      }\n    }\n\n    return {\n      element: next,\n      uncontrolled,\n      lastMoverOrGroupper: next || uncontrolled ? undefined : this\n    };\n  }\n\n  makeTabbable(isTabbable) {\n    this._shouldTabInside = isTabbable || !this._props.tabbability;\n\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle$1(this._element, !this._shouldTabInside);\n    }\n  }\n\n  isActive(noIfFirstIsFocused) {\n    var _a;\n\n    const element = this.getElement() || null;\n    let isParentActive = true;\n\n    for (let e = element === null || element === void 0 ? void 0 : element.parentElement; e; e = e.parentElement) {\n      const g = (_a = getTabsterOnElement(this._tabster, e)) === null || _a === void 0 ? void 0 : _a.groupper;\n\n      if (g) {\n        if (!g._shouldTabInside) {\n          isParentActive = false;\n        }\n      }\n    }\n\n    let ret = isParentActive ? this._props.tabbability ? this._shouldTabInside : false : undefined;\n\n    if (ret && noIfFirstIsFocused) {\n      const focused = this._tabster.focusedElement.getFocusedElement();\n\n      if (focused) {\n        ret = focused !== this.getFirst(true);\n      }\n    }\n\n    return ret;\n  }\n\n  getFirst(orContainer) {\n    var _a;\n\n    const groupperElement = this.getElement();\n    let first;\n\n    if (groupperElement) {\n      if (orContainer && this._tabster.focusable.isFocusable(groupperElement)) {\n        return groupperElement;\n      }\n\n      first = (_a = this._first) === null || _a === void 0 ? void 0 : _a.get();\n\n      if (!first) {\n        first = this._tabster.focusable.findFirst({\n          container: groupperElement,\n          ignoreUncontrolled: true,\n          useActiveModalizer: true\n        }) || undefined;\n\n        if (first) {\n          this.setFirst(first);\n        }\n      }\n    }\n\n    return first;\n  }\n\n  setFirst(element) {\n    if (element) {\n      this._first = new WeakHTMLElement(this._tabster.getWindow, element);\n    } else {\n      delete this._first;\n    }\n  }\n\n  acceptElement(element, state) {\n    var _a;\n\n    const cachedGrouppers = state.cachedGrouppers;\n    const parentElement = (_a = this.getElement()) === null || _a === void 0 ? void 0 : _a.parentElement;\n    const parentCtx = parentElement && RootAPI.getTabsterContext(this._tabster, parentElement);\n    const parentCtxGroupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;\n    const parentGroupper = (parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.isGroupperFirst) ? parentCtxGroupper : undefined;\n    let parentGroupperElement;\n\n    const getIsActive = groupper => {\n      let cached = cachedGrouppers[groupper.id];\n      let isActive;\n\n      if (cached) {\n        isActive = cached.isActive;\n      } else {\n        isActive = this.isActive(true);\n        cached = cachedGrouppers[groupper.id] = {\n          isActive\n        };\n      }\n\n      return isActive;\n    };\n\n    if (parentGroupper) {\n      parentGroupperElement = parentGroupper.getElement();\n\n      if (!getIsActive(parentGroupper) && parentGroupperElement && state.container !== parentGroupperElement && state.container.contains(parentGroupperElement)) {\n        // Do not fall into a child groupper of inactive parent groupper if it's in the scope of the search.\n        return NodeFilter.FILTER_REJECT;\n      }\n    }\n\n    const isActive = getIsActive(this);\n    const groupperElement = this.getElement();\n\n    if (groupperElement) {\n      if (isActive !== true) {\n        if (groupperElement === element && parentCtxGroupper) {\n          if (!parentGroupperElement) {\n            parentGroupperElement = parentCtxGroupper.getElement();\n          }\n\n          if (parentGroupperElement && !getIsActive(parentCtxGroupper) && state.container.contains(parentGroupperElement) && parentGroupperElement !== state.container) {\n            return NodeFilter.FILTER_REJECT;\n          }\n        }\n\n        if (groupperElement !== element && groupperElement.contains(element)) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        const cached = cachedGrouppers[this.id];\n        let first;\n\n        if (\"first\" in cached) {\n          first = cached.first;\n        } else {\n          first = cached.first = this.getFirst(true);\n        }\n\n        if (first && state.acceptCondition(first)) {\n          state.lastToIgnore = groupperElement;\n\n          if (first !== state.from) {\n            state.found = true;\n            state.foundElement = first;\n            return NodeFilter.FILTER_ACCEPT;\n          } else {\n            return NodeFilter.FILTER_REJECT;\n          }\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass GroupperAPI {\n  constructor(tabster, getWindow) {\n    this._current = {};\n    this._grouppers = {};\n\n    this._init = () => {\n      const win = this._win(); // Making sure groupper's onFocus is called before modalizer's onFocus.\n\n\n      this._tabster.focusedElement.subscribeFirst(this._onFocus);\n\n      win.document.addEventListener(\"mousedown\", this._onMouseDown, true);\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n    };\n\n    this._onGroupperDispose = groupper => {\n      delete this._grouppers[groupper.id];\n    };\n\n    this._onFocus = element => {\n      if (element) {\n        this._updateCurrent(element, true, true);\n      }\n    };\n\n    this._onMouseDown = e => {\n      if (e.target) {\n        this._updateCurrent(e.target, true);\n      }\n    };\n\n    this._onKeyDown = event => {\n      if (event.keyCode !== Keys.Enter && event.keyCode !== Keys.Esc) {\n        return;\n      }\n\n      const element = this._tabster.focusedElement.getFocusedElement();\n\n      if (element) {\n        this.handleKeyPress(element, event);\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = getWindow;\n    tabster.queueInit(this._init);\n  }\n\n  dispose() {\n    const win = this._win();\n\n    this._current = {};\n\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    win.document.removeEventListener(\"mousedown\", this._onMouseDown, true);\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    Object.keys(this._grouppers).forEach(groupperId => {\n      if (this._grouppers[groupperId]) {\n        this._grouppers[groupperId].dispose();\n\n        delete this._grouppers[groupperId];\n      }\n    });\n  }\n\n  createGroupper(element, props, sys) {\n    if (process.env.NODE_ENV === 'development') ;\n\n    const newGroupper = new Groupper(this._tabster, element, this._onGroupperDispose, props, sys);\n    this._grouppers[newGroupper.id] = newGroupper;\n\n    const focusedElement = this._tabster.focusedElement.getFocusedElement(); // Newly created groupper contains currently focused element, update the state on the next tick (to\n    // make sure all grouppers are processed).\n\n\n    if (focusedElement && element.contains(focusedElement) && !this._updateTimer) {\n      this._updateTimer = this._win().setTimeout(() => {\n        delete this._updateTimer; // Making sure the focused element hasn't changed.\n\n        if (focusedElement === this._tabster.focusedElement.getFocusedElement()) {\n          this._updateCurrent(focusedElement, true, true);\n        }\n      }, 0);\n    }\n\n    return newGroupper;\n  }\n\n  forgetCurrentGrouppers() {\n    this._current = {};\n  }\n\n  _updateCurrent(element, includeTarget, checkTarget) {\n    var _a;\n\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n\n      delete this._updateTimer;\n    }\n\n    const newIds = {};\n    let isTarget = true;\n\n    for (let el = element; el; el = el.parentElement) {\n      const groupper = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;\n\n      if (groupper) {\n        newIds[groupper.id] = true;\n\n        if (isTarget && checkTarget && el !== element) {\n          isTarget = false;\n        }\n\n        if (includeTarget || !isTarget) {\n          this._current[groupper.id] = groupper;\n          const isTabbable = groupper.isActive() || element !== el && (!groupper.getProps().delegated || groupper.getFirst(false) !== element);\n          groupper.makeTabbable(isTabbable);\n        }\n\n        isTarget = false;\n      }\n    }\n\n    for (const id of Object.keys(this._current)) {\n      const groupper = this._current[id];\n\n      if (!(groupper.id in newIds)) {\n        groupper.makeTabbable(false);\n        groupper.setFirst(undefined);\n        delete this._current[id];\n      }\n    }\n  }\n\n  handleKeyPress(element, event, noGoUp) {\n    var _a;\n\n    const tabster = this._tabster;\n    const ctx = RootAPI.getTabsterContext(tabster, element);\n    const modalizerInGroupper = ctx === null || ctx === void 0 ? void 0 : ctx.modalizerInGroupper;\n    let groupper = (ctx === null || ctx === void 0 ? void 0 : ctx.groupper) || modalizerInGroupper;\n\n    if (ctx && groupper) {\n      if (ctx.ignoreKeydown(event)) {\n        return;\n      }\n\n      let next;\n      const groupperElement = groupper.getElement();\n\n      if (event.keyCode === Keys.Enter) {\n        if (groupperElement && (element === groupperElement || groupper.getProps().delegated && element === groupper.getFirst(false))) {\n          next = tabster.focusable.findNext({\n            container: groupperElement,\n            currentElement: element,\n            useActiveModalizer: true\n          });\n        }\n      } else if (event.keyCode === Keys.Esc) {\n        if (groupperElement && groupperElement.contains(element)) {\n          if (element !== groupperElement || noGoUp) {\n            next = groupper.getFirst(true);\n          } else {\n            const parentElement = groupperElement.parentElement;\n            const parentCtx = parentElement ? RootAPI.getTabsterContext(tabster, parentElement) : undefined;\n            groupper = parentCtx === null || parentCtx === void 0 ? void 0 : parentCtx.groupper;\n            next = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);\n          }\n        }\n\n        if (groupper) {\n          groupper.makeTabbable(false);\n\n          if (modalizerInGroupper) {\n            (_a = tabster.modalizer) === null || _a === void 0 ? void 0 : _a.setActive(undefined);\n          }\n        }\n      }\n\n      if (next) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        next.focus();\n      }\n    }\n  }\n\n}\n\nfunction _setInformativeStyle$1(weakElement, remove) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-groupper\");\n      } else {\n        element.style.setProperty(\"--tabster-groupper\", \"unlimited\");\n      }\n    }\n  }\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nclass KeyboardNavigationState extends Subscribable {\n  constructor(getWindow) {\n    super();\n\n    this._onChange = isNavigatingWithKeyboard => {\n      this.setVal(isNavigatingWithKeyboard, undefined);\n    };\n\n    this._keyborg = createKeyborg(getWindow());\n\n    this._keyborg.subscribe(this._onChange);\n  }\n\n  dispose() {\n    super.dispose();\n\n    if (this._keyborg) {\n      this._keyborg.unsubscribe(this._onChange);\n\n      disposeKeyborg(this._keyborg);\n      delete this._keyborg;\n    }\n  }\n\n  setNavigatingWithKeyboard(isNavigatingWithKeyboard) {\n    var _a;\n\n    (_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.setVal(isNavigatingWithKeyboard);\n  }\n\n  isNavigatingWithKeyboard() {\n    var _a;\n\n    return !!((_a = this._keyborg) === null || _a === void 0 ? void 0 : _a.isNavigatingWithKeyboard());\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nlet _wasFocusedCounter = 0;\nconst _ariaHidden = \"aria-hidden\";\n\nfunction _setInformativeStyle(weakElement, remove, internalId, userId, isActive, wasFocused) {\n  if (process.env.NODE_ENV === 'development') {\n    const element = weakElement.get();\n\n    if (element) {\n      if (remove) {\n        element.style.removeProperty(\"--tabster-modalizer\");\n      } else {\n        element.style.setProperty(\"--tabster-modalizer\", internalId + \",\" + userId + \",\" + (isActive ? \"active\" : \"inactive\") + \",\" + \",\" + (wasFocused ? `focused(${wasFocused})` : \"not-focused\"));\n      }\n    }\n  }\n}\n/**\r\n * Manages the dummy inputs for the Modalizer.\r\n */\n\n\nclass ModalizerDummyManager extends DummyInputManager {\n  constructor(element, tabster, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Modalizer, sys);\n\n    this._setHandlers((dummyInput, isBackward) => {\n      var _a, _b, _c;\n\n      const el = element.get();\n      const container = el && ((_a = RootAPI.getRoot(tabster, el)) === null || _a === void 0 ? void 0 : _a.getElement());\n      const input = dummyInput.input;\n      let toFocus;\n\n      if (container && input) {\n        const dummyContainer = (_b = input.__tabsterDummyContainer) === null || _b === void 0 ? void 0 : _b.get();\n        const ctx = RootAPI.getTabsterContext(tabster, dummyContainer || input);\n\n        if (ctx) {\n          toFocus = (_c = FocusedElementState.findNextTabbable(tabster, ctx, container, input, isBackward, true, true)) === null || _c === void 0 ? void 0 : _c.element;\n        }\n\n        if (toFocus) {\n          nativeFocus(toFocus);\n        }\n      }\n    });\n  }\n\n}\n\nclass Modalizer extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys, activeElements) {\n    super(tabster, element, props);\n    this._wasFocused = 0;\n    this.userId = props.id;\n    this._onDispose = onDispose;\n    this._activeElements = activeElements;\n\n    if (!tabster.controlTab) {\n      this.dummyManager = new ModalizerDummyManager(this._element, tabster, sys);\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);\n    }\n  }\n\n  makeActive(isActive) {\n    if (this._isActive !== isActive) {\n      this._isActive = isActive;\n      const element = this.getElement();\n\n      if (element) {\n        const activeElements = this._activeElements;\n        const index = activeElements.map(e => e.deref()).indexOf(element);\n\n        if (isActive) {\n          if (index < 0) {\n            activeElements.push(new WeakRef(element));\n          }\n        } else {\n          if (index >= 0) {\n            activeElements.splice(index, 1);\n          }\n        }\n      }\n\n      if (process.env.NODE_ENV === 'development') {\n        _setInformativeStyle(this._element, false, this.id, this.userId, this._isActive, this._wasFocused);\n      }\n\n      this.triggerFocusEvent(isActive ? ModalizerActiveEventName : ModalizerInactiveEventName);\n    }\n  }\n\n  focused(noIncrement) {\n    if (!noIncrement) {\n      this._wasFocused = ++_wasFocusedCounter;\n    }\n\n    return this._wasFocused;\n  }\n\n  setProps(props) {\n    if (props.id) {\n      this.userId = props.id;\n    }\n\n    this._props = { ...props\n    };\n  }\n\n  dispose() {\n    var _a;\n\n    this.makeActive(false);\n\n    this._onDispose(this);\n\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n    this._activeElements = [];\n\n    this._remove();\n  }\n\n  isActive() {\n    return !!this._isActive;\n  }\n\n  contains(element) {\n    var _a;\n\n    return !!((_a = this.getElement()) === null || _a === void 0 ? void 0 : _a.contains(element));\n  }\n\n  findNextTabbable(currentElement, isBackward, ignoreUncontrolled, ignoreAccessibility) {\n    var _a, _b;\n\n    const modalizerElement = this.getElement();\n\n    if (!modalizerElement) {\n      return null;\n    }\n\n    const tabster = this._tabster;\n    let next = null;\n    let uncontrolled;\n\n    const onUncontrolled = el => {\n      uncontrolled = el;\n    };\n\n    const container = currentElement && ((_a = RootAPI.getRoot(tabster, currentElement)) === null || _a === void 0 ? void 0 : _a.getElement());\n\n    if (container) {\n      next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"]({\n        container,\n        currentElement,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      });\n\n      if (!uncontrolled && !next && this._props.isTrapped && ((_b = tabster.modalizer) === null || _b === void 0 ? void 0 : _b.activeId)) {\n        next = tabster.focusable[isBackward ? \"findLast\" : \"findFirst\"]({\n          container,\n          ignoreUncontrolled: true,\n          ignoreAccessibility,\n          useActiveModalizer: true\n        });\n      }\n    }\n\n    return {\n      element: next,\n      uncontrolled\n    };\n  }\n\n  triggerFocusEvent(eventName, allElements) {\n    const element = this.getElement();\n    let defaultPrevented = false;\n\n    if (element) {\n      const elements = allElements ? this._activeElements.map(e => e.deref()) : [element];\n\n      for (const el of elements) {\n        if (el && !triggerEvent(el, eventName, {\n          id: this.userId,\n          element,\n          eventName\n        })) {\n          defaultPrevented = true;\n        }\n      }\n    }\n\n    return defaultPrevented;\n  }\n\n  _remove() {\n    if (process.env.NODE_ENV === 'development') {\n      _setInformativeStyle(this._element, true);\n    }\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nclass ModalizerAPI {\n  constructor(tabster) {\n    this._onModalizerDispose = modalizer => {\n      const id = modalizer.id;\n      const userId = modalizer.userId;\n      const part = this._parts[userId];\n      delete this._modalizers[id];\n\n      if (part) {\n        delete part[id];\n\n        if (Object.keys(part).length === 0) {\n          delete this._parts[userId];\n\n          if (this.activeId === userId) {\n            this.setActive(undefined);\n          }\n        }\n      }\n    };\n\n    this._onKeyDown = event => {\n      var _a;\n\n      if (event.keyCode !== Keys.Esc) {\n        return;\n      }\n\n      const tabster = this._tabster;\n      const element = tabster.focusedElement.getFocusedElement();\n\n      if (element) {\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n\n        if (ctx && !ctx.groupper && (modalizer === null || modalizer === void 0 ? void 0 : modalizer.isActive()) && !ctx.ignoreKeydown(event)) {\n          const activeId = modalizer.userId;\n\n          if (activeId) {\n            const part = this._parts[activeId];\n\n            if (part) {\n              const focusedSince = Object.keys(part).map(id => {\n                var _a;\n\n                const m = part[id];\n                const el = m.getElement();\n                let groupper;\n\n                if (el) {\n                  groupper = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.groupper;\n                }\n\n                return m && el && groupper ? {\n                  el,\n                  focusedSince: m.focused(true)\n                } : {\n                  focusedSince: 0\n                };\n              }).filter(f => f.focusedSince > 0).sort((a, b) => a.focusedSince > b.focusedSince ? -1 : a.focusedSince < b.focusedSince ? 1 : 0);\n\n              if (focusedSince.length) {\n                const groupperElement = focusedSince[0].el;\n\n                if (groupperElement) {\n                  (_a = tabster.groupper) === null || _a === void 0 ? void 0 : _a.handleKeyPress(groupperElement, event, true);\n                }\n              }\n            }\n          }\n        }\n      }\n    };\n    /**\r\n     * Subscribes to the focus state and handles modalizer related focus events\r\n     * @param e - Element that is focused\r\n     * @param details - Additional data about the focus event\r\n     */\n\n\n    this._onFocus = (focusedElement, details) => {\n      var _a, _b;\n\n      const ctx = focusedElement && RootAPI.getTabsterContext(this._tabster, focusedElement); // Modalizer behaviour is opt in, only apply to elements that have a tabster context\n\n      if (!ctx || !focusedElement) {\n        return;\n      }\n\n      const augmentedMap = this._augMap;\n\n      for (let e = focusedElement; e; e = e.parentElement) {\n        // If the newly focused element is inside some of the hidden containers,\n        // remove aria-hidden from those synchronously for the screen readers\n        // to be able to read the element. The rest of aria-hiddens, will be removed\n        // acynchronously for the sake of performance.\n        if (augmentedMap.has(e)) {\n          augmentedMap.delete(e);\n          augmentAttribute(this._tabster, e, _ariaHidden);\n        }\n      }\n\n      const modalizer = ctx.modalizer; // An inactive groupper with the modalizer on the same node will not give the modalizer\n      // in the context, yet we still want to track that the modalizer's container was focused.\n\n      (_b = modalizer || ((_a = getTabsterOnElement(this._tabster, focusedElement)) === null || _a === void 0 ? void 0 : _a.modalizer)) === null || _b === void 0 ? void 0 : _b.focused();\n\n      if ((modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId) === this.activeId) {\n        this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;\n        return;\n      } // Developers calling `element.focus()` should change/deactivate active modalizer\n\n\n      if (details.isFocusedProgrammatically || this.currentIsOthersAccessible || (modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isAlwaysAccessible)) {\n        this.setActive(modalizer);\n      } else {\n        // Focused outside of the active modalizer, try pull focus back to current modalizer\n        const win = this._win();\n\n        win.clearTimeout(this._restoreModalizerFocusTimer); // TODO some rendering frameworks (i.e. React) might async rerender the DOM so we need to wait for a duration\n        // Figure out a better way of doing this rather than a 100ms timeout\n\n        this._restoreModalizerFocusTimer = win.setTimeout(() => this._restoreModalizerFocus(focusedElement), 100);\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    this._modalizers = {};\n    this._parts = {};\n    this._augMap = new WeakMap();\n    this._aug = [];\n    this.activeElements = [];\n\n    if (!tabster.controlTab) {\n      tabster.root.addDummyInputs();\n    }\n\n    const win = this._win();\n\n    win.addEventListener(\"keydown\", this._onKeyDown, true);\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    });\n  }\n\n  dispose() {\n    const win = this._win();\n\n    win.removeEventListener(\"keydown\", this._onKeyDown, true); // Dispose all modalizers managed by the API\n\n    Object.keys(this._modalizers).forEach(modalizerId => {\n      if (this._modalizers[modalizerId]) {\n        this._modalizers[modalizerId].dispose();\n\n        delete this._modalizers[modalizerId];\n      }\n    });\n    win.clearTimeout(this._restoreModalizerFocusTimer);\n    win.clearTimeout(this._hiddenUpdateTimer);\n    this._parts = {};\n    delete this.activeId;\n    this.activeElements = [];\n    this._augMap = new WeakMap();\n    this._aug = [];\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n  }\n\n  createModalizer(element, props, sys) {\n    var _a;\n\n    if (process.env.NODE_ENV === 'development') ;\n\n    const modalizer = new Modalizer(this._tabster, element, this._onModalizerDispose, props, sys, this.activeElements);\n    const id = modalizer.id;\n    const userId = props.id;\n    this._modalizers[id] = modalizer;\n    let part = this._parts[userId];\n\n    if (!part) {\n      part = this._parts[userId] = {};\n    }\n\n    part[id] = modalizer; // Adding a modalizer which is already focused, activate it\n\n    if (element.contains((_a = this._tabster.focusedElement.getFocusedElement()) !== null && _a !== void 0 ? _a : null)) {\n      if (userId !== this.activeId) {\n        this.setActive(modalizer);\n      } else {\n        modalizer.makeActive(true);\n      }\n    }\n\n    return modalizer;\n  }\n\n  isAugmented(element) {\n    return this._augMap.has(element);\n  }\n\n  hiddenUpdate() {\n    if (this._hiddenUpdateTimer) {\n      return;\n    }\n\n    this._hiddenUpdateTimer = this._win().setTimeout(() => {\n      delete this._hiddenUpdateTimer;\n\n      this._hiddenUpdate();\n    }, 250);\n  }\n\n  setActive(modalizer) {\n    const userId = modalizer === null || modalizer === void 0 ? void 0 : modalizer.userId;\n    const activeId = this.activeId;\n\n    if (activeId === userId) {\n      return;\n    }\n\n    this.activeId = userId;\n\n    if (activeId) {\n      const part = this._parts[activeId];\n\n      if (part) {\n        for (const id of Object.keys(part)) {\n          part[id].makeActive(false);\n        }\n      }\n    }\n\n    if (userId) {\n      const part = this._parts[userId];\n\n      if (part) {\n        for (const id of Object.keys(part)) {\n          part[id].makeActive(true);\n        }\n      }\n    }\n\n    this.currentIsOthersAccessible = modalizer === null || modalizer === void 0 ? void 0 : modalizer.getProps().isOthersAccessible;\n    this.hiddenUpdate();\n  }\n\n  focus(elementFromModalizer, noFocusFirst, noFocusDefault) {\n    const ctx = RootAPI.getTabsterContext(this._tabster, elementFromModalizer);\n    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n\n    if (modalizer) {\n      this.setActive(modalizer);\n      const props = modalizer.getProps();\n      const modalizerRoot = modalizer.getElement();\n\n      if (modalizerRoot) {\n        if (noFocusFirst === undefined) {\n          noFocusFirst = props.isNoFocusFirst;\n        }\n\n        if (!noFocusFirst && this._tabster.keyboardNavigation.isNavigatingWithKeyboard() && this._tabster.focusedElement.focusFirst({\n          container: modalizerRoot\n        })) {\n          return true;\n        }\n\n        if (noFocusDefault === undefined) {\n          noFocusDefault = props.isNoFocusDefault;\n        }\n\n        if (!noFocusDefault && this._tabster.focusedElement.focusDefault(modalizerRoot)) {\n          return true;\n        }\n\n        this._tabster.focusedElement.resetFocus(modalizerRoot);\n      }\n    } else if (process.env.NODE_ENV === 'development') {\n      console.error(\"Element is not in Modalizer.\", elementFromModalizer);\n    }\n\n    return false;\n  }\n\n  acceptElement(element, state) {\n    var _a;\n\n    const modalizerUserId = state.modalizerUserId;\n    const currentModalizer = (_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.modalizer;\n\n    if (modalizerUserId) {\n      for (const e of this.activeElements) {\n        const el = e.deref();\n\n        if (el && (element.contains(el) || el === element)) {\n          // We have a part of currently active modalizer somewhere deeper in the DOM,\n          // skipping all other checks.\n          return NodeFilter.FILTER_SKIP;\n        }\n      }\n    }\n\n    return modalizerUserId === (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.userId) || !modalizerUserId && (currentModalizer === null || currentModalizer === void 0 ? void 0 : currentModalizer.getProps().isAlwaysAccessible) ? undefined : NodeFilter.FILTER_SKIP;\n  }\n\n  _hiddenUpdate() {\n    var _a;\n\n    const tabster = this._tabster;\n    const body = tabster.getWindow().document.body;\n    const activeId = this.activeId;\n    const parts = this._parts;\n    const visibleElements = [];\n    const hiddenElements = [];\n    const alwaysAccessibleElements = [];\n\n    for (const userId of Object.keys(parts)) {\n      const mParts = parts[userId];\n\n      for (const id of Object.keys(mParts)) {\n        const m = mParts[id];\n        const el = m.getElement();\n        const props = m.getProps();\n        const isAlwaysAccessible = props.isAlwaysAccessible;\n\n        if (el) {\n          if (userId === activeId) {\n            if (!this.currentIsOthersAccessible) {\n              visibleElements.push(el);\n            }\n          } else if (isAlwaysAccessible) {\n            alwaysAccessibleElements.push(el);\n          } else {\n            hiddenElements.push(el);\n          }\n        }\n      }\n    }\n\n    const augmentedMap = this._augMap;\n    const allVisibleElements = visibleElements.length > 0 ? [...visibleElements, ...alwaysAccessibleElements] : undefined;\n    const newAugmented = [];\n    const newAugmentedMap = new WeakMap();\n\n    const toggle = (element, hide) => {\n      const tagName = element.tagName;\n\n      if (tagName === \"SCRIPT\" || tagName === \"STYLE\") {\n        return;\n      }\n\n      let isAugmented = false;\n\n      if (augmentedMap.has(element)) {\n        if (hide) {\n          isAugmented = true;\n        } else {\n          augmentedMap.delete(element);\n          augmentAttribute(tabster, element, _ariaHidden);\n        }\n      } else if (hide && augmentAttribute(tabster, element, _ariaHidden, \"true\")) {\n        augmentedMap.set(element, true);\n        isAugmented = true;\n      }\n\n      if (isAugmented) {\n        newAugmented.push(new WeakRef(element));\n        newAugmentedMap.set(element, true);\n      }\n    };\n\n    const walk = element => {\n      for (let el = element.firstElementChild; el; el = el.nextElementSibling) {\n        let skip = false;\n        let containsModalizer = false;\n\n        if (allVisibleElements) {\n          for (const c of allVisibleElements) {\n            if (el === c) {\n              skip = true;\n              break;\n            }\n\n            if (el.contains(c)) {\n              containsModalizer = true;\n              break;\n            }\n          }\n\n          if (containsModalizer) {\n            walk(el);\n          } else if (!skip) {\n            toggle(el, true);\n          }\n        } else {\n          toggle(el, false);\n        }\n      }\n    };\n\n    if (!allVisibleElements) {\n      alwaysAccessibleElements.forEach(e => toggle(e, false));\n    }\n\n    hiddenElements.forEach(e => toggle(e, true));\n\n    if (body) {\n      walk(body);\n    }\n\n    (_a = this._aug) === null || _a === void 0 ? void 0 : _a.map(e => e.deref()).forEach(e => {\n      if (e && !newAugmentedMap.get(e)) {\n        toggle(e, false);\n      }\n    });\n    this._aug = newAugmented;\n    this._augMap = newAugmentedMap;\n  }\n  /**\r\n   * Called when an element is focused outside of an active modalizer.\r\n   * Attempts to pull focus back into the active modalizer\r\n   * @param outsideElement - An element being focused outside of the modalizer\r\n   */\n\n\n  _restoreModalizerFocus(outsideElement) {\n    const ownerDocument = outsideElement === null || outsideElement === void 0 ? void 0 : outsideElement.ownerDocument;\n\n    if (!outsideElement || !ownerDocument) {\n      return;\n    }\n\n    const ctx = RootAPI.getTabsterContext(this._tabster, outsideElement);\n    const modalizer = ctx === null || ctx === void 0 ? void 0 : ctx.modalizer;\n    const activeId = this.activeId;\n\n    if (!modalizer && !activeId || modalizer && activeId === modalizer.userId) {\n      return;\n    }\n\n    const container = ctx === null || ctx === void 0 ? void 0 : ctx.root.getElement();\n\n    if (container) {\n      let toFocus = this._tabster.focusable.findFirst({\n        container,\n        ignoreUncontrolled: true,\n        useActiveModalizer: true\n      });\n\n      if (toFocus) {\n        if (outsideElement.compareDocumentPosition(toFocus) & document.DOCUMENT_POSITION_PRECEDING) {\n          toFocus = this._tabster.focusable.findLast({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n\n          if (!toFocus) {\n            // This only might mean that findFirst/findLast are buggy and inconsistent.\n            throw new Error(\"Something went wrong.\");\n          }\n        }\n\n        this._tabster.focusedElement.focus(toFocus);\n\n        return;\n      }\n    } // Current Modalizer doesn't seem to have focusable elements.\n    // Blurring the currently focused element which is outside of the current Modalizer.\n\n\n    outsideElement.blur();\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nconst _inputSelector = /*#__PURE__*/[\"input\", \"textarea\", \"*[contenteditable]\"].join(\", \");\n\nclass MoverDummyManager extends DummyInputManager {\n  constructor(element, tabster, getMemorized, sys) {\n    super(tabster, element, DummyInputManagerPriorities.Mover, sys);\n\n    this._onFocusDummyInput = dummyInput => {\n      var _a, _b;\n\n      const container = this._element.get();\n\n      const input = dummyInput.input;\n\n      if (container && input) {\n        const ctx = RootAPI.getTabsterContext(this._tabster, container);\n        let toFocus;\n\n        if (ctx) {\n          toFocus = (_a = FocusedElementState.findNextTabbable(this._tabster, ctx, undefined, input, !dummyInput.isFirst, true)) === null || _a === void 0 ? void 0 : _a.element;\n        }\n\n        const memorized = (_b = this._getMemorized()) === null || _b === void 0 ? void 0 : _b.get();\n\n        if (memorized) {\n          toFocus = memorized;\n        }\n\n        if (toFocus) {\n          nativeFocus(toFocus);\n        }\n      }\n    };\n\n    this._tabster = tabster;\n    this._getMemorized = getMemorized;\n\n    this._setHandlers(this._onFocusDummyInput);\n  }\n\n} // TypeScript enums produce depressing JavaScript code, so, we're just using\n// a few old style constants here.\n\n\nconst _moverUpdateAdd = 1;\nconst _moverUpdateAttr = 2;\nconst _moverUpdateRemove = 3;\nclass Mover extends TabsterPart {\n  constructor(tabster, element, onDispose, props, sys) {\n    var _a;\n\n    super(tabster, element, props);\n    this._visible = {};\n\n    this._onIntersection = entries => {\n      for (const entry of entries) {\n        const el = entry.target;\n        const id = getElementUId(this._win, el);\n        let newVisibility;\n        let fullyVisible = this._fullyVisible;\n\n        if (entry.intersectionRatio >= 0.25) {\n          newVisibility = entry.intersectionRatio >= 0.75 ? Visibilities.Visible : Visibilities.PartiallyVisible;\n\n          if (newVisibility === Visibilities.Visible) {\n            fullyVisible = id;\n          }\n        } else {\n          newVisibility = Visibilities.Invisible;\n        }\n\n        if (this._visible[id] !== newVisibility) {\n          if (newVisibility === undefined) {\n            delete this._visible[id];\n\n            if (fullyVisible === id) {\n              delete this._fullyVisible;\n            }\n          } else {\n            this._visible[id] = newVisibility;\n            this._fullyVisible = fullyVisible;\n          }\n\n          const state = this.getState(el);\n\n          if (state) {\n            triggerEvent(el, MoverEventName, state);\n          }\n        }\n      }\n    };\n\n    this._win = tabster.getWindow;\n    this.visibilityTolerance = (_a = props.visibilityTolerance) !== null && _a !== void 0 ? _a : 0.8;\n\n    if (this._props.trackState || this._props.visibilityAware) {\n      this._intersectionObserver = new IntersectionObserver(this._onIntersection, {\n        threshold: [0, 0.25, 0.5, 0.75, 1]\n      });\n\n      this._observeState();\n    }\n\n    this._onDispose = onDispose;\n\n    const getMemorized = () => props.memorizeCurrent ? this._current : undefined;\n\n    if (!tabster.controlTab) {\n      this.dummyManager = new MoverDummyManager(this._element, tabster, getMemorized, sys);\n    }\n  }\n\n  dispose() {\n    var _a;\n\n    this._onDispose(this);\n\n    if (this._intersectionObserver) {\n      this._intersectionObserver.disconnect();\n\n      delete this._intersectionObserver;\n    }\n\n    delete this._current;\n    delete this._fullyVisible;\n    delete this._allElements;\n    delete this._updateQueue;\n\n    if (this._unobserve) {\n      this._unobserve();\n\n      delete this._unobserve;\n    }\n\n    const win = this._win();\n\n    if (this._setCurrentTimer) {\n      win.clearTimeout(this._setCurrentTimer);\n      delete this._setCurrentTimer;\n    }\n\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      delete this._updateTimer;\n    }\n\n    (_a = this.dummyManager) === null || _a === void 0 ? void 0 : _a.dispose();\n  }\n\n  setCurrent(element) {\n    if (element) {\n      this._current = new WeakHTMLElement(this._win, element);\n    } else {\n      this._current = undefined;\n    }\n\n    if ((this._props.trackState || this._props.visibilityAware) && !this._setCurrentTimer) {\n      this._setCurrentTimer = this._win().setTimeout(() => {\n        var _a;\n\n        delete this._setCurrentTimer;\n        const changed = [];\n\n        if (this._current !== this._prevCurrent) {\n          changed.push(this._current);\n          changed.push(this._prevCurrent);\n          this._prevCurrent = this._current;\n        }\n\n        for (const weak of changed) {\n          const el = weak === null || weak === void 0 ? void 0 : weak.get();\n\n          if (el && ((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) === this) {\n            const props = this._props;\n\n            if (el && (props.visibilityAware !== undefined || props.trackState)) {\n              const state = this.getState(el);\n\n              if (state) {\n                triggerEvent(el, MoverEventName, state);\n              }\n            }\n          }\n        }\n      });\n    }\n  }\n\n  getCurrent() {\n    var _a;\n\n    return ((_a = this._current) === null || _a === void 0 ? void 0 : _a.get()) || null;\n  }\n\n  findNextTabbable(currentElement, isBackward, ignoreUncontrolled, ignoreAccessibility) {\n    var _a;\n\n    const container = this.getElement();\n    const currentIsDummy = container && ((_a = currentElement === null || currentElement === void 0 ? void 0 : currentElement.__tabsterDummyContainer) === null || _a === void 0 ? void 0 : _a.get()) === container;\n\n    if (!container) {\n      return null;\n    }\n\n    const tabster = this._tabster;\n    const focusable = tabster.focusable;\n    let next = null;\n    let uncontrolled;\n\n    const onUncontrolled = el => {\n      uncontrolled = el;\n    };\n\n    if (this._props.tabbable || currentIsDummy || currentElement && !container.contains(currentElement)) {\n      next = isBackward ? focusable.findPrev({\n        currentElement,\n        container,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      }) : focusable.findNext({\n        currentElement,\n        container,\n        onUncontrolled,\n        ignoreUncontrolled,\n        ignoreAccessibility,\n        useActiveModalizer: true\n      });\n    }\n\n    return {\n      element: next,\n      uncontrolled,\n      lastMoverOrGroupper: next || uncontrolled ? undefined : this\n    };\n  }\n\n  acceptElement(element, state) {\n    var _a, _b, _c;\n\n    if (!FocusedElementState.isTabbing) {\n      return ((_a = state.currentCtx) === null || _a === void 0 ? void 0 : _a.isExcludedFromMover) ? NodeFilter.FILTER_REJECT : undefined;\n    }\n\n    const {\n      memorizeCurrent,\n      visibilityAware,\n      hasDefault\n    } = this._props;\n    const moverElement = this.getElement();\n\n    if (moverElement && (memorizeCurrent || visibilityAware || hasDefault) && (!moverElement.contains(state.from) || ((_b = state.from.__tabsterDummyContainer) === null || _b === void 0 ? void 0 : _b.get()) === moverElement)) {\n      let found;\n\n      if (memorizeCurrent) {\n        const current = (_c = this._current) === null || _c === void 0 ? void 0 : _c.get();\n\n        if (current && state.acceptCondition(current)) {\n          found = current;\n        }\n      }\n\n      if (!found && hasDefault) {\n        found = this._tabster.focusable.findDefault({\n          container: moverElement,\n          ignoreUncontrolled: true,\n          useActiveModalizer: true\n        });\n      }\n\n      if (!found && visibilityAware) {\n        found = this._tabster.focusable.findElement({\n          container: moverElement,\n          ignoreUncontrolled: true,\n          useActiveModalizer: true,\n          isBackward: state.isBackward,\n          acceptCondition: el => {\n            var _a;\n\n            const id = getElementUId(this._win, el);\n            const visibility = this._visible[id];\n            return moverElement !== el && !!((_a = this._allElements) === null || _a === void 0 ? void 0 : _a.get(el)) && state.acceptCondition(el) && (visibility === Visibilities.Visible || visibility === Visibilities.PartiallyVisible && (visibilityAware === Visibilities.PartiallyVisible || !this._fullyVisible));\n          }\n        });\n      }\n\n      if (found) {\n        state.found = true;\n        state.foundElement = found;\n        state.lastToIgnore = moverElement;\n        return NodeFilter.FILTER_ACCEPT;\n      }\n    }\n\n    return undefined;\n  }\n\n  _observeState() {\n    const element = this.getElement();\n\n    if (this._unobserve || !element || typeof MutationObserver === \"undefined\") {\n      return;\n    }\n\n    const win = this._win();\n\n    const allElements = this._allElements = new WeakMap();\n    const tabsterFocusable = this._tabster.focusable;\n    let updateQueue = this._updateQueue = [];\n    const observer = new MutationObserver(mutations => {\n      for (const mutation of mutations) {\n        const target = mutation.target;\n        const removed = mutation.removedNodes;\n        const added = mutation.addedNodes;\n\n        if (mutation.type === \"attributes\") {\n          if (mutation.attributeName === \"tabindex\") {\n            updateQueue.push({\n              element: target,\n              type: _moverUpdateAttr\n            });\n          }\n        } else {\n          for (let i = 0; i < removed.length; i++) {\n            updateQueue.push({\n              element: removed[i],\n              type: _moverUpdateRemove\n            });\n          }\n\n          for (let i = 0; i < added.length; i++) {\n            updateQueue.push({\n              element: added[i],\n              type: _moverUpdateAdd\n            });\n          }\n        }\n      }\n\n      requestUpdate();\n    });\n\n    const setElement = (element, remove) => {\n      var _a, _b;\n\n      const current = allElements.get(element);\n\n      if (current && remove) {\n        (_a = this._intersectionObserver) === null || _a === void 0 ? void 0 : _a.unobserve(element);\n        allElements.delete(element);\n      }\n\n      if (!current && !remove) {\n        allElements.set(element, this);\n        (_b = this._intersectionObserver) === null || _b === void 0 ? void 0 : _b.observe(element);\n      }\n    };\n\n    const updateElement = element => {\n      const isFocusable = tabsterFocusable.isFocusable(element);\n      const current = allElements.get(element);\n\n      if (current) {\n        if (!isFocusable) {\n          setElement(element, true);\n        }\n      } else {\n        if (isFocusable) {\n          setElement(element);\n        }\n      }\n    };\n\n    const addNewElements = element => {\n      const {\n        mover\n      } = getMoverGroupper(element);\n\n      if (mover && mover !== this) {\n        if (mover.getElement() === element && tabsterFocusable.isFocusable(element)) {\n          setElement(element);\n        } else {\n          return;\n        }\n      }\n\n      const walker = createElementTreeWalker(win.document, element, node => {\n        const {\n          mover,\n          groupper\n        } = getMoverGroupper(node);\n\n        if (mover && mover !== this) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        const groupperFirstFocusable = groupper === null || groupper === void 0 ? void 0 : groupper.getFirst(true);\n\n        if (groupper && groupper.getElement() !== node && groupperFirstFocusable && groupperFirstFocusable !== node) {\n          return NodeFilter.FILTER_REJECT;\n        }\n\n        if (tabsterFocusable.isFocusable(node)) {\n          setElement(node);\n        }\n\n        return NodeFilter.FILTER_SKIP;\n      });\n\n      if (walker) {\n        walker.currentNode = element;\n\n        while (walker.nextNode()) {\n          /* Iterating for the sake of calling processNode() callback. */\n        }\n      }\n    };\n\n    const removeWalk = element => {\n      const current = allElements.get(element);\n\n      if (current) {\n        setElement(element, true);\n      }\n\n      for (let el = element.firstElementChild; el; el = el.nextElementSibling) {\n        removeWalk(el);\n      }\n    };\n\n    const requestUpdate = () => {\n      if (!this._updateTimer && updateQueue.length) {\n        this._updateTimer = win.setTimeout(() => {\n          delete this._updateTimer;\n\n          for (const {\n            element,\n            type\n          } of updateQueue) {\n            switch (type) {\n              case _moverUpdateAttr:\n                updateElement(element);\n                break;\n\n              case _moverUpdateAdd:\n                addNewElements(element);\n                break;\n\n              case _moverUpdateRemove:\n                removeWalk(element);\n                break;\n            }\n          }\n\n          updateQueue = this._updateQueue = [];\n        }, 0);\n      }\n    };\n\n    const getMoverGroupper = element => {\n      const ret = {};\n\n      for (let el = element; el; el = el.parentElement) {\n        const toe = getTabsterOnElement(this._tabster, el);\n\n        if (toe) {\n          if (toe.groupper && !ret.groupper) {\n            ret.groupper = toe.groupper;\n          }\n\n          if (toe.mover) {\n            ret.mover = toe.mover;\n            break;\n          }\n        }\n      }\n\n      return ret;\n    };\n\n    updateQueue.push({\n      element,\n      type: _moverUpdateAdd\n    });\n    requestUpdate();\n    observer.observe(element, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: [\"tabindex\"]\n    });\n\n    this._unobserve = () => {\n      observer.disconnect();\n    };\n  }\n\n  getState(element) {\n    const id = getElementUId(this._win, element);\n\n    if (id in this._visible) {\n      const visibility = this._visible[id] || Visibilities.Invisible;\n      const isCurrent = this._current ? this._current.get() === element : undefined;\n      return {\n        isCurrent,\n        visibility\n      };\n    }\n\n    return undefined;\n  }\n\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n/**\r\n * Calculates distance between two rectangles.\r\n *\r\n * @param ax1 first rectangle left\r\n * @param ay1 first rectangle top\r\n * @param ax2 first rectangle right\r\n * @param ay2 first rectangle bottom\r\n * @param bx1 second rectangle left\r\n * @param by1 second rectangle top\r\n * @param bx2 second rectangle right\r\n * @param by2 second rectangle bottom\r\n * @returns number, shortest distance between the rectangles.\r\n */\n\n\nfunction getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n  const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;\n  const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;\n  return xDistance === 0 ? yDistance : yDistance === 0 ? xDistance : Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n}\n\nclass MoverAPI {\n  constructor(tabster, getWindow) {\n    this._init = () => {\n      const win = this._win();\n\n      win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    };\n\n    this._onMoverDispose = mover => {\n      delete this._movers[mover.id];\n    };\n\n    this._onFocus = e => {\n      var _a;\n\n      for (let el = e; el; el = el.parentElement) {\n        const mover = (_a = getTabsterOnElement(this._tabster, el)) === null || _a === void 0 ? void 0 : _a.mover;\n\n        if (mover) {\n          mover.setCurrent(e);\n          break;\n        }\n      }\n    };\n\n    this._onKeyDown = async e => {\n      var _a, _b, _c, _d;\n\n      if (this._ignoredInputTimer) {\n        this._win().clearTimeout(this._ignoredInputTimer);\n\n        delete this._ignoredInputTimer;\n      }\n\n      (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n      let keyCode = e.keyCode; // Mover does not use ctrl key currently\n\n      if (e.ctrlKey) {\n        return;\n      }\n\n      switch (keyCode) {\n        case Keys.Down:\n        case Keys.Right:\n        case Keys.Up:\n        case Keys.Left:\n        case Keys.PageDown:\n        case Keys.PageUp:\n        case Keys.Home:\n        case Keys.End:\n          break;\n\n        default:\n          return;\n      }\n\n      const tabster = this._tabster;\n      const focused = tabster.focusedElement.getFocusedElement();\n\n      if (!focused || (await this._isIgnoredInput(focused, keyCode))) {\n        return;\n      }\n\n      const ctx = RootAPI.getTabsterContext(tabster, focused, {\n        checkRtl: true\n      });\n\n      if (!ctx || !ctx.mover || ctx.isExcludedFromMover || ctx.ignoreKeydown(e)) {\n        return;\n      }\n\n      const mover = ctx.mover;\n      const container = mover.getElement();\n\n      if (ctx.isGroupperFirst) {\n        const groupper = ctx.groupper;\n\n        if (groupper && !groupper.isActive(true)) {\n          // For the cases when we have Mover/Active Groupper/Inactive Groupper, we need to check\n          // the grouppers between the current element and the current mover.\n          for (let el = (_b = groupper.getElement()) === null || _b === void 0 ? void 0 : _b.parentElement; el && el !== container; el = el.parentElement) {\n            if ((_d = (_c = getTabsterOnElement(tabster, el)) === null || _c === void 0 ? void 0 : _c.groupper) === null || _d === void 0 ? void 0 : _d.isActive(true)) {\n              return;\n            }\n          }\n        } else {\n          return;\n        }\n      }\n\n      if (!container) {\n        return;\n      }\n\n      const focusable = tabster.focusable;\n      const moverProps = mover.getProps();\n      const direction = moverProps.direction || MoverDirections.Both;\n      const isBoth = direction === MoverDirections.Both;\n      const isVertical = isBoth || direction === MoverDirections.Vertical;\n      const isHorizontal = isBoth || direction === MoverDirections.Horizontal;\n      const isGrid = direction === MoverDirections.Grid;\n      const isCyclic = moverProps.cyclic;\n      let next;\n      let focusedElementRect;\n      let focusedElementX1 = 0;\n      let focusedElementX2 = 0;\n\n      if (isGrid) {\n        focusedElementRect = focused.getBoundingClientRect();\n        focusedElementX1 = Math.ceil(focusedElementRect.left);\n        focusedElementX2 = Math.floor(focusedElementRect.right);\n      }\n\n      if (ctx.isRtl) {\n        if (keyCode === Keys.Right) {\n          keyCode = Keys.Left;\n        } else if (keyCode === Keys.Left) {\n          keyCode = Keys.Right;\n        }\n      }\n\n      if (keyCode === Keys.Down && isVertical || keyCode === Keys.Right && (isHorizontal || isGrid)) {\n        next = focusable.findNext({\n          currentElement: focused,\n          container,\n          useActiveModalizer: true\n        });\n\n        if (next && isGrid) {\n          const nextElementX1 = Math.ceil(next.getBoundingClientRect().left);\n\n          if (focusedElementX2 > nextElementX1) {\n            next = undefined;\n          }\n        } else if (!next && isCyclic) {\n          next = focusable.findFirst({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n        }\n      } else if (keyCode === Keys.Up && isVertical || keyCode === Keys.Left && (isHorizontal || isGrid)) {\n        next = focusable.findPrev({\n          currentElement: focused,\n          container,\n          useActiveModalizer: true\n        });\n\n        if (next && isGrid) {\n          const nextElementX2 = Math.floor(next.getBoundingClientRect().right);\n\n          if (nextElementX2 > focusedElementX1) {\n            next = undefined;\n          }\n        } else if (!next && isCyclic) {\n          next = focusable.findLast({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n        }\n      } else if (keyCode === Keys.Home) {\n        if (isGrid) {\n          focusable.findElement({\n            container,\n            currentElement: focused,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true,\n            isBackward: true,\n            acceptCondition: el => {\n              var _a;\n\n              if (!focusable.isFocusable(el)) {\n                return false;\n              }\n\n              const nextElementX1 = Math.ceil((_a = el.getBoundingClientRect().left) !== null && _a !== void 0 ? _a : 0);\n\n              if (el !== focused && focusedElementX1 <= nextElementX1) {\n                return true;\n              }\n\n              next = el;\n              return false;\n            }\n          });\n        } else {\n          next = focusable.findFirst({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n        }\n      } else if (keyCode === Keys.End) {\n        if (isGrid) {\n          focusable.findElement({\n            container,\n            currentElement: focused,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true,\n            acceptCondition: el => {\n              var _a;\n\n              if (!focusable.isFocusable(el)) {\n                return false;\n              }\n\n              const nextElementX1 = Math.ceil((_a = el.getBoundingClientRect().left) !== null && _a !== void 0 ? _a : 0);\n\n              if (el !== focused && focusedElementX1 >= nextElementX1) {\n                return true;\n              }\n\n              next = el;\n              return false;\n            }\n          });\n        } else {\n          next = focusable.findLast({\n            container,\n            ignoreUncontrolled: true,\n            useActiveModalizer: true\n          });\n        }\n      } else if (keyCode === Keys.PageUp) {\n        focusable.findElement({\n          currentElement: focused,\n          container,\n          useActiveModalizer: true,\n          isBackward: true,\n          acceptCondition: el => {\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n\n            if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {\n              next = el;\n              return false;\n            }\n\n            return true;\n          }\n        }); // will be on the first column move forward and preserve previous column\n\n        if (isGrid && next) {\n          const firstColumnX1 = Math.ceil(next.getBoundingClientRect().left);\n          focusable.findElement({\n            currentElement: next,\n            container,\n            useActiveModalizer: true,\n            acceptCondition: el => {\n              if (!focusable.isFocusable(el)) {\n                return false;\n              }\n\n              const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);\n\n              if (focusedElementX1 < nextElementX1 || firstColumnX1 >= nextElementX1) {\n                return true;\n              }\n\n              next = el;\n              return false;\n            }\n          });\n        }\n\n        if (next) {\n          scrollIntoView(this._win, next, false);\n        }\n      } else if (keyCode === Keys.PageDown) {\n        focusable.findElement({\n          currentElement: focused,\n          container,\n          useActiveModalizer: true,\n          acceptCondition: el => {\n            if (!focusable.isFocusable(el)) {\n              return false;\n            }\n\n            if (isElementVerticallyVisibleInContainer(this._win, el, mover.visibilityTolerance)) {\n              next = el;\n              return false;\n            }\n\n            return true;\n          }\n        }); // will be on the last column move backwards and preserve previous column\n\n        if (isGrid && next) {\n          const lastColumnX1 = Math.ceil(next.getBoundingClientRect().left);\n          focusable.findElement({\n            currentElement: next,\n            container,\n            useActiveModalizer: true,\n            isBackward: true,\n            acceptCondition: el => {\n              if (!focusable.isFocusable(el)) {\n                return false;\n              }\n\n              const nextElementX1 = Math.ceil(el.getBoundingClientRect().left);\n\n              if (focusedElementX1 > nextElementX1 || lastColumnX1 <= nextElementX1) {\n                return true;\n              }\n\n              next = el;\n              return false;\n            }\n          });\n        }\n\n        if (next) {\n          scrollIntoView(this._win, next, true);\n        }\n      } else if (isGrid) {\n        const isBackward = keyCode === Keys.Up;\n        const ax1 = focusedElementX1; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        const ay1 = Math.ceil(focusedElementRect.top);\n        const ax2 = focusedElementX2; // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        const ay2 = Math.floor(focusedElementRect.bottom);\n        let targetElement;\n        let lastDistance;\n        let lastIntersection = 0;\n        focusable.findAll({\n          container,\n          currentElement: focused,\n          isBackward,\n          onElement: el => {\n            // Find element which has maximal intersection with the focused element horizontally,\n            // or the closest one.\n            const rect = el.getBoundingClientRect();\n            const bx1 = Math.ceil(rect.left);\n            const by1 = Math.ceil(rect.top);\n            const bx2 = Math.floor(rect.right);\n            const by2 = Math.floor(rect.bottom);\n\n            if (isBackward && ay1 < by2 || !isBackward && ay2 > by1) {\n              // Only consider elements which are below/above curretly focused.\n              return true;\n            }\n\n            const xIntersectionWidth = Math.ceil(Math.min(ax2, bx2)) - Math.floor(Math.max(ax1, bx1));\n            const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));\n\n            if (xIntersectionWidth > 0 && minWidth >= xIntersectionWidth) {\n              // Element intersects with the focused element on X axis.\n              const intersection = xIntersectionWidth / minWidth;\n\n              if (intersection > lastIntersection) {\n                targetElement = el;\n                lastIntersection = intersection;\n              }\n            } else if (lastIntersection === 0) {\n              // If we didn't have intersection, try just the closest one.\n              const distance = getDistance(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2);\n\n              if (lastDistance === undefined || distance < lastDistance) {\n                lastDistance = distance;\n                targetElement = el;\n              }\n            } else if (lastIntersection > 0) {\n              // Element doesn't intersect, but we had intersection already, stop search.\n              return false;\n            }\n\n            return true;\n          }\n        });\n        next = targetElement;\n      }\n\n      if (next) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n        nativeFocus(next);\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = getWindow;\n    this._movers = {};\n    tabster.queueInit(this._init);\n  }\n\n  dispose() {\n    var _a;\n\n    const win = this._win();\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n\n    if (this._ignoredInputTimer) {\n      win.clearTimeout(this._ignoredInputTimer);\n      delete this._ignoredInputTimer;\n    }\n\n    win.removeEventListener(\"keydown\", this._onKeyDown, true);\n    Object.keys(this._movers).forEach(moverId => {\n      if (this._movers[moverId]) {\n        this._movers[moverId].dispose();\n\n        delete this._movers[moverId];\n      }\n    });\n  }\n\n  createMover(element, props, sys) {\n    if (process.env.NODE_ENV === 'development') ;\n\n    const newMover = new Mover(this._tabster, element, this._onMoverDispose, props, sys);\n    this._movers[newMover.id] = newMover;\n    return newMover;\n  }\n\n  async _isIgnoredInput(element, keyCode) {\n    var _a;\n\n    if (element.getAttribute(\"aria-expanded\") === \"true\") {\n      return true;\n    }\n\n    if (matchesSelector(element, _inputSelector)) {\n      let selectionStart = 0;\n      let selectionEnd = 0;\n      let textLength = 0;\n      let asyncRet;\n\n      if (element.tagName === \"INPUT\" || element.tagName === \"TEXTAREA\") {\n        const type = element.type;\n        const value = element.value;\n        textLength = (value || \"\").length;\n\n        if (type === \"email\" || type === \"number\") {\n          // For these types Chromium doesn't provide selectionStart and selectionEnd.\n          // Hence the ugly workaround to find if the caret position is changed with\n          // the keypress.\n          // TODO: Have a look at range, week, time, time, date, datetime-local.\n          if (textLength) {\n            const selection = (_a = element.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.getSelection();\n\n            if (selection) {\n              const initialLength = selection.toString().length;\n              const isBackward = keyCode === Keys.Left || keyCode === Keys.Up;\n              selection.modify(\"extend\", isBackward ? \"backward\" : \"forward\", \"character\");\n\n              if (initialLength !== selection.toString().length) {\n                // The caret is moved, so, we're not on the edge of the value.\n                // Restore original selection.\n                selection.modify(\"extend\", isBackward ? \"forward\" : \"backward\", \"character\");\n                return true;\n              } else {\n                textLength = 0;\n              }\n            }\n          }\n        } else {\n          const selStart = element.selectionStart;\n\n          if (selStart === null) {\n            // Do not ignore not text editable inputs like checkboxes and radios (but ignore hidden).\n            return type === \"hidden\";\n          }\n\n          selectionStart = selStart || 0;\n          selectionEnd = element.selectionEnd || 0;\n        }\n      } else if (element.contentEditable === \"true\") {\n        asyncRet = new (getPromise(this._win))(resolve => {\n          this._ignoredInputResolve = value => {\n            delete this._ignoredInputResolve;\n            resolve(value);\n          };\n\n          const win = this._win();\n\n          if (this._ignoredInputTimer) {\n            win.clearTimeout(this._ignoredInputTimer);\n          }\n\n          const {\n            anchorNode: prevAnchorNode,\n            focusNode: prevFocusNode,\n            anchorOffset: prevAnchorOffset,\n            focusOffset: prevFocusOffset\n          } = win.getSelection() || {}; // Get selection gives incorrect value if we call it syncronously onKeyDown.\n\n          this._ignoredInputTimer = win.setTimeout(() => {\n            var _a, _b, _c;\n\n            delete this._ignoredInputTimer;\n            const {\n              anchorNode,\n              focusNode,\n              anchorOffset,\n              focusOffset\n            } = win.getSelection() || {};\n\n            if (anchorNode !== prevAnchorNode || focusNode !== prevFocusNode || anchorOffset !== prevAnchorOffset || focusOffset !== prevFocusOffset) {\n              (_a = this._ignoredInputResolve) === null || _a === void 0 ? void 0 : _a.call(this, false);\n              return;\n            }\n\n            selectionStart = anchorOffset || 0;\n            selectionEnd = focusOffset || 0;\n            textLength = ((_b = element.textContent) === null || _b === void 0 ? void 0 : _b.length) || 0;\n\n            if (anchorNode && focusNode) {\n              if (element.contains(anchorNode) && element.contains(focusNode)) {\n                if (anchorNode !== element) {\n                  let anchorFound = false;\n\n                  const addOffsets = node => {\n                    if (node === anchorNode) {\n                      anchorFound = true;\n                    } else if (node === focusNode) {\n                      return true;\n                    }\n\n                    const nodeText = node.textContent;\n\n                    if (nodeText && !node.firstChild) {\n                      const len = nodeText.length;\n\n                      if (anchorFound) {\n                        if (focusNode !== anchorNode) {\n                          selectionEnd += len;\n                        }\n                      } else {\n                        selectionStart += len;\n                        selectionEnd += len;\n                      }\n                    }\n\n                    let stop = false;\n\n                    for (let e = node.firstChild; e && !stop; e = e.nextSibling) {\n                      stop = addOffsets(e);\n                    }\n\n                    return stop;\n                  };\n\n                  addOffsets(element);\n                }\n              }\n            }\n\n            (_c = this._ignoredInputResolve) === null || _c === void 0 ? void 0 : _c.call(this, true);\n          }, 0);\n        });\n      }\n\n      if (asyncRet && !(await asyncRet)) {\n        return true;\n      }\n\n      if (selectionStart !== selectionEnd) {\n        return true;\n      }\n\n      if (selectionStart > 0 && (keyCode === Keys.Left || keyCode === Keys.Up || keyCode === Keys.Home)) {\n        return true;\n      }\n\n      if (selectionStart < textLength && (keyCode === Keys.Right || keyCode === Keys.Down || keyCode === Keys.End)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nfunction observeMutations(doc, tabster, updateTabsterByAttribute, syncState) {\n  if (typeof MutationObserver === \"undefined\") {\n    return () => {\n      /* Noop */\n    };\n  }\n\n  const getWindow = tabster.getWindow;\n  let elementByUId;\n\n  const onMutation = mutations => {\n    var _a, _b, _c, _d, _e;\n\n    for (const mutation of mutations) {\n      const target = mutation.target;\n      const removed = mutation.removedNodes;\n      const added = mutation.addedNodes;\n\n      if (mutation.type === \"attributes\") {\n        if (mutation.attributeName === TabsterAttributeName) {\n          updateTabsterByAttribute(tabster, target);\n        }\n      } else {\n        for (let i = 0; i < removed.length; i++) {\n          updateTabsterElements(removed[i], true);\n          (_b = (_a = tabster._dummyObserver).domChanged) === null || _b === void 0 ? void 0 : _b.call(_a, target);\n        }\n\n        for (let i = 0; i < added.length; i++) {\n          updateTabsterElements(added[i]);\n          (_d = (_c = tabster._dummyObserver).domChanged) === null || _d === void 0 ? void 0 : _d.call(_c, target);\n        }\n      }\n    }\n\n    (_e = tabster.modalizer) === null || _e === void 0 ? void 0 : _e.hiddenUpdate();\n  };\n\n  function updateTabsterElements(node, removed) {\n    if (!elementByUId) {\n      elementByUId = getInstanceContext(getWindow).elementByUId;\n    }\n\n    processNode(node, removed);\n    const walker = createElementTreeWalker(doc, node, element => {\n      return processNode(element, removed);\n    });\n\n    if (walker) {\n      while (walker.nextNode()) {\n        /* Iterating for the sake of calling processNode() callback. */\n      }\n    }\n  }\n\n  function processNode(element, removed) {\n    var _a;\n\n    if (!element.getAttribute) {\n      // It might actually be a text node.\n      return NodeFilter.FILTER_SKIP;\n    }\n\n    const uid = element.__tabsterElementUID;\n\n    if (uid && elementByUId) {\n      if (removed) {\n        delete elementByUId[uid];\n      } else {\n        (_a = elementByUId[uid]) !== null && _a !== void 0 ? _a : elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n      }\n    }\n\n    if (getTabsterOnElement(tabster, element) || element.hasAttribute(TabsterAttributeName)) {\n      updateTabsterByAttribute(tabster, element, removed);\n    }\n\n    return NodeFilter.FILTER_SKIP;\n  }\n\n  const observer = new MutationObserver(onMutation);\n\n  if (syncState) {\n    updateTabsterElements(getWindow().document.body);\n  }\n\n  observer.observe(doc, {\n    childList: true,\n    subtree: true,\n    attributes: true,\n    attributeFilter: [TabsterAttributeName]\n  });\n  return () => {\n    observer.disconnect();\n  };\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst _conditionCheckTimeout = 100;\nclass ObservedElementAPI extends Subscribable {\n  constructor(tabster) {\n    super();\n    this._waiting = {};\n    this._lastRequestFocusId = 0;\n    this._observedById = {};\n    this._observedByName = {};\n    this._currentRequestTimestamp = 0;\n\n    this._onFocus = e => {\n      if (e) {\n        const current = this._currentRequest;\n\n        if (current) {\n          const delta = Date.now() - this._currentRequestTimestamp;\n\n          const settleTime = 300;\n\n          if (delta >= settleTime) {\n            // Giving some time for the focus to settle before\n            // automatically cancelling the current request on focus change.\n            delete this._currentRequest;\n            current.cancel();\n          }\n        }\n      }\n    };\n\n    this.onObservedElementUpdate = element => {\n      var _a;\n\n      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;\n      const uid = getElementUId(this._win, element);\n      let info = this._observedById[uid];\n\n      if (observed && documentContains(element.ownerDocument, element)) {\n        if (!info) {\n          info = this._observedById[uid] = {\n            element: new WeakHTMLElement(this._win, element)\n          };\n        }\n\n        observed.names.sort();\n        const observedNames = observed.names;\n        const prevNames = info.prevNames; // prevNames are already sorted\n\n        if (this._isObservedNamesUpdated(observedNames, prevNames)) {\n          if (prevNames) {\n            prevNames.forEach(prevName => {\n              const obn = this._observedByName[prevName];\n\n              if (obn && obn[uid]) {\n                if (Object.keys(obn).length > 1) {\n                  delete obn[uid];\n                } else {\n                  delete this._observedByName[prevName];\n                }\n              }\n            });\n          }\n\n          info.prevNames = observedNames;\n        }\n\n        observedNames.forEach(observedName => {\n          let obn = this._observedByName[observedName];\n\n          if (!obn) {\n            obn = this._observedByName[observedName] = {};\n          } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n          obn[uid] = info;\n\n          this._waitConditional(observedName);\n        });\n      } else if (info) {\n        const prevNames = info.prevNames;\n\n        if (prevNames) {\n          prevNames.forEach(prevName => {\n            const obn = this._observedByName[prevName];\n\n            if (obn && obn[uid]) {\n              if (Object.keys(obn).length > 1) {\n                delete obn[uid];\n              } else {\n                delete this._observedByName[prevName];\n              }\n            }\n          });\n        }\n\n        delete this._observedById[uid];\n      }\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    tabster.queueInit(() => {\n      this._tabster.focusedElement.subscribe(this._onFocus);\n    });\n  }\n\n  dispose() {\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    for (const key of Object.keys(this._waiting)) {\n      this._rejectWaiting(key);\n    }\n\n    this._observedById = {};\n    this._observedByName = {};\n  }\n\n  _rejectWaiting(key, shouldResolve) {\n    const w = this._waiting[key];\n\n    if (w) {\n      const win = this._win();\n\n      if (w.timer) {\n        win.clearTimeout(w.timer);\n      }\n\n      if (w.conditionTimer) {\n        win.clearTimeout(w.conditionTimer);\n      }\n\n      if (!shouldResolve && w.reject) {\n        w.reject();\n      } else if (shouldResolve && w.resolve) {\n        w.resolve(null);\n      }\n\n      delete this._waiting[key];\n    }\n  }\n\n  _isObservedNamesUpdated(cur, prev) {\n    if (!prev || cur.length !== prev.length) {\n      return true;\n    }\n\n    for (let i = 0; i < cur.length; ++i) {\n      if (cur[i] !== prev[i]) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\r\n   * Returns existing element by observed name\r\n   *\r\n   * @param observedName An observed name\r\n   * @param accessibility Optionally, return only if the element is accessible or focusable\r\n   * @returns HTMLElement | null\r\n   */\n\n\n  getElement(observedName, accessibility) {\n    const o = this._observedByName[observedName];\n\n    if (o) {\n      for (const uid of Object.keys(o)) {\n        let el = o[uid].element.get() || null;\n\n        if (el) {\n          if (accessibility === ObservedElementAccesibilities.Accessible && !this._tabster.focusable.isAccessible(el) || accessibility === ObservedElementAccesibilities.Focusable && !this._tabster.focusable.isFocusable(el, true)) {\n            el = null;\n          }\n        } else {\n          delete o[uid];\n          delete this._observedById[uid];\n        }\n\n        return el;\n      }\n    }\n\n    return null;\n  }\n  /**\r\n   * Waits for the element to appear in the DOM and returns it.\r\n   *\r\n   * @param observedName An observed name\r\n   * @param timeout Wait no longer than this timeout\r\n   * @param accessibility Optionally, wait for the element to also become accessible or focusable before returning it\r\n   * @returns Promise<HTMLElement | null>\r\n   */\n\n\n  waitElement(observedName, timeout, accessibility) {\n    const el = this.getElement(observedName, accessibility);\n\n    if (el) {\n      return {\n        result: getPromise(this._win).resolve(el),\n        cancel: () => {\n          /**/\n        }\n      };\n    }\n\n    let prefix;\n\n    if (accessibility === ObservedElementAccesibilities.Accessible) {\n      prefix = \"a\";\n    } else if (accessibility === ObservedElementAccesibilities.Focusable) {\n      prefix = \"f\";\n    } else {\n      prefix = \"_\";\n    }\n\n    const key = prefix + observedName;\n    let w = this._waiting[key];\n\n    if (w && w.request) {\n      return w.request;\n    }\n\n    w = this._waiting[key] = {\n      timer: this._win().setTimeout(() => {\n        if (w.conditionTimer) {\n          this._win().clearTimeout(w.conditionTimer);\n        }\n\n        delete this._waiting[key];\n\n        if (w.resolve) {\n          w.resolve(null);\n        }\n      }, timeout)\n    };\n    const promise = new (getPromise(this._win))((resolve, reject) => {\n      w.resolve = resolve;\n      w.reject = reject;\n    });\n    w.request = {\n      result: promise,\n      cancel: () => {\n        this._rejectWaiting(key, true);\n      }\n    };\n\n    if (accessibility && this.getElement(observedName)) {\n      // If the observed element is alread in DOM, but not accessible yet,\n      // we need to run the wait logic.\n      this._waitConditional(observedName);\n    }\n\n    return w.request;\n  }\n\n  requestFocus(observedName, timeout) {\n    const requestId = ++this._lastRequestFocusId;\n    const currentRequestFocus = this._currentRequest;\n\n    if (currentRequestFocus) {\n      currentRequestFocus.cancel();\n    }\n\n    const request = this.waitElement(observedName, timeout, ObservedElementAccesibilities.Focusable);\n    this._currentRequest = request;\n    this._currentRequestTimestamp = Date.now();\n    request.result.finally(() => {\n      if (this._currentRequest === request) {\n        delete this._currentRequest;\n      }\n    });\n    return {\n      result: request.result.then(element => this._lastRequestFocusId === requestId && element ? this._tabster.focusedElement.focus(element, true) : false),\n      cancel: () => {\n        request.cancel();\n      }\n    };\n  }\n\n  _waitConditional(observedName) {\n    const waitingElementKey = \"_\" + observedName;\n    const waitingAccessibleElementKey = \"a\" + observedName;\n    const waitingFocusableElementKey = \"f\" + observedName;\n    const waitingElement = this._waiting[waitingElementKey];\n    const waitingAccessibleElement = this._waiting[waitingAccessibleElementKey];\n    const waitingFocusableElement = this._waiting[waitingFocusableElementKey];\n\n    const win = this._win();\n\n    const resolve = (element, key, waiting, accessibility) => {\n      var _a;\n\n      const observed = (_a = getTabsterOnElement(this._tabster, element)) === null || _a === void 0 ? void 0 : _a.observed;\n\n      if (!observed || !observed.names.includes(observedName)) {\n        return;\n      }\n\n      if (waiting.timer) {\n        win.clearTimeout(waiting.timer);\n      }\n\n      delete this._waiting[key];\n\n      if (waiting.resolve) {\n        waiting.resolve(element);\n      }\n\n      this.trigger(element, {\n        names: [observedName],\n        details: observed.details,\n        accessibility\n      });\n    };\n\n    if (waitingElement) {\n      const element = this.getElement(observedName);\n\n      if (element && documentContains(element.ownerDocument, element)) {\n        resolve(element, waitingElementKey, waitingElement, ObservedElementAccesibilities.Any);\n      }\n    }\n\n    if (waitingAccessibleElement && !waitingAccessibleElement.conditionTimer) {\n      const resolveAccessible = () => {\n        const element = this.getElement(observedName);\n\n        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isAccessible(element)) {\n          resolve(element, waitingAccessibleElementKey, waitingAccessibleElement, ObservedElementAccesibilities.Accessible);\n        } else {\n          waitingAccessibleElement.conditionTimer = win.setTimeout(resolveAccessible, _conditionCheckTimeout);\n        }\n      };\n\n      resolveAccessible();\n    }\n\n    if (waitingFocusableElement && !waitingFocusableElement.conditionTimer) {\n      const resolveFocusable = () => {\n        const element = this.getElement(observedName);\n\n        if (element && documentContains(element.ownerDocument, element) && this._tabster.focusable.isFocusable(element, true)) {\n          resolve(element, waitingFocusableElementKey, waitingFocusableElement, ObservedElementAccesibilities.Focusable);\n        } else {\n          waitingFocusableElement.conditionTimer = win.setTimeout(resolveFocusable, _conditionCheckTimeout);\n        }\n      };\n\n      resolveFocusable();\n    }\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nconst defaultProps = {\n  areaClass: \"tabster-focus-outline-area\",\n  outlineClass: \"tabster-focus-outline\",\n  outlineColor: \"#ff4500\",\n  outlineWidth: 2,\n  zIndex: 2147483647\n};\nlet _props = defaultProps;\n\nclass OutlinePosition {\n  constructor(left, top, right, bottom) {\n    this.left = left;\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n  }\n\n  equalsTo(other) {\n    return this.left === other.left && this.top === other.top && this.right === other.right && this.bottom === other.bottom;\n  }\n\n  clone() {\n    return new OutlinePosition(this.left, this.top, this.right, this.bottom);\n  }\n\n}\n\nclass OutlineAPI {\n  constructor(tabster) {\n    this._isVisible = false;\n    this._allOutlineElements = [];\n\n    this._init = () => {\n      this._tabster.keyboardNavigation.subscribe(this._onKeyboardNavigationStateChanged);\n\n      this._tabster.focusedElement.subscribe(this._onFocus);\n\n      const win = this._win();\n\n      win.addEventListener(\"scroll\", this._onScroll, true); // Capture!\n\n      if (this._fullScreenEventName) {\n        win.document.addEventListener(this._fullScreenEventName, this._onFullScreenChanged);\n      }\n    };\n\n    this._onFullScreenChanged = e => {\n      if (!this._fullScreenElementName || !e.target) {\n        return;\n      }\n\n      const target = e.target.body || e.target;\n\n      const outlineElements = this._getDOM(target);\n\n      if (target.ownerDocument && outlineElements) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const fsElement = target.ownerDocument[this._fullScreenElementName];\n\n        if (fsElement) {\n          fsElement.appendChild(outlineElements.container);\n          this._fullScreenElement = fsElement;\n        } else {\n          target.ownerDocument.body.appendChild(outlineElements.container);\n          this._fullScreenElement = undefined;\n        }\n      }\n    };\n\n    this._onKeyboardNavigationStateChanged = () => {\n      this._onFocus(this._tabster.focusedElement.getFocusedElement());\n    };\n\n    this._onFocus = e => {\n      if (!this._updateElement(e) && this._isVisible) {\n        this._setVisibility(false);\n      }\n    };\n\n    this._onScroll = e => {\n      if (!this._outlinedElement || !OutlineAPI._isParentChild(e.target, this._outlinedElement)) {\n        return;\n      }\n\n      this._curPos = undefined;\n\n      this._setOutlinePosition();\n    };\n\n    this._tabster = tabster;\n    this._win = tabster.getWindow;\n    tabster.queueInit(this._init);\n\n    if (typeof document !== \"undefined\") {\n      if (\"onfullscreenchange\" in document) {\n        this._fullScreenEventName = \"fullscreenchange\";\n        this._fullScreenElementName = \"fullscreenElement\";\n      } else if (\"onwebkitfullscreenchange\" in document) {\n        this._fullScreenEventName = \"webkitfullscreenchange\";\n        this._fullScreenElementName = \"webkitFullscreenElement\";\n      } else if (\"onmozfullscreenchange\" in document) {\n        this._fullScreenEventName = \"mozfullscreenchange\";\n        this._fullScreenElementName = \"mozFullScreenElement\";\n      } else if (\"onmsfullscreenchange\" in document) {\n        this._fullScreenEventName = \"msfullscreenchange\";\n        this._fullScreenElementName = \"msFullscreenElement\";\n      }\n    }\n  }\n\n  setup(props) {\n    _props = { ..._props,\n      ...props\n    };\n\n    const win = this._win();\n\n    if (!win.__tabsterOutline) {\n      win.__tabsterOutline = {};\n    }\n\n    if (!win.__tabsterOutline.style) {\n      win.__tabsterOutline.style = appendStyles(win.document, _props);\n    }\n\n    if (!props || !props.areaClass) {\n      win.document.body.classList.add(defaultProps.areaClass);\n    } else {\n      win.document.body.classList.remove(defaultProps.areaClass);\n    }\n  }\n\n  dispose() {\n    const win = this._win();\n\n    if (this._updateTimer) {\n      win.clearTimeout(this._updateTimer);\n      this._updateTimer = undefined;\n    }\n\n    this._tabster.keyboardNavigation.unsubscribe(this._onKeyboardNavigationStateChanged);\n\n    this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n    win.removeEventListener(\"scroll\", this._onScroll, true);\n\n    if (this._fullScreenEventName) {\n      win.document.removeEventListener(this._fullScreenEventName, this._onFullScreenChanged);\n    }\n\n    this._allOutlineElements.forEach(outlineElements => this._removeDOM(outlineElements.container));\n\n    this._allOutlineElements = [];\n    delete this._outlinedElement;\n    delete this._curPos;\n    delete this._curOutlineElements;\n    delete this._fullScreenElement;\n  }\n\n  _shouldShowCustomOutline(element) {\n    const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n\n    if (tabsterOnElement && tabsterOnElement.outline && tabsterOnElement.outline.isIgnored) {\n      return false;\n    }\n\n    for (let i = element; i; i = i.parentElement) {\n      if (i.classList && i.classList.contains(_props.areaClass)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _updateElement(e) {\n    this._outlinedElement = undefined;\n\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n\n      this._updateTimer = undefined;\n    }\n\n    this._curPos = undefined;\n\n    if (!this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n      return false;\n    }\n\n    if (e) {\n      // TODO: It's hard (and not necessary) to come up with every possible\n      // condition when there should be no outline, it's better to add an\n      // API to customize the ignores.\n      if (e.tagName === \"INPUT\") {\n        const inputType = e.type;\n        const outlinedInputTypes = {\n          button: true,\n          checkbox: true,\n          file: true,\n          image: true,\n          radio: true,\n          range: true,\n          reset: true,\n          submit: true\n        };\n\n        if (!(inputType in outlinedInputTypes)) {\n          return false;\n        }\n      } else if (e.tagName === \"TEXTAREA\" || e.contentEditable === \"true\" || e.tagName === \"IFRAME\") {\n        return false;\n      }\n\n      if (!this._shouldShowCustomOutline(e)) {\n        return false;\n      }\n\n      if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n        this._outlinedElement = e;\n\n        this._updateOutline();\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  _updateOutline() {\n    this._setOutlinePosition();\n\n    if (this._updateTimer) {\n      this._win().clearTimeout(this._updateTimer);\n\n      this._updateTimer = undefined;\n    }\n\n    if (!this._outlinedElement) {\n      return;\n    }\n\n    this._updateTimer = this._win().setTimeout(() => {\n      this._updateTimer = undefined;\n\n      this._updateOutline();\n    }, 30);\n  }\n\n  _setVisibility(visible) {\n    this._isVisible = visible;\n\n    if (this._curOutlineElements) {\n      if (visible) {\n        this._curOutlineElements.container.classList.add(`${_props.outlineClass}_visible`);\n      } else {\n        this._curOutlineElements.container.classList.remove(`${_props.outlineClass}_visible`);\n\n        this._curPos = undefined;\n      }\n    }\n  }\n\n  _setOutlinePosition() {\n    if (!this._outlinedElement) {\n      return;\n    }\n\n    let boundingRect = getBoundingRect(this._win, this._outlinedElement);\n    const position = new OutlinePosition(boundingRect.left, boundingRect.top, boundingRect.right, boundingRect.bottom);\n\n    if (this._curPos && position.equalsTo(this._curPos)) {\n      return;\n    }\n\n    const outlineElements = this._getDOM(this._outlinedElement);\n\n    const win = this._outlinedElement.ownerDocument && this._outlinedElement.ownerDocument.defaultView;\n\n    if (!outlineElements || !win) {\n      return;\n    }\n\n    if (this._curOutlineElements !== outlineElements) {\n      this._setVisibility(false);\n\n      this._curOutlineElements = outlineElements;\n    }\n\n    this._curPos = position;\n    const p = position.clone();\n    let hasAbsolutePositionedParent = false;\n    let hasFixedPositionedParent = false;\n    const container = outlineElements.container;\n    const scrollingElement = container && container.ownerDocument && container.ownerDocument.scrollingElement;\n\n    if (!scrollingElement) {\n      return;\n    }\n\n    for (let parent = this._outlinedElement.parentElement; parent; parent = parent.parentElement) {\n      // The element might be partially visible within its scrollable parent,\n      // reduce the bounding rect if this is the case.\n      if (parent === this._fullScreenElement) {\n        break;\n      }\n\n      boundingRect = getBoundingRect(this._win, parent);\n      const win = parent.ownerDocument && parent.ownerDocument.defaultView;\n\n      if (!win) {\n        return;\n      }\n\n      const computedStyle = win.getComputedStyle(parent);\n      const position = computedStyle.position;\n\n      if (position === \"absolute\") {\n        hasAbsolutePositionedParent = true;\n      } else if (position === \"fixed\" || position === \"sticky\") {\n        hasFixedPositionedParent = true;\n      }\n\n      if (computedStyle.overflow === \"visible\") {\n        continue;\n      }\n\n      if (!hasAbsolutePositionedParent && !hasFixedPositionedParent || computedStyle.overflow === \"hidden\") {\n        if (boundingRect.left > p.left) {\n          p.left = boundingRect.left;\n        }\n\n        if (boundingRect.top > p.top) {\n          p.top = boundingRect.top;\n        }\n\n        if (boundingRect.right < p.right) {\n          p.right = boundingRect.right;\n        }\n\n        if (boundingRect.bottom < p.bottom) {\n          p.bottom = boundingRect.bottom;\n        }\n      }\n    }\n\n    const allRect = getBoundingRect(this._win, scrollingElement);\n    const allWidth = allRect.left + allRect.right;\n    const allHeight = allRect.top + allRect.bottom;\n    const ow = _props.outlineWidth;\n    p.left = p.left > ow ? p.left - ow : 0;\n    p.top = p.top > ow ? p.top - ow : 0;\n    p.right = p.right < allWidth - ow ? p.right + ow : allWidth;\n    p.bottom = p.bottom < allHeight - ow ? p.bottom + ow : allHeight;\n    const width = p.right - p.left;\n    const height = p.bottom - p.top;\n\n    if (width > ow * 2 && height > ow * 2) {\n      const leftBorderNode = outlineElements.left;\n      const topBorderNode = outlineElements.top;\n      const rightBorderNode = outlineElements.right;\n      const bottomBorderNode = outlineElements.bottom;\n      const sx = this._fullScreenElement || hasFixedPositionedParent ? 0 : win.pageXOffset;\n      const sy = this._fullScreenElement || hasFixedPositionedParent ? 0 : win.pageYOffset;\n      container.style.position = hasFixedPositionedParent ? \"fixed\" : \"absolute\";\n      container.style.background = _props.outlineColor;\n      leftBorderNode.style.width = rightBorderNode.style.width = topBorderNode.style.height = bottomBorderNode.style.height = _props.outlineWidth + \"px\";\n      leftBorderNode.style.left = topBorderNode.style.left = bottomBorderNode.style.left = p.left + sx + \"px\";\n      rightBorderNode.style.left = p.left + sx + width - ow + \"px\";\n      leftBorderNode.style.top = rightBorderNode.style.top = topBorderNode.style.top = p.top + sy + \"px\";\n      bottomBorderNode.style.top = p.top + sy + height - ow + \"px\";\n      leftBorderNode.style.height = rightBorderNode.style.height = height + \"px\";\n      topBorderNode.style.width = bottomBorderNode.style.width = width + \"px\";\n\n      this._setVisibility(true);\n    } else {\n      this._setVisibility(false);\n    }\n  }\n\n  _getDOM(contextElement) {\n    const doc = contextElement.ownerDocument;\n    const win = doc && doc.defaultView;\n\n    if (!doc || !win || !win.__tabsterOutline) {\n      return undefined;\n    }\n\n    if (!win.__tabsterOutline.style) {\n      win.__tabsterOutline.style = appendStyles(doc, _props);\n    }\n\n    if (!win.__tabsterOutline.elements) {\n      const outlineElements = {\n        container: doc.createElement(\"div\"),\n        left: doc.createElement(\"div\"),\n        top: doc.createElement(\"div\"),\n        right: doc.createElement(\"div\"),\n        bottom: doc.createElement(\"div\")\n      };\n      outlineElements.container.className = _props.outlineClass;\n      outlineElements.left.className = `${_props.outlineClass}__left`;\n      outlineElements.top.className = `${_props.outlineClass}__top`;\n      outlineElements.right.className = `${_props.outlineClass}__right`;\n      outlineElements.bottom.className = `${_props.outlineClass}__bottom`;\n      outlineElements.container.appendChild(outlineElements.left);\n      outlineElements.container.appendChild(outlineElements.top);\n      outlineElements.container.appendChild(outlineElements.right);\n      outlineElements.container.appendChild(outlineElements.bottom);\n      doc.body.appendChild(outlineElements.container);\n      win.__tabsterOutline.elements = outlineElements; // TODO: Make a garbage collector to remove the references\n      // to the outlines which are nowhere in the DOM anymore.\n\n      this._allOutlineElements.push(outlineElements);\n    }\n\n    return win.__tabsterOutline.elements;\n  }\n\n  _removeDOM(contextElement) {\n    const win = contextElement.ownerDocument && contextElement.ownerDocument.defaultView;\n    const outline = win && win.__tabsterOutline;\n\n    if (!outline) {\n      return;\n    }\n\n    if (outline.style && outline.style.parentNode) {\n      outline.style.parentNode.removeChild(outline.style);\n      delete outline.style;\n    }\n\n    const outlineElements = outline && outline.elements;\n\n    if (outlineElements) {\n      if (outlineElements.container.parentNode) {\n        outlineElements.container.parentNode.removeChild(outlineElements.container);\n      }\n\n      delete outline.elements;\n    }\n  }\n\n  static _isParentChild(parent, child) {\n    return child === parent || // tslint:disable-next-line:no-bitwise\n    !!(parent.compareDocumentPosition(child) & document.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n\n}\n\nfunction appendStyles(document, props) {\n  const style = document.createElement(\"style\");\n  style.type = \"text/css\";\n  style.appendChild(document.createTextNode(getOutlineStyles(props)));\n  document.head.appendChild(style);\n  return style;\n}\n\nfunction getOutlineStyles(props) {\n  return `\n.${props.areaClass} *, .${props.areaClass} *:focus {\noutline: none !important;\n}\n\n.${props.outlineClass} {\ndisplay: none;\nposition: absolute;\nwidth: 0;\nheight: 0;\nleft: 0;\ntop: 0;\nz-index: ${props.zIndex};\n}\n\n.${props.outlineClass}.${props.outlineClass}_visible {\ndisplay: block;\n}\n\n.${props.outlineClass}__left,\n.${props.outlineClass}__top,\n.${props.outlineClass}__right,\n.${props.outlineClass}__bottom {\nposition: absolute;\nbackground: inherit;\n}`;\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Allows default or user focus behaviour on the DOM subtree\r\n * i.e. Tabster will not control focus events within an uncontrolled area\r\n */\nclass UncontrolledAPI {\n  constructor() {\n    /**/\n  }\n\n}\n\n/*!\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nclass Tabster {\n  constructor(tabster) {\n    this.keyboardNavigation = tabster.keyboardNavigation;\n    this.focusedElement = tabster.focusedElement;\n    this.focusable = tabster.focusable;\n    this.root = tabster.root;\n    this.uncontrolled = tabster.uncontrolled;\n    this.core = tabster;\n  }\n\n}\n/**\r\n * Extends Window to include an internal Tabster instance.\r\n */\n\n\nclass TabsterCore {\n  constructor(win, props) {\n    var _a;\n\n    this._forgetMemorizedElements = [];\n    this._wrappers = new Set();\n    this._initQueue = [];\n    this._version = \"4.3.0\";\n    this._noop = false;\n\n    this.getWindow = () => {\n      if (!this._win) {\n        throw new Error(\"Using disposed Tabster.\");\n      }\n\n      return this._win;\n    };\n\n    this._storage = createWeakMap(win);\n    this._win = win;\n    const getWindow = this.getWindow;\n    this.keyboardNavigation = new KeyboardNavigationState(getWindow);\n    this.focusedElement = new FocusedElementState(this, getWindow);\n    this.focusable = new FocusableAPI(this);\n    this.root = new RootAPI(this, props === null || props === void 0 ? void 0 : props.autoRoot);\n    this.uncontrolled = new UncontrolledAPI();\n    this.controlTab = (_a = props === null || props === void 0 ? void 0 : props.controlTab) !== null && _a !== void 0 ? _a : true;\n    this.rootDummyInputs = !!(props === null || props === void 0 ? void 0 : props.rootDummyInputs);\n    this._dummyObserver = new DummyInputObserver(getWindow);\n    this.internal = {\n      stopObserver: () => {\n        if (this._unobserve) {\n          this._unobserve();\n\n          delete this._unobserve;\n        }\n      },\n      resumeObserver: syncState => {\n        if (!this._unobserve) {\n          const doc = getWindow().document;\n          this._unobserve = observeMutations(doc, this, updateTabsterByAttribute, syncState);\n        }\n      }\n    };\n    startFakeWeakRefsCleanup(getWindow); // Gives a tick to the host app to initialize other tabster\n    // APIs before tabster starts observing attributes.\n\n    this.queueInit(() => {\n      this.internal.resumeObserver(true);\n    });\n  }\n\n  createTabster(noRefCount) {\n    const wrapper = new Tabster(this);\n\n    if (!noRefCount) {\n      this._wrappers.add(wrapper);\n    }\n\n    return wrapper;\n  }\n\n  disposeTabster(wrapper, allInstances) {\n    if (allInstances) {\n      this._wrappers.clear();\n    } else {\n      this._wrappers.delete(wrapper);\n    }\n\n    if (this._wrappers.size === 0) {\n      this.dispose();\n    }\n  }\n\n  dispose() {\n    var _a, _b, _c, _d, _e, _f, _g;\n\n    this.internal.stopObserver();\n    const win = this._win;\n    win === null || win === void 0 ? void 0 : win.clearTimeout(this._initTimer);\n    delete this._initTimer;\n    this._initQueue = [];\n    this._forgetMemorizedElements = [];\n\n    if (win && this._forgetMemorizedTimer) {\n      win.clearTimeout(this._forgetMemorizedTimer);\n      delete this._forgetMemorizedTimer;\n    }\n\n    (_a = this.outline) === null || _a === void 0 ? void 0 : _a.dispose();\n    (_b = this.crossOrigin) === null || _b === void 0 ? void 0 : _b.dispose();\n    (_c = this.deloser) === null || _c === void 0 ? void 0 : _c.dispose();\n    (_d = this.groupper) === null || _d === void 0 ? void 0 : _d.dispose();\n    (_e = this.mover) === null || _e === void 0 ? void 0 : _e.dispose();\n    (_f = this.modalizer) === null || _f === void 0 ? void 0 : _f.dispose();\n    (_g = this.observedElement) === null || _g === void 0 ? void 0 : _g.dispose();\n    this.keyboardNavigation.dispose();\n    this.focusable.dispose();\n    this.focusedElement.dispose();\n    this.root.dispose();\n\n    this._dummyObserver.dispose();\n\n    stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);\n    clearElementCache(this.getWindow);\n    this._storage = new WeakMap();\n\n    this._wrappers.clear();\n\n    if (win) {\n      disposeInstanceContext(win);\n      delete win.__tabsterInstance;\n      delete this._win;\n    }\n  }\n\n  storageEntry(element, addremove) {\n    const storage = this._storage;\n    let entry = storage.get(element);\n\n    if (entry) {\n      if (addremove === false && Object.keys(entry).length === 0) {\n        storage.delete(element);\n      }\n    } else if (addremove === true) {\n      entry = {};\n      storage.set(element, entry);\n    }\n\n    return entry;\n  }\n\n  forceCleanup() {\n    if (!this._win) {\n      return;\n    }\n\n    this._forgetMemorizedElements.push(this._win.document.body);\n\n    if (this._forgetMemorizedTimer) {\n      return;\n    }\n\n    this._forgetMemorizedTimer = this._win.setTimeout(() => {\n      delete this._forgetMemorizedTimer;\n\n      for (let el = this._forgetMemorizedElements.shift(); el; el = this._forgetMemorizedElements.shift()) {\n        clearElementCache(this.getWindow, el);\n        FocusedElementState.forgetMemorized(this.focusedElement, el);\n      }\n    }, 0);\n    cleanupFakeWeakRefs(this.getWindow, true);\n  }\n\n  queueInit(callback) {\n    var _a;\n\n    if (!this._win) {\n      return;\n    }\n\n    this._initQueue.push(callback);\n\n    if (!this._initTimer) {\n      this._initTimer = (_a = this._win) === null || _a === void 0 ? void 0 : _a.setTimeout(() => {\n        delete this._initTimer;\n        this.drainInitQueue();\n      }, 0);\n    }\n  }\n\n  drainInitQueue() {\n    if (!this._win) {\n      return;\n    }\n\n    const queue = this._initQueue; // Resetting the queue before calling the callbacks to avoid recursion.\n\n    this._initQueue = [];\n    queue.forEach(callback => callback());\n  }\n\n}\n\nfunction forceCleanup(tabster) {\n  // The only legit case for calling this method is when you've completely removed\n  // the application DOM and not going to add the new one for a while.\n  const tabsterCore = tabster.core;\n  tabsterCore.forceCleanup();\n}\n/**\r\n * Creates an instance of Tabster, returns the current window instance if it already exists.\r\n */\n\nfunction createTabster(win, props) {\n  let tabster = getCurrentTabster(win);\n\n  if (tabster) {\n    return tabster.createTabster();\n  }\n\n  tabster = new TabsterCore(win, props);\n  win.__tabsterInstance = tabster;\n  return tabster.createTabster();\n}\n/**\r\n * Returns an instance of Tabster if it was created before or null.\r\n */\n\nfunction getTabster(win) {\n  const tabster = getCurrentTabster(win);\n  return tabster ? tabster.createTabster(true) : null;\n}\n/**\r\n * Creates a new groupper instance or returns an existing one\r\n * @param tabster Tabster instance\r\n */\n\nfunction getGroupper(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.groupper) {\n    tabsterCore.groupper = new GroupperAPI(tabsterCore, tabsterCore.getWindow);\n  }\n\n  return tabsterCore.groupper;\n}\n/**\r\n * Creates a new mover instance or returns an existing one\r\n * @param tabster Tabster instance\r\n */\n\nfunction getMover(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.mover) {\n    tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);\n  }\n\n  return tabsterCore.mover;\n}\nfunction getOutline(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.outline) {\n    tabsterCore.outline = new OutlineAPI(tabsterCore);\n  }\n\n  return tabsterCore.outline;\n}\n/**\r\n * Creates a new new deloser instance or returns an existing one\r\n * @param tabster Tabster instance\r\n * @param props Deloser props\r\n */\n\nfunction getDeloser(tabster, props) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.deloser) {\n    tabsterCore.deloser = new DeloserAPI(tabsterCore, props);\n  }\n\n  return tabsterCore.deloser;\n}\n/**\r\n * Creates a new modalizer instance or returns an existing one\r\n * @param tabster Tabster instance\r\n */\n\nfunction getModalizer(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.modalizer) {\n    tabsterCore.modalizer = new ModalizerAPI(tabsterCore);\n  }\n\n  return tabsterCore.modalizer;\n}\nfunction getObservedElement(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.observedElement) {\n    tabsterCore.observedElement = new ObservedElementAPI(tabsterCore);\n  }\n\n  return tabsterCore.observedElement;\n}\nfunction getCrossOrigin(tabster) {\n  const tabsterCore = tabster.core;\n\n  if (!tabsterCore.crossOrigin) {\n    getDeloser(tabster);\n    getModalizer(tabster);\n    getMover(tabster);\n    getGroupper(tabster);\n    getOutline(tabster);\n    getObservedElement(tabster);\n    tabsterCore.crossOrigin = new CrossOriginAPI(tabsterCore);\n  }\n\n  return tabsterCore.crossOrigin;\n}\nfunction getInternal(tabster) {\n  const tabsterCore = tabster.core;\n  return tabsterCore.internal;\n}\nfunction disposeTabster(tabster, allInstances) {\n  tabster.core.disposeTabster(tabster, allInstances);\n}\n/**\r\n * Returns an instance of Tabster if it already exists on the window .\r\n * @param win window instance that could contain an Tabster instance.\r\n */\n\nfunction getCurrentTabster(win) {\n  return win.__tabsterInstance;\n}\n/**\r\n * Allows to make Tabster non operational. Intended for performance debugging (and other\r\n * kinds of debugging), you can switch Tabster off without changing the application code\r\n * that consumes it.\r\n * @param tabster a reference created by createTabster().\r\n * @param noop true if you want to make Tabster noop, false if you want to turn it back.\r\n */\n\nfunction makeNoOp(tabster, noop) {\n  const core = tabster.core;\n\n  if (core._noop !== noop) {\n    core._noop = noop;\n\n    const processNode = element => {\n      if (!element.getAttribute) {\n        return NodeFilter.FILTER_SKIP;\n      }\n\n      if (getTabsterOnElement(core, element) || element.hasAttribute(TabsterAttributeName)) {\n        updateTabsterByAttribute(core, element);\n      }\n\n      return NodeFilter.FILTER_SKIP;\n    };\n\n    const doc = core.getWindow().document;\n    const body = doc.body;\n    processNode(body);\n    const walker = createElementTreeWalker(doc, body, processNode);\n\n    if (walker) {\n      while (walker.nextNode()) {\n        /* Iterating for the sake of calling processNode() callback. */\n      }\n    }\n  }\n}\nfunction isNoOp(tabster) {\n  return tabster._noop;\n}\n\nexport { Types, createTabster, disposeTabster, forceCleanup, getCrossOrigin, getDeloser, getGroupper, getInternal, getModalizer, getMover, getObservedElement, getOutline, getTabster, getTabsterAttribute, isNoOp, makeNoOp, mergeTabsterProps, setTabsterAttribute };\n//# sourceMappingURL=tabster.esm.js.map\n"],"names":["TabsterAttributeName","TabsterDummyInputAttributeName","DeloserEventName","ModalizerActiveEventName","ModalizerInactiveEventName","ModalizerFocusInEventName","ModalizerFocusOutEventName","ModalizerBeforeFocusOutEventName","MoverEventName","FocusInEventName","FocusOutEventName","ObservedElementAccesibilities","RestoreFocusOrders","Visibilities","MoverDirections","GroupperTabbabilities","SysDummyInputsPositions","Types","getTabsterOnElement","tabster","element","_a","updateTabsterByAttribute","dispose","_b","newAttrValue","entry","newAttr","newValue","tabsterOnElement","oldTabsterProps","newTabsterProps","key","root","part","sys","createEventTarget","getWindow","global","error","_isBrokenIE11","_DOMRect","x","y","width","height","_uidCounter","_updateDummyInputsTimeout","getInstanceContext","win","ctx","disposeInstanceContext","createWeakMap","FakeWeakRef","target","fwr","forceRemove","documentContains","WeakHTMLElement","data","context","ref","cleanupFakeWeakRefs","e","startFakeWeakRefsCleanup","getWeakRef","stopFakeWeakRefsCleanupAndClearStorage","createElementTreeWalker","doc","acceptNode","filter","getBoundingRect","cacheId","cached","scrollingElement","left","top","right","bottom","r","rect","cId","isElementVerticallyVisibleInContainer","tolerance","container","getScrollableContainer","containerRect","elementRect","intersectionTolerance","topIntersection","bottomIntersection","totalIntersection","scrollIntoView","alignToTop","el","makeFocusIgnored","shouldIgnoreFocus","getUId","wnd","rnd","srnd","getElementUId","uid","clearElementCache","parent","wel","matchesSelector","selector","matches","getPromise","_lastTabsterPartId","TabsterPart","props","DummyInput","isOutside","input","relatedTarget","DummyInputManager","style","isIn","current","previous","DummyInputManagerPriorities","priority","outsideByDefault","callForDefaultAction","DummyInputManagerCore","backwards","onFocusIn","onFocusOut","tabbable","ret","moveOutside","isBackward","insertBefore","beforeBefore","nativeFocus","DummyInputObserver","dummy","callback","dummyParent","dummyInputElements","compute","scrollTopLeftCache","setTopLeftCallbacks","setTopLeft","manager","dummyInput","first","last","firstInput","lastInput","toFocus","w","wrapper","tabIndex","_c","dif","dil","elementParent","nextSibling","firstElementChild","from","transformElements","newTransformElements","scrollTop","scrollLeft","scrollTopLeft","transform","instance","forcedDummyPosition","tagName","dummyElement","force","_d","a","b","getLastChild","lastChild","i","getAdjacentElement","prev","cur","adjacent","triggerEvent","name","details","event","augmentAttribute","value","origVal","origValue","getTabsterAttribute","plain","attr","mergeTabsterProps","newProps","setTabsterAttribute","update","RootDummyManager","setFocused","Root","onDispose","hasFocused","fromAdjacent","RootAPI","dummyManager","autoRoot","body","rootId","newRoot","roots","id","options","checkRtl","modalizer","groupper","mover","isExcludedFromMover","isGroupperFirst","modalizerInGroupper","isRtl","uncontrolled","curElement","ignoreKeydown","dir","curModalizer","curGroupper","curMover","rootAPI","removed","_containerHistoryLength","DeloserItemBase","DeloserItem","deloser","available","DeloserHistoryByRootBase","rootUId","c","d","DeloserHistoryByRoot","item","skip","resetQueue","DeloserHistory","DeloserAPI","historyByRoot","createInstance","hbr","h","buildElementSelector","withClass","withIndex","escapeRegExp","escapeReplaceValue","cls","index","buildSelector","isBody","Deloser","preserveExisting","we","active","restoreFocusOrder","rootElement","availableInHistory","availableDefault","availableFirst","els","autoDeloser","restore","curDeloser","restoreFocus","lastFocused","deloserAPI","autoDeloserProps","Subscribable","callbacks","val","_focusableSelector","FocusableAPI","includeProgrammaticallyFocusable","noVisibleCheck","noAccessibleCheck","attrVal","found","findAll","currentElement","useActiveModalizer","ignoreUncontrolled","ignoreAccessibility","modalizerId","onUncontrolled","onElement","elements","acceptCondition","acceptElementState","walker","node","prepareForNextElement","shouldContinueIfNotFound","foundElement","nextUncontrolled","state","_e","lastToIgnore","result","fromCtx","fromMover","groupperElement","fromMoverElement","moverElement","Keys","FocusedElementState","KEYBORG_FOCUSIN","activeElement","_f","controlTab","next","nextElement","moveFrom","preventDefault","lastMoverOrGroupper","outOfDOMOrder","nextElementCtx","lastCtx","noFocusedProgrammaticallyFlag","isFirst","tabsterFocusable","prevTabIndex","prevAriaHidden","isFocusedProgrammatically","lastResetElement","nextVal","actualContainer","isTabbingTimer","callFindNext","what","lastMoverOrGroupperElement","parentElement","parentCtx","parentMoverOrGroupper","newCurrent","adjacentElement","adjacentCtx","adjacentFrom","KeyboardNavigationState","isNavigatingWithKeyboard","createKeyborg","disposeKeyborg","_wasFocusedCounter","_ariaHidden","ModalizerDummyManager","dummyContainer","Modalizer","activeElements","isActive","noIncrement","eventName","allElements","defaultPrevented","ModalizerAPI","userId","activeId","focusedSince","m","f","focusedElement","augmentedMap","elementFromModalizer","noFocusFirst","noFocusDefault","modalizerRoot","modalizerUserId","currentModalizer","parts","visibleElements","hiddenElements","alwaysAccessibleElements","mParts","isAlwaysAccessible","allVisibleElements","newAugmented","newAugmentedMap","toggle","hide","isAugmented","walk","containsModalizer","outsideElement","ownerDocument","_inputSelector","MoverDummyManager","getMemorized","memorized","_moverUpdateAdd","_moverUpdateAttr","_moverUpdateRemove","Mover","entries","newVisibility","fullyVisible","changed","weak","currentIsDummy","focusable","memorizeCurrent","visibilityAware","hasDefault","visibility","updateQueue","observer","mutations","mutation","added","requestUpdate","setElement","remove","updateElement","isFocusable","addNewElements","getMoverGroupper","groupperFirstFocusable","removeWalk","type","toe","getDistance","ax1","ay1","ax2","ay2","bx1","by1","bx2","by2","xDistance","yDistance","MoverAPI","keyCode","focused","moverProps","direction","isBoth","isVertical","isHorizontal","isGrid","isCyclic","focusedElementRect","focusedElementX1","focusedElementX2","nextElementX1","firstColumnX1","lastColumnX1","targetElement","lastDistance","lastIntersection","xIntersectionWidth","minWidth","intersection","distance","moverId","newMover","selectionStart","selectionEnd","textLength","asyncRet","selection","initialLength","selStart","resolve","prevAnchorNode","prevFocusNode","prevAnchorOffset","prevFocusOffset","anchorNode","focusNode","anchorOffset","focusOffset","anchorFound","addOffsets","nodeText","len","stop","observeMutations","syncState","elementByUId","onMutation","updateTabsterElements","processNode","UncontrolledAPI","Tabster","TabsterCore","noRefCount","allInstances","_g","addremove","storage","queue","createTabster","getCurrentTabster","getMover","tabsterCore","getDeloser","getModalizer","disposeTabster"],"mappings":"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"}
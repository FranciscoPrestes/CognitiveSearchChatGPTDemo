{"version":3,"file":"react-router-dom-e5f3a2d5.js","sources":["../../../frontend/node_modules/react-router-dom/dist/index.js"],"sourcesContent":["/**\r\n * React Router DOM v6.8.1\r\n *\r\n * Copyright (c) Remix Software Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE.md file in the root directory of this source tree.\r\n *\r\n * @license MIT\r\n */\r\nimport * as React from 'react';\r\nimport { UNSAFE_enhanceManualRouteObjects, Router, useHref, useResolvedPath, useLocation, UNSAFE_DataRouterStateContext, UNSAFE_NavigationContext, useNavigate, createPath, UNSAFE_RouteContext, useMatches, useNavigation, unstable_useBlocker, UNSAFE_DataRouterContext } from 'react-router';\r\nexport { AbortedDeferredError, Await, MemoryRouter, Navigate, NavigationType, Outlet, Route, Router, RouterProvider, Routes, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, UNSAFE_LocationContext, UNSAFE_NavigationContext, UNSAFE_RouteContext, UNSAFE_enhanceManualRouteObjects, createMemoryRouter, createPath, createRoutesFromChildren, createRoutesFromElements, defer, generatePath, isRouteErrorResponse, json, matchPath, matchRoutes, parsePath, redirect, renderMatches, resolvePath, unstable_useBlocker, useActionData, useAsyncError, useAsyncValue, useHref, useInRouterContext, useLoaderData, useLocation, useMatch, useMatches, useNavigate, useNavigation, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRevalidator, useRouteError, useRouteLoaderData, useRoutes } from 'react-router';\r\nimport { createRouter, createBrowserHistory, createHashHistory, ErrorResponse, invariant, joinPaths } from '@remix-run/router';\r\n\r\nfunction _extends() {\r\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      var source = arguments[i];\r\n\r\n      for (var key in source) {\r\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n          target[key] = source[key];\r\n        }\r\n      }\r\n    }\r\n\r\n    return target;\r\n  };\r\n  return _extends.apply(this, arguments);\r\n}\r\n\r\nfunction _objectWithoutPropertiesLoose(source, excluded) {\r\n  if (source == null) return {};\r\n  var target = {};\r\n  var sourceKeys = Object.keys(source);\r\n  var key, i;\r\n\r\n  for (i = 0; i < sourceKeys.length; i++) {\r\n    key = sourceKeys[i];\r\n    if (excluded.indexOf(key) >= 0) continue;\r\n    target[key] = source[key];\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\nconst defaultMethod = \"get\";\r\nconst defaultEncType = \"application/x-www-form-urlencoded\";\r\nfunction isHtmlElement(object) {\r\n  return object != null && typeof object.tagName === \"string\";\r\n}\r\nfunction isButtonElement(object) {\r\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\r\n}\r\nfunction isFormElement(object) {\r\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\r\n}\r\nfunction isInputElement(object) {\r\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\r\n}\r\n\r\nfunction isModifiedEvent(event) {\r\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\r\n}\r\n\r\nfunction shouldProcessLinkClick(event, target) {\r\n  return event.button === 0 && ( // Ignore everything but left clicks\r\n  !target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\r\n  !isModifiedEvent(event) // Ignore clicks with modifier keys\r\n  ;\r\n}\r\n/**\r\n * Creates a URLSearchParams object using the given initializer.\r\n *\r\n * This is identical to `new URLSearchParams(init)` except it also\r\n * supports arrays as values in the object form of the initializer\r\n * instead of just strings. This is convenient when you need multiple\r\n * values for a given key, but don't want to use an array initializer.\r\n *\r\n * For example, instead of:\r\n *\r\n *   let searchParams = new URLSearchParams([\r\n *     ['sort', 'name'],\r\n *     ['sort', 'price']\r\n *   ]);\r\n *\r\n * you can do:\r\n *\r\n *   let searchParams = createSearchParams({\r\n *     sort: ['name', 'price']\r\n *   });\r\n */\r\n\r\nfunction createSearchParams(init) {\r\n  if (init === void 0) {\r\n    init = \"\";\r\n  }\r\n\r\n  return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {\r\n    let value = init[key];\r\n    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);\r\n  }, []));\r\n}\r\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\r\n  let searchParams = createSearchParams(locationSearch);\r\n\r\n  if (defaultSearchParams) {\r\n    for (let key of defaultSearchParams.keys()) {\r\n      if (!searchParams.has(key)) {\r\n        defaultSearchParams.getAll(key).forEach(value => {\r\n          searchParams.append(key, value);\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  return searchParams;\r\n}\r\nfunction getFormSubmissionInfo(target, defaultAction, options) {\r\n  let method;\r\n  let action;\r\n  let encType;\r\n  let formData;\r\n\r\n  if (isFormElement(target)) {\r\n    let submissionTrigger = options.submissionTrigger;\r\n    method = options.method || target.getAttribute(\"method\") || defaultMethod;\r\n    action = options.action || target.getAttribute(\"action\") || defaultAction;\r\n    encType = options.encType || target.getAttribute(\"enctype\") || defaultEncType;\r\n    formData = new FormData(target);\r\n\r\n    if (submissionTrigger && submissionTrigger.name) {\r\n      formData.append(submissionTrigger.name, submissionTrigger.value);\r\n    }\r\n  } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\r\n    let form = target.form;\r\n\r\n    if (form == null) {\r\n      throw new Error(\"Cannot submit a <button> or <input type=\\\"submit\\\"> without a <form>\");\r\n    } // <button>/<input type=\"submit\"> may override attributes of <form>\r\n\r\n\r\n    method = options.method || target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\r\n    action = options.action || target.getAttribute(\"formaction\") || form.getAttribute(\"action\") || defaultAction;\r\n    encType = options.encType || target.getAttribute(\"formenctype\") || form.getAttribute(\"enctype\") || defaultEncType;\r\n    formData = new FormData(form); // Include name + value from a <button>, appending in case the button name\r\n    // matches an existing input name\r\n\r\n    if (target.name) {\r\n      formData.append(target.name, target.value);\r\n    }\r\n  } else if (isHtmlElement(target)) {\r\n    throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + \"<input type=\\\"submit|image\\\">\");\r\n  } else {\r\n    method = options.method || defaultMethod;\r\n    action = options.action || defaultAction;\r\n    encType = options.encType || defaultEncType;\r\n\r\n    if (target instanceof FormData) {\r\n      formData = target;\r\n    } else {\r\n      formData = new FormData();\r\n\r\n      if (target instanceof URLSearchParams) {\r\n        for (let [name, value] of target) {\r\n          formData.append(name, value);\r\n        }\r\n      } else if (target != null) {\r\n        for (let name of Object.keys(target)) {\r\n          formData.append(name, target[name]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  let {\r\n    protocol,\r\n    host\r\n  } = window.location;\r\n  let url = new URL(action, protocol + \"//\" + host);\r\n  return {\r\n    url,\r\n    method: method.toLowerCase(),\r\n    encType,\r\n    formData\r\n  };\r\n}\r\n\r\nconst _excluded = [\"onClick\", \"relative\", \"reloadDocument\", \"replace\", \"state\", \"target\", \"to\", \"preventScrollReset\"],\r\n      _excluded2 = [\"aria-current\", \"caseSensitive\", \"className\", \"end\", \"style\", \"to\", \"children\"],\r\n      _excluded3 = [\"reloadDocument\", \"replace\", \"method\", \"action\", \"onSubmit\", \"fetcherKey\", \"routeId\", \"relative\", \"preventScrollReset\"];\r\n//#region Routers\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction createBrowserRouter(routes, opts) {\r\n  return createRouter({\r\n    basename: opts == null ? void 0 : opts.basename,\r\n    history: createBrowserHistory({\r\n      window: opts == null ? void 0 : opts.window\r\n    }),\r\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\r\n    routes: UNSAFE_enhanceManualRouteObjects(routes)\r\n  }).initialize();\r\n}\r\nfunction createHashRouter(routes, opts) {\r\n  return createRouter({\r\n    basename: opts == null ? void 0 : opts.basename,\r\n    history: createHashHistory({\r\n      window: opts == null ? void 0 : opts.window\r\n    }),\r\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\r\n    routes: UNSAFE_enhanceManualRouteObjects(routes)\r\n  }).initialize();\r\n}\r\n\r\nfunction parseHydrationData() {\r\n  var _window;\r\n\r\n  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\r\n\r\n  if (state && state.errors) {\r\n    state = _extends({}, state, {\r\n      errors: deserializeErrors(state.errors)\r\n    });\r\n  }\r\n\r\n  return state;\r\n}\r\n\r\nfunction deserializeErrors(errors) {\r\n  if (!errors) return null;\r\n  let entries = Object.entries(errors);\r\n  let serialized = {};\r\n\r\n  for (let [key, val] of entries) {\r\n    // Hey you!  If you change this, please change the corresponding logic in\r\n    // serializeErrors in react-router-dom/server.tsx :)\r\n    if (val && val.__type === \"RouteErrorResponse\") {\r\n      serialized[key] = new ErrorResponse(val.status, val.statusText, val.data, val.internal === true);\r\n    } else if (val && val.__type === \"Error\") {\r\n      let error = new Error(val.message); // Wipe away the client-side stack trace.  Nothing to fill it in with\r\n      // because we don't serialize SSR stack traces for security reasons\r\n\r\n      error.stack = \"\";\r\n      serialized[key] = error;\r\n    } else {\r\n      serialized[key] = val;\r\n    }\r\n  }\r\n\r\n  return serialized;\r\n}\r\n/**\r\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\r\n */\r\n\r\n\r\nfunction BrowserRouter(_ref) {\r\n  let {\r\n    basename,\r\n    children,\r\n    window\r\n  } = _ref;\r\n  let historyRef = React.useRef();\r\n\r\n  if (historyRef.current == null) {\r\n    historyRef.current = createBrowserHistory({\r\n      window,\r\n      v5Compat: true\r\n    });\r\n  }\r\n\r\n  let history = historyRef.current;\r\n  let [state, setState] = React.useState({\r\n    action: history.action,\r\n    location: history.location\r\n  });\r\n  React.useLayoutEffect(() => history.listen(setState), [history]);\r\n  return /*#__PURE__*/React.createElement(Router, {\r\n    basename: basename,\r\n    children: children,\r\n    location: state.location,\r\n    navigationType: state.action,\r\n    navigator: history\r\n  });\r\n}\r\n/**\r\n * A `<Router>` for use in web browsers. Stores the location in the hash\r\n * portion of the URL so it is not sent to the server.\r\n */\r\n\r\nfunction HashRouter(_ref2) {\r\n  let {\r\n    basename,\r\n    children,\r\n    window\r\n  } = _ref2;\r\n  let historyRef = React.useRef();\r\n\r\n  if (historyRef.current == null) {\r\n    historyRef.current = createHashHistory({\r\n      window,\r\n      v5Compat: true\r\n    });\r\n  }\r\n\r\n  let history = historyRef.current;\r\n  let [state, setState] = React.useState({\r\n    action: history.action,\r\n    location: history.location\r\n  });\r\n  React.useLayoutEffect(() => history.listen(setState), [history]);\r\n  return /*#__PURE__*/React.createElement(Router, {\r\n    basename: basename,\r\n    children: children,\r\n    location: state.location,\r\n    navigationType: state.action,\r\n    navigator: history\r\n  });\r\n}\r\n/**\r\n * A `<Router>` that accepts a pre-instantiated history object. It's important\r\n * to note that using your own history object is highly discouraged and may add\r\n * two versions of the history library to your bundles unless you use the same\r\n * version of the history library that React Router uses internally.\r\n */\r\n\r\nfunction HistoryRouter(_ref3) {\r\n  let {\r\n    basename,\r\n    children,\r\n    history\r\n  } = _ref3;\r\n  const [state, setState] = React.useState({\r\n    action: history.action,\r\n    location: history.location\r\n  });\r\n  React.useLayoutEffect(() => history.listen(setState), [history]);\r\n  return /*#__PURE__*/React.createElement(Router, {\r\n    basename: basename,\r\n    children: children,\r\n    location: state.location,\r\n    navigationType: state.action,\r\n    navigator: history\r\n  });\r\n}\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  HistoryRouter.displayName = \"unstable_HistoryRouter\";\r\n}\r\nconst isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\r\n/**\r\n * The public API for rendering a history-aware <a>.\r\n */\r\n\r\nconst Link = /*#__PURE__*/React.forwardRef(function LinkWithRef(_ref4, ref) {\r\n  let {\r\n    onClick,\r\n    relative,\r\n    reloadDocument,\r\n    replace,\r\n    state,\r\n    target,\r\n    to,\r\n    preventScrollReset\r\n  } = _ref4,\r\n      rest = _objectWithoutPropertiesLoose(_ref4, _excluded);\r\n\r\n  // Rendered into <a href> for absolute URLs\r\n  let absoluteHref;\r\n  let isExternal = false;\r\n\r\n  if (isBrowser && typeof to === \"string\" && /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i.test(to)) {\r\n    absoluteHref = to;\r\n    let currentUrl = new URL(window.location.href);\r\n    let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\r\n\r\n    if (targetUrl.origin === currentUrl.origin) {\r\n      // Strip the protocol/origin for same-origin absolute URLs\r\n      to = targetUrl.pathname + targetUrl.search + targetUrl.hash;\r\n    } else {\r\n      isExternal = true;\r\n    }\r\n  } // Rendered into <a href> for relative URLs\r\n\r\n\r\n  let href = useHref(to, {\r\n    relative\r\n  });\r\n  let internalOnClick = useLinkClickHandler(to, {\r\n    replace,\r\n    state,\r\n    target,\r\n    preventScrollReset,\r\n    relative\r\n  });\r\n\r\n  function handleClick(event) {\r\n    if (onClick) onClick(event);\r\n\r\n    if (!event.defaultPrevented) {\r\n      internalOnClick(event);\r\n    }\r\n  }\r\n\r\n  return (\r\n    /*#__PURE__*/\r\n    // eslint-disable-next-line jsx-a11y/anchor-has-content\r\n    React.createElement(\"a\", _extends({}, rest, {\r\n      href: absoluteHref || href,\r\n      onClick: isExternal || reloadDocument ? onClick : handleClick,\r\n      ref: ref,\r\n      target: target\r\n    }))\r\n  );\r\n});\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  Link.displayName = \"Link\";\r\n}\r\n/**\r\n * A <Link> wrapper that knows if it's \"active\" or not.\r\n */\r\n\r\n\r\nconst NavLink = /*#__PURE__*/React.forwardRef(function NavLinkWithRef(_ref5, ref) {\r\n  let {\r\n    \"aria-current\": ariaCurrentProp = \"page\",\r\n    caseSensitive = false,\r\n    className: classNameProp = \"\",\r\n    end = false,\r\n    style: styleProp,\r\n    to,\r\n    children\r\n  } = _ref5,\r\n      rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);\r\n\r\n  let path = useResolvedPath(to, {\r\n    relative: rest.relative\r\n  });\r\n  let location = useLocation();\r\n  let routerState = React.useContext(UNSAFE_DataRouterStateContext);\r\n  let {\r\n    navigator\r\n  } = React.useContext(UNSAFE_NavigationContext);\r\n  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\r\n  let locationPathname = location.pathname;\r\n  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\r\n\r\n  if (!caseSensitive) {\r\n    locationPathname = locationPathname.toLowerCase();\r\n    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\r\n    toPathname = toPathname.toLowerCase();\r\n  }\r\n\r\n  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === \"/\";\r\n  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\r\n  let ariaCurrent = isActive ? ariaCurrentProp : undefined;\r\n  let className;\r\n\r\n  if (typeof classNameProp === \"function\") {\r\n    className = classNameProp({\r\n      isActive,\r\n      isPending\r\n    });\r\n  } else {\r\n    // If the className prop is not a function, we use a default `active`\r\n    // class for <NavLink />s that are active. In v5 `active` was the default\r\n    // value for `activeClassName`, but we are removing that API and can still\r\n    // use the old default behavior for a cleaner upgrade path and keep the\r\n    // simple styling rules working as they currently do.\r\n    className = [classNameProp, isActive ? \"active\" : null, isPending ? \"pending\" : null].filter(Boolean).join(\" \");\r\n  }\r\n\r\n  let style = typeof styleProp === \"function\" ? styleProp({\r\n    isActive,\r\n    isPending\r\n  }) : styleProp;\r\n  return /*#__PURE__*/React.createElement(Link, _extends({}, rest, {\r\n    \"aria-current\": ariaCurrent,\r\n    className: className,\r\n    ref: ref,\r\n    style: style,\r\n    to: to\r\n  }), typeof children === \"function\" ? children({\r\n    isActive,\r\n    isPending\r\n  }) : children);\r\n});\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  NavLink.displayName = \"NavLink\";\r\n}\r\n/**\r\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\r\n * that the interaction with the server is with `fetch` instead of new document\r\n * requests, allowing components to add nicer UX to the page as the form is\r\n * submitted and returns with data.\r\n */\r\n\r\n\r\nconst Form = /*#__PURE__*/React.forwardRef((props, ref) => {\r\n  return /*#__PURE__*/React.createElement(FormImpl, _extends({}, props, {\r\n    ref: ref\r\n  }));\r\n});\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  Form.displayName = \"Form\";\r\n}\r\n\r\nconst FormImpl = /*#__PURE__*/React.forwardRef((_ref6, forwardedRef) => {\r\n  let {\r\n    reloadDocument,\r\n    replace,\r\n    method = defaultMethod,\r\n    action,\r\n    onSubmit,\r\n    fetcherKey,\r\n    routeId,\r\n    relative,\r\n    preventScrollReset\r\n  } = _ref6,\r\n      props = _objectWithoutPropertiesLoose(_ref6, _excluded3);\r\n\r\n  let submit = useSubmitImpl(fetcherKey, routeId);\r\n  let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\r\n  let formAction = useFormAction(action, {\r\n    relative\r\n  });\r\n\r\n  let submitHandler = event => {\r\n    onSubmit && onSubmit(event);\r\n    if (event.defaultPrevented) return;\r\n    event.preventDefault();\r\n    let submitter = event.nativeEvent.submitter;\r\n    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\r\n    submit(submitter || event.currentTarget, {\r\n      method: submitMethod,\r\n      replace,\r\n      relative,\r\n      preventScrollReset\r\n    });\r\n  };\r\n\r\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\r\n    ref: forwardedRef,\r\n    method: formMethod,\r\n    action: formAction,\r\n    onSubmit: reloadDocument ? onSubmit : submitHandler\r\n  }, props));\r\n});\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  FormImpl.displayName = \"FormImpl\";\r\n}\r\n/**\r\n * This component will emulate the browser's scroll restoration on location\r\n * changes.\r\n */\r\n\r\n\r\nfunction ScrollRestoration(_ref7) {\r\n  let {\r\n    getKey,\r\n    storageKey\r\n  } = _ref7;\r\n  useScrollRestoration({\r\n    getKey,\r\n    storageKey\r\n  });\r\n  return null;\r\n}\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  ScrollRestoration.displayName = \"ScrollRestoration\";\r\n} //#endregion\r\n////////////////////////////////////////////////////////////////////////////////\r\n//#region Hooks\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n\r\nvar DataRouterHook;\r\n\r\n(function (DataRouterHook) {\r\n  DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\r\n  DataRouterHook[\"UseSubmitImpl\"] = \"useSubmitImpl\";\r\n  DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\r\n})(DataRouterHook || (DataRouterHook = {}));\r\n\r\nvar DataRouterStateHook;\r\n\r\n(function (DataRouterStateHook) {\r\n  DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\r\n  DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\r\n})(DataRouterStateHook || (DataRouterStateHook = {}));\r\n\r\nfunction getDataRouterConsoleError(hookName) {\r\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\r\n}\r\n\r\nfunction useDataRouterContext(hookName) {\r\n  let ctx = React.useContext(UNSAFE_DataRouterContext);\r\n  !ctx ? process.env.NODE_ENV !== \"production\" ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\r\n  return ctx;\r\n}\r\n\r\nfunction useDataRouterState(hookName) {\r\n  let state = React.useContext(UNSAFE_DataRouterStateContext);\r\n  !state ? process.env.NODE_ENV !== \"production\" ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\r\n  return state;\r\n}\r\n/**\r\n * Handles the click behavior for router `<Link>` components. This is useful if\r\n * you need to create custom `<Link>` components with the same click behavior we\r\n * use in our exported `<Link>`.\r\n */\r\n\r\n\r\nfunction useLinkClickHandler(to, _temp) {\r\n  let {\r\n    target,\r\n    replace: replaceProp,\r\n    state,\r\n    preventScrollReset,\r\n    relative\r\n  } = _temp === void 0 ? {} : _temp;\r\n  let navigate = useNavigate();\r\n  let location = useLocation();\r\n  let path = useResolvedPath(to, {\r\n    relative\r\n  });\r\n  return React.useCallback(event => {\r\n    if (shouldProcessLinkClick(event, target)) {\r\n      event.preventDefault(); // If the URL hasn't changed, a regular <a> will do a replace instead of\r\n      // a push, so do the same here unless the replace prop is explicitly set\r\n\r\n      let replace = replaceProp !== undefined ? replaceProp : createPath(location) === createPath(path);\r\n      navigate(to, {\r\n        replace,\r\n        state,\r\n        preventScrollReset,\r\n        relative\r\n      });\r\n    }\r\n  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative]);\r\n}\r\n/**\r\n * A convenient wrapper for reading and writing search parameters via the\r\n * URLSearchParams interface.\r\n */\r\n\r\nfunction useSearchParams(defaultInit) {\r\n  process.env.NODE_ENV !== \"production\" ? warning(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") : void 0;\r\n  let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\r\n  let hasSetSearchParamsRef = React.useRef(false);\r\n  let location = useLocation();\r\n  let searchParams = React.useMemo(() => // Only merge in the defaults if we haven't yet called setSearchParams.\r\n  // Once we call that we want those to take precedence, otherwise you can't\r\n  // remove a param with setSearchParams({}) if it has an initial value\r\n  getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);\r\n  let navigate = useNavigate();\r\n  let setSearchParams = React.useCallback((nextInit, navigateOptions) => {\r\n    const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\r\n    hasSetSearchParamsRef.current = true;\r\n    navigate(\"?\" + newSearchParams, navigateOptions);\r\n  }, [navigate, searchParams]);\r\n  return [searchParams, setSearchParams];\r\n}\r\n/**\r\n * Returns a function that may be used to programmatically submit a form (or\r\n * some arbitrary data) to the server.\r\n */\r\n\r\nfunction useSubmit() {\r\n  return useSubmitImpl();\r\n}\r\n\r\nfunction useSubmitImpl(fetcherKey, routeId) {\r\n  let {\r\n    router\r\n  } = useDataRouterContext(DataRouterHook.UseSubmitImpl);\r\n  let defaultAction = useFormAction();\r\n  return React.useCallback(function (target, options) {\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n\r\n    if (typeof document === \"undefined\") {\r\n      throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\r\n    }\r\n\r\n    let {\r\n      method,\r\n      encType,\r\n      formData,\r\n      url\r\n    } = getFormSubmissionInfo(target, defaultAction, options);\r\n    let href = url.pathname + url.search;\r\n    let opts = {\r\n      replace: options.replace,\r\n      preventScrollReset: options.preventScrollReset,\r\n      formData,\r\n      formMethod: method,\r\n      formEncType: encType\r\n    };\r\n\r\n    if (fetcherKey) {\r\n      !(routeId != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"No routeId available for useFetcher()\") : invariant(false) : void 0;\r\n      router.fetch(fetcherKey, routeId, href, opts);\r\n    } else {\r\n      router.navigate(href, opts);\r\n    }\r\n  }, [defaultAction, router, fetcherKey, routeId]);\r\n}\r\n\r\nfunction useFormAction(action, _temp2) {\r\n  let {\r\n    relative\r\n  } = _temp2 === void 0 ? {} : _temp2;\r\n  let {\r\n    basename\r\n  } = React.useContext(UNSAFE_NavigationContext);\r\n  let routeContext = React.useContext(UNSAFE_RouteContext);\r\n  !routeContext ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"useFormAction must be used inside a RouteContext\") : invariant(false) : void 0;\r\n  let [match] = routeContext.matches.slice(-1); // Shallow clone path so we can modify it below, otherwise we modify the\r\n  // object referenced by useMemo inside useResolvedPath\r\n\r\n  let path = _extends({}, useResolvedPath(action ? action : \".\", {\r\n    relative\r\n  })); // Previously we set the default action to \".\". The problem with this is that\r\n  // `useResolvedPath(\".\")` excludes search params and the hash of the resolved\r\n  // URL. This is the intended behavior of when \".\" is specifically provided as\r\n  // the form action, but inconsistent w/ browsers when the action is omitted.\r\n  // https://github.com/remix-run/remix/issues/927\r\n\r\n\r\n  let location = useLocation();\r\n\r\n  if (action == null) {\r\n    // Safe to write to these directly here since if action was undefined, we\r\n    // would have called useResolvedPath(\".\") which will never include a search\r\n    // or hash\r\n    path.search = location.search;\r\n    path.hash = location.hash; // When grabbing search params from the URL, remove the automatically\r\n    // inserted ?index param so we match the useResolvedPath search behavior\r\n    // which would not include ?index\r\n\r\n    if (match.route.index) {\r\n      let params = new URLSearchParams(path.search);\r\n      params.delete(\"index\");\r\n      path.search = params.toString() ? \"?\" + params.toString() : \"\";\r\n    }\r\n  }\r\n\r\n  if ((!action || action === \".\") && match.route.index) {\r\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\r\n  } // If we're operating within a basename, prepend it to the pathname prior\r\n  // to creating the form action.  If this is a root navigation, then just use\r\n  // the raw basename which allows the basename to have full control over the\r\n  // presence of a trailing slash on root actions\r\n\r\n\r\n  if (basename !== \"/\") {\r\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\r\n  }\r\n\r\n  return createPath(path);\r\n}\r\n\r\nfunction createFetcherForm(fetcherKey, routeId) {\r\n  let FetcherForm = /*#__PURE__*/React.forwardRef((props, ref) => {\r\n    return /*#__PURE__*/React.createElement(FormImpl, _extends({}, props, {\r\n      ref: ref,\r\n      fetcherKey: fetcherKey,\r\n      routeId: routeId\r\n    }));\r\n  });\r\n\r\n  if (process.env.NODE_ENV !== \"production\") {\r\n    FetcherForm.displayName = \"fetcher.Form\";\r\n  }\r\n\r\n  return FetcherForm;\r\n}\r\n\r\nlet fetcherId = 0;\r\n/**\r\n * Interacts with route loaders and actions without causing a navigation. Great\r\n * for any interaction that stays on the same page.\r\n */\r\n\r\nfunction useFetcher() {\r\n  var _route$matches;\r\n\r\n  let {\r\n    router\r\n  } = useDataRouterContext(DataRouterHook.UseFetcher);\r\n  let route = React.useContext(UNSAFE_RouteContext);\r\n  !route ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"useFetcher must be used inside a RouteContext\") : invariant(false) : void 0;\r\n  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\r\n  !(routeId != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"useFetcher can only be used on routes that contain a unique \\\"id\\\"\") : invariant(false) : void 0;\r\n  let [fetcherKey] = React.useState(() => String(++fetcherId));\r\n  let [Form] = React.useState(() => {\r\n    !routeId ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"No routeId available for fetcher.Form()\") : invariant(false) : void 0;\r\n    return createFetcherForm(fetcherKey, routeId);\r\n  });\r\n  let [load] = React.useState(() => href => {\r\n    !router ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"No router available for fetcher.load()\") : invariant(false) : void 0;\r\n    !routeId ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"No routeId available for fetcher.load()\") : invariant(false) : void 0;\r\n    router.fetch(fetcherKey, routeId, href);\r\n  });\r\n  let submit = useSubmitImpl(fetcherKey, routeId);\r\n  let fetcher = router.getFetcher(fetcherKey);\r\n  let fetcherWithComponents = React.useMemo(() => _extends({\r\n    Form,\r\n    submit,\r\n    load\r\n  }, fetcher), [fetcher, Form, submit, load]);\r\n  React.useEffect(() => {\r\n    // Is this busted when the React team gets real weird and calls effects\r\n    // twice on mount?  We really just need to garbage collect here when this\r\n    // fetcher is no longer around.\r\n    return () => {\r\n      if (!router) {\r\n        console.warn(\"No fetcher available to clean up from useFetcher()\");\r\n        return;\r\n      }\r\n\r\n      router.deleteFetcher(fetcherKey);\r\n    };\r\n  }, [router, fetcherKey]);\r\n  return fetcherWithComponents;\r\n}\r\n/**\r\n * Provides all fetchers currently on the page. Useful for layouts and parent\r\n * routes that need to provide pending/optimistic UI regarding the fetch.\r\n */\r\n\r\nfunction useFetchers() {\r\n  let state = useDataRouterState(DataRouterStateHook.UseFetchers);\r\n  return [...state.fetchers.values()];\r\n}\r\nconst SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\r\nlet savedScrollPositions = {};\r\n/**\r\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\r\n */\r\n\r\nfunction useScrollRestoration(_temp3) {\r\n  let {\r\n    getKey,\r\n    storageKey\r\n  } = _temp3 === void 0 ? {} : _temp3;\r\n  let {\r\n    router\r\n  } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\r\n  let {\r\n    restoreScrollPosition,\r\n    preventScrollReset\r\n  } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);\r\n  let location = useLocation();\r\n  let matches = useMatches();\r\n  let navigation = useNavigation(); // Trigger manual scroll restoration while we're active\r\n\r\n  React.useEffect(() => {\r\n    window.history.scrollRestoration = \"manual\";\r\n    return () => {\r\n      window.history.scrollRestoration = \"auto\";\r\n    };\r\n  }, []); // Save positions on pagehide\r\n\r\n  usePageHide(React.useCallback(() => {\r\n    if (navigation.state === \"idle\") {\r\n      let key = (getKey ? getKey(location, matches) : null) || location.key;\r\n      savedScrollPositions[key] = window.scrollY;\r\n    }\r\n\r\n    sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\r\n    window.history.scrollRestoration = \"auto\";\r\n  }, [storageKey, getKey, navigation.state, location, matches])); // Read in any saved scroll locations\r\n\r\n  if (typeof document !== \"undefined\") {\r\n    // eslint-disable-next-line react-hooks/rules-of-hooks\r\n    React.useLayoutEffect(() => {\r\n      try {\r\n        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\r\n\r\n        if (sessionPositions) {\r\n          savedScrollPositions = JSON.parse(sessionPositions);\r\n        }\r\n      } catch (e) {// no-op, use default empty object\r\n      }\r\n    }, [storageKey]); // Enable scroll restoration in the router\r\n    // eslint-disable-next-line react-hooks/rules-of-hooks\r\n\r\n    React.useLayoutEffect(() => {\r\n      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKey);\r\n      return () => disableScrollRestoration && disableScrollRestoration();\r\n    }, [router, getKey]); // Restore scrolling when state.restoreScrollPosition changes\r\n    // eslint-disable-next-line react-hooks/rules-of-hooks\r\n\r\n    React.useLayoutEffect(() => {\r\n      // Explicit false means don't do anything (used for submissions)\r\n      if (restoreScrollPosition === false) {\r\n        return;\r\n      } // been here before, scroll to it\r\n\r\n\r\n      if (typeof restoreScrollPosition === \"number\") {\r\n        window.scrollTo(0, restoreScrollPosition);\r\n        return;\r\n      } // try to scroll to the hash\r\n\r\n\r\n      if (location.hash) {\r\n        let el = document.getElementById(location.hash.slice(1));\r\n\r\n        if (el) {\r\n          el.scrollIntoView();\r\n          return;\r\n        }\r\n      } // Don't reset if this navigation opted out\r\n\r\n\r\n      if (preventScrollReset === true) {\r\n        return;\r\n      } // otherwise go to the top on new locations\r\n\r\n\r\n      window.scrollTo(0, 0);\r\n    }, [location, restoreScrollPosition, preventScrollReset]);\r\n  }\r\n}\r\n/**\r\n * Setup a callback to be fired on the window's `beforeunload` event. This is\r\n * useful for saving some data to `window.localStorage` just before the page\r\n * refreshes.\r\n *\r\n * Note: The `callback` argument should be a function created with\r\n * `React.useCallback()`.\r\n */\r\n\r\n\r\nfunction useBeforeUnload(callback, options) {\r\n  let {\r\n    capture\r\n  } = options || {};\r\n  React.useEffect(() => {\r\n    let opts = capture != null ? {\r\n      capture\r\n    } : undefined;\r\n    window.addEventListener(\"beforeunload\", callback, opts);\r\n    return () => {\r\n      window.removeEventListener(\"beforeunload\", callback, opts);\r\n    };\r\n  }, [callback, capture]);\r\n}\r\n/**\r\n * Setup a callback to be fired on the window's `pagehide` event. This is\r\n * useful for saving some data to `window.localStorage` just before the page\r\n * refreshes.  This event is better supported than beforeunload across browsers.\r\n *\r\n * Note: The `callback` argument should be a function created with\r\n * `React.useCallback()`.\r\n */\r\n\r\nfunction usePageHide(callback, options) {\r\n  let {\r\n    capture\r\n  } = options || {};\r\n  React.useEffect(() => {\r\n    let opts = capture != null ? {\r\n      capture\r\n    } : undefined;\r\n    window.addEventListener(\"pagehide\", callback, opts);\r\n    return () => {\r\n      window.removeEventListener(\"pagehide\", callback, opts);\r\n    };\r\n  }, [callback, capture]);\r\n}\r\n/**\r\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\r\n * of building a custom UI with useBlocker.\r\n *\r\n * Warning: This has *a lot of rough edges* and behaves very differently (and\r\n * very incorrectly in some cases) across browsers if user click addition\r\n * back/forward navigations while the confirm is open.  Use at your own risk.\r\n */\r\n\r\n\r\nfunction usePrompt(_ref8) {\r\n  let {\r\n    when,\r\n    message\r\n  } = _ref8;\r\n  let blocker = unstable_useBlocker(when);\r\n  React.useEffect(() => {\r\n    if (blocker.state === \"blocked\" && !when) {\r\n      blocker.reset();\r\n    }\r\n  }, [blocker, when]);\r\n  React.useEffect(() => {\r\n    if (blocker.state === \"blocked\") {\r\n      let proceed = window.confirm(message);\r\n\r\n      if (proceed) {\r\n        setTimeout(blocker.proceed, 0);\r\n      } else {\r\n        blocker.reset();\r\n      }\r\n    }\r\n  }, [blocker, message]);\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\n//#region Utils\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction warning(cond, message) {\r\n  if (!cond) {\r\n    // eslint-disable-next-line no-console\r\n    if (typeof console !== \"undefined\") console.warn(message);\r\n\r\n    try {\r\n      // Welcome to debugging React Router!\r\n      //\r\n      // This error is thrown as a convenience so you can more easily\r\n      // find the source for a warning that appears in the console by\r\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\r\n      throw new Error(message); // eslint-disable-next-line no-empty\r\n    } catch (e) {}\r\n  }\r\n} //#endregion\r\n\r\nexport { BrowserRouter, Form, HashRouter, Link, NavLink, ScrollRestoration, useScrollRestoration as UNSAFE_useScrollRestoration, createBrowserRouter, createHashRouter, createSearchParams, HistoryRouter as unstable_HistoryRouter, usePrompt as unstable_usePrompt, useBeforeUnload, useFetcher, useFetchers, useFormAction, useLinkClickHandler, useSearchParams, useSubmit };\r\n//# sourceMappingURL=index.js.map\r\n"],"names":["_extends","target","i","source","key","_objectWithoutPropertiesLoose","excluded","sourceKeys","isModifiedEvent","event","shouldProcessLinkClick","_excluded","_excluded2","HashRouter","_ref2","basename","children","window","historyRef","reactExports","createHashHistory","history","state","setState","React.useLayoutEffect","React.createElement","Router","isBrowser","Link","_ref4","ref","onClick","relative","reloadDocument","replace","to","rest","absoluteHref","isExternal","currentUrl","targetUrl","href","useHref","internalOnClick","useLinkClickHandler","preventScrollReset","handleClick","NavLink","_ref5","ariaCurrentProp","caseSensitive","classNameProp","end","styleProp","path","useResolvedPath","location","useLocation","routerState","DataRouterStateContext","React.useContext","NavigationContext","toPathname","navigator","locationPathname","nextLocationPathname","isActive","isPending","ariaCurrent","className","style","DataRouterHook","DataRouterStateHook","_temp","replaceProp","navigate","useNavigate","React.useCallback","createPath"],"mappings":"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"}
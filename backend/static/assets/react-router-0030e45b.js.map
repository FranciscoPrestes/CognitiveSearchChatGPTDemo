{"version":3,"file":"react-router-0030e45b.js","sources":["../../../frontend/node_modules/react-router/dist/index.js"],"sourcesContent":["/**\r\n * React Router v6.8.1\r\n *\r\n * Copyright (c) Remix Software Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE.md file in the root directory of this source tree.\r\n *\r\n * @license MIT\r\n */\r\nimport { invariant, joinPaths, matchPath, UNSAFE_getPathContributingMatches, warning, resolveTo, parsePath, matchRoutes, Action, isRouteErrorResponse, createMemoryHistory, stripBasename, AbortedDeferredError, createRouter } from '@remix-run/router';\r\nexport { AbortedDeferredError, Action as NavigationType, createPath, defer, generatePath, isRouteErrorResponse, json, matchPath, matchRoutes, parsePath, redirect, resolvePath } from '@remix-run/router';\r\nimport * as React from 'react';\r\n\r\nfunction _extends() {\r\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\r\n    for (var i = 1; i < arguments.length; i++) {\r\n      var source = arguments[i];\r\n\r\n      for (var key in source) {\r\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n          target[key] = source[key];\r\n        }\r\n      }\r\n    }\r\n\r\n    return target;\r\n  };\r\n  return _extends.apply(this, arguments);\r\n}\r\n\r\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n/**\r\n * inlined Object.is polyfill to avoid requiring consumers ship their own\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\r\n */\r\n\r\nfunction isPolyfill(x, y) {\r\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\r\n  ;\r\n}\r\n\r\nconst is = typeof Object.is === \"function\" ? Object.is : isPolyfill; // Intentionally not using named imports because Rollup uses dynamic\r\n// dispatch for CommonJS interop named imports.\r\n\r\nconst {\r\n  useState,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  useDebugValue\r\n} = React;\r\nlet didWarnOld18Alpha = false;\r\nlet didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\r\n// because of a very particular set of implementation details and assumptions\r\n// -- change any one of them and it will break. The most important assumption\r\n// is that updates are always synchronous, because concurrent rendering is\r\n// only available in versions of React that also have a built-in\r\n// useSyncExternalStore API. And we only use this shim when the built-in API\r\n// does not exist.\r\n//\r\n// Do not assume that the clever hacks used by this hook also work in general.\r\n// The point of this shim is to replace the need for hacks by other libraries.\r\n\r\nfunction useSyncExternalStore$2(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\r\n// React do not expose a way to check if we're hydrating. So users of the shim\r\n// will need to track that themselves and return the correct value\r\n// from `getSnapshot`.\r\ngetServerSnapshot) {\r\n  if (process.env.NODE_ENV !== \"production\") {\r\n    if (!didWarnOld18Alpha) {\r\n      if (\"startTransition\" in React) {\r\n        didWarnOld18Alpha = true;\r\n        console.error(\"You are using an outdated, pre-release alpha of React 18 that \" + \"does not support useSyncExternalStore. The \" + \"use-sync-external-store shim will not work correctly. Upgrade \" + \"to a newer pre-release.\");\r\n      }\r\n    }\r\n  } // Read the current snapshot from the store on every render. Again, this\r\n  // breaks the rules of React, and only works here because of specific\r\n  // implementation details, most importantly that updates are\r\n  // always synchronous.\r\n\r\n\r\n  const value = getSnapshot();\r\n\r\n  if (process.env.NODE_ENV !== \"production\") {\r\n    if (!didWarnUncachedGetSnapshot) {\r\n      const cachedValue = getSnapshot();\r\n\r\n      if (!is(value, cachedValue)) {\r\n        console.error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\r\n        didWarnUncachedGetSnapshot = true;\r\n      }\r\n    }\r\n  } // Because updates are synchronous, we don't queue them. Instead we force a\r\n  // re-render whenever the subscribed state changes by updating an some\r\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\r\n  // the current value.\r\n  //\r\n  // Because we don't actually use the state returned by the useState hook, we\r\n  // can save a bit of memory by storing other stuff in that slot.\r\n  //\r\n  // To implement the early bailout, we need to track some things on a mutable\r\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\r\n  // our useState hook instead.\r\n  //\r\n  // To force a re-render, we call forceUpdate({inst}). That works because the\r\n  // new object always fails an equality check.\r\n\r\n\r\n  const [{\r\n    inst\r\n  }, forceUpdate] = useState({\r\n    inst: {\r\n      value,\r\n      getSnapshot\r\n    }\r\n  }); // Track the latest getSnapshot function with a ref. This needs to be updated\r\n  // in the layout phase so we can access it during the tearing check that\r\n  // happens on subscribe.\r\n\r\n  useLayoutEffect(() => {\r\n    inst.value = value;\r\n    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\r\n    // commit phase if there was an interleaved mutation. In concurrent mode\r\n    // this can happen all the time, but even in synchronous mode, an earlier\r\n    // effect may have mutated the store.\r\n\r\n    if (checkIfSnapshotChanged(inst)) {\r\n      // Force a re-render.\r\n      forceUpdate({\r\n        inst\r\n      });\r\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\r\n\r\n  }, [subscribe, value, getSnapshot]);\r\n  useEffect(() => {\r\n    // Check for changes right before subscribing. Subsequent changes will be\r\n    // detected in the subscription handler.\r\n    if (checkIfSnapshotChanged(inst)) {\r\n      // Force a re-render.\r\n      forceUpdate({\r\n        inst\r\n      });\r\n    }\r\n\r\n    const handleStoreChange = () => {\r\n      // TODO: Because there is no cross-renderer API for batching updates, it's\r\n      // up to the consumer of this library to wrap their subscription event\r\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\r\n      // the case and print a warning in development?\r\n      // The store changed. Check if the snapshot changed since the last time we\r\n      // read from the store.\r\n      if (checkIfSnapshotChanged(inst)) {\r\n        // Force a re-render.\r\n        forceUpdate({\r\n          inst\r\n        });\r\n      }\r\n    }; // Subscribe to the store and return a clean-up function.\r\n\r\n\r\n    return subscribe(handleStoreChange); // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [subscribe]);\r\n  useDebugValue(value);\r\n  return value;\r\n}\r\n\r\nfunction checkIfSnapshotChanged(inst) {\r\n  const latestGetSnapshot = inst.getSnapshot;\r\n  const prevValue = inst.value;\r\n\r\n  try {\r\n    const nextValue = latestGetSnapshot();\r\n    return !is(prevValue, nextValue);\r\n  } catch (error) {\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * Copyright (c) Facebook, Inc. and its affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * @flow\r\n */\r\nfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\r\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\r\n  // React do not expose a way to check if we're hydrating. So users of the shim\r\n  // will need to track that themselves and return the correct value\r\n  // from `getSnapshot`.\r\n  return getSnapshot();\r\n}\r\n\r\n/**\r\n * Inlined into the react-router repo since use-sync-external-store does not\r\n * provide a UMD-compatible package, so we need this to be able to distribute\r\n * UMD react-router bundles\r\n */\r\nconst canUseDOM = !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\r\nconst isServerEnvironment = !canUseDOM;\r\nconst shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;\r\nconst useSyncExternalStore = \"useSyncExternalStore\" in React ? (module => module.useSyncExternalStore)(React) : shim;\r\n\r\nconst DataRouterContext = /*#__PURE__*/React.createContext(null);\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  DataRouterContext.displayName = \"DataRouter\";\r\n}\r\n\r\nconst DataRouterStateContext = /*#__PURE__*/React.createContext(null);\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  DataRouterStateContext.displayName = \"DataRouterState\";\r\n}\r\n\r\nconst AwaitContext = /*#__PURE__*/React.createContext(null);\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  AwaitContext.displayName = \"Await\";\r\n}\r\n\r\nconst NavigationContext = /*#__PURE__*/React.createContext(null);\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  NavigationContext.displayName = \"Navigation\";\r\n}\r\n\r\nconst LocationContext = /*#__PURE__*/React.createContext(null);\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  LocationContext.displayName = \"Location\";\r\n}\r\n\r\nconst RouteContext = /*#__PURE__*/React.createContext({\r\n  outlet: null,\r\n  matches: []\r\n});\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  RouteContext.displayName = \"Route\";\r\n}\r\n\r\nconst RouteErrorContext = /*#__PURE__*/React.createContext(null);\r\n\r\nif (process.env.NODE_ENV !== \"production\") {\r\n  RouteErrorContext.displayName = \"RouteError\";\r\n}\r\n\r\n/**\r\n * Returns the full href for the given \"to\" value. This is useful for building\r\n * custom links that are also accessible and preserve right-click behavior.\r\n *\r\n * @see https://reactrouter.com/hooks/use-href\r\n */\r\n\r\nfunction useHref(to, _temp) {\r\n  let {\r\n    relative\r\n  } = _temp === void 0 ? {} : _temp;\r\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\r\n  // router loaded. We can help them understand how to avoid that.\r\n  \"useHref() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\r\n  let {\r\n    basename,\r\n    navigator\r\n  } = React.useContext(NavigationContext);\r\n  let {\r\n    hash,\r\n    pathname,\r\n    search\r\n  } = useResolvedPath(to, {\r\n    relative\r\n  });\r\n  let joinedPathname = pathname; // If we're operating within a basename, prepend it to the pathname prior\r\n  // to creating the href.  If this is a root navigation, then just use the raw\r\n  // basename which allows the basename to have full control over the presence\r\n  // of a trailing slash on root links\r\n\r\n  if (basename !== \"/\") {\r\n    joinedPathname = pathname === \"/\" ? basename : joinPaths([basename, pathname]);\r\n  }\r\n\r\n  return navigator.createHref({\r\n    pathname: joinedPathname,\r\n    search,\r\n    hash\r\n  });\r\n}\r\n/**\r\n * Returns true if this component is a descendant of a <Router>.\r\n *\r\n * @see https://reactrouter.com/hooks/use-in-router-context\r\n */\r\n\r\nfunction useInRouterContext() {\r\n  return React.useContext(LocationContext) != null;\r\n}\r\n/**\r\n * Returns the current location object, which represents the current URL in web\r\n * browsers.\r\n *\r\n * Note: If you're using this it may mean you're doing some of your own\r\n * \"routing\" in your app, and we'd like to know what your use case is. We may\r\n * be able to provide something higher-level to better suit your needs.\r\n *\r\n * @see https://reactrouter.com/hooks/use-location\r\n */\r\n\r\nfunction useLocation() {\r\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\r\n  // router loaded. We can help them understand how to avoid that.\r\n  \"useLocation() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\r\n  return React.useContext(LocationContext).location;\r\n}\r\n/**\r\n * Returns the current navigation action which describes how the router came to\r\n * the current location, either by a pop, push, or replace on the history stack.\r\n *\r\n * @see https://reactrouter.com/hooks/use-navigation-type\r\n */\r\n\r\nfunction useNavigationType() {\r\n  return React.useContext(LocationContext).navigationType;\r\n}\r\n/**\r\n * Returns a PathMatch object if the given pattern matches the current URL.\r\n * This is useful for components that need to know \"active\" state, e.g.\r\n * <NavLink>.\r\n *\r\n * @see https://reactrouter.com/hooks/use-match\r\n */\r\n\r\nfunction useMatch(pattern) {\r\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\r\n  // router loaded. We can help them understand how to avoid that.\r\n  \"useMatch() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\r\n  let {\r\n    pathname\r\n  } = useLocation();\r\n  return React.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);\r\n}\r\n/**\r\n * The interface for the navigate() function returned from useNavigate().\r\n */\r\n\r\n/**\r\n * Returns an imperative method for changing the location. Used by <Link>s, but\r\n * may also be used by other elements to change the location.\r\n *\r\n * @see https://reactrouter.com/hooks/use-navigate\r\n */\r\nfunction useNavigate() {\r\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\r\n  // router loaded. We can help them understand how to avoid that.\r\n  \"useNavigate() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\r\n  let {\r\n    basename,\r\n    navigator\r\n  } = React.useContext(NavigationContext);\r\n  let {\r\n    matches\r\n  } = React.useContext(RouteContext);\r\n  let {\r\n    pathname: locationPathname\r\n  } = useLocation();\r\n  let routePathnamesJson = JSON.stringify(UNSAFE_getPathContributingMatches(matches).map(match => match.pathnameBase));\r\n  let activeRef = React.useRef(false);\r\n  React.useEffect(() => {\r\n    activeRef.current = true;\r\n  });\r\n  let navigate = React.useCallback(function (to, options) {\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n\r\n    process.env.NODE_ENV !== \"production\" ? warning(activeRef.current, \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\") : void 0;\r\n    if (!activeRef.current) return;\r\n\r\n    if (typeof to === \"number\") {\r\n      navigator.go(to);\r\n      return;\r\n    }\r\n\r\n    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\"); // If we're operating within a basename, prepend it to the pathname prior\r\n    // to handing off to history.  If this is a root navigation, then we\r\n    // navigate to the raw basename which allows the basename to have full\r\n    // control over the presence of a trailing slash on root links\r\n\r\n    if (basename !== \"/\") {\r\n      path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\r\n    }\r\n\r\n    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\r\n  }, [basename, navigator, routePathnamesJson, locationPathname]);\r\n  return navigate;\r\n}\r\nconst OutletContext = /*#__PURE__*/React.createContext(null);\r\n/**\r\n * Returns the context (if provided) for the child route at this level of the route\r\n * hierarchy.\r\n * @see https://reactrouter.com/hooks/use-outlet-context\r\n */\r\n\r\nfunction useOutletContext() {\r\n  return React.useContext(OutletContext);\r\n}\r\n/**\r\n * Returns the element for the child route at this level of the route\r\n * hierarchy. Used internally by <Outlet> to render child routes.\r\n *\r\n * @see https://reactrouter.com/hooks/use-outlet\r\n */\r\n\r\nfunction useOutlet(context) {\r\n  let outlet = React.useContext(RouteContext).outlet;\r\n\r\n  if (outlet) {\r\n    return /*#__PURE__*/React.createElement(OutletContext.Provider, {\r\n      value: context\r\n    }, outlet);\r\n  }\r\n\r\n  return outlet;\r\n}\r\n/**\r\n * Returns an object of key/value pairs of the dynamic params from the current\r\n * URL that were matched by the route path.\r\n *\r\n * @see https://reactrouter.com/hooks/use-params\r\n */\r\n\r\nfunction useParams() {\r\n  let {\r\n    matches\r\n  } = React.useContext(RouteContext);\r\n  let routeMatch = matches[matches.length - 1];\r\n  return routeMatch ? routeMatch.params : {};\r\n}\r\n/**\r\n * Resolves the pathname of the given `to` value against the current location.\r\n *\r\n * @see https://reactrouter.com/hooks/use-resolved-path\r\n */\r\n\r\nfunction useResolvedPath(to, _temp2) {\r\n  let {\r\n    relative\r\n  } = _temp2 === void 0 ? {} : _temp2;\r\n  let {\r\n    matches\r\n  } = React.useContext(RouteContext);\r\n  let {\r\n    pathname: locationPathname\r\n  } = useLocation();\r\n  let routePathnamesJson = JSON.stringify(UNSAFE_getPathContributingMatches(matches).map(match => match.pathnameBase));\r\n  return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [to, routePathnamesJson, locationPathname, relative]);\r\n}\r\n/**\r\n * Returns the element of the route that matched the current location, prepared\r\n * with the correct context to render the remainder of the route tree. Route\r\n * elements in the tree must render an <Outlet> to render their child route's\r\n * element.\r\n *\r\n * @see https://reactrouter.com/hooks/use-routes\r\n */\r\n\r\nfunction useRoutes(routes, locationArg) {\r\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\r\n  // router loaded. We can help them understand how to avoid that.\r\n  \"useRoutes() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\r\n  let {\r\n    navigator\r\n  } = React.useContext(NavigationContext);\r\n  let dataRouterStateContext = React.useContext(DataRouterStateContext);\r\n  let {\r\n    matches: parentMatches\r\n  } = React.useContext(RouteContext);\r\n  let routeMatch = parentMatches[parentMatches.length - 1];\r\n  let parentParams = routeMatch ? routeMatch.params : {};\r\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\r\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\r\n  let parentRoute = routeMatch && routeMatch.route;\r\n\r\n  if (process.env.NODE_ENV !== \"production\") {\r\n    // You won't get a warning about 2 different <Routes> under a <Route>\r\n    // without a trailing *, but this is a best-effort warning anyway since we\r\n    // cannot even give the warning unless they land at the parent route.\r\n    //\r\n    // Example:\r\n    //\r\n    // <Routes>\r\n    //   {/* This route path MUST end with /* because otherwise\r\n    //       it will never match /blog/post/123 */}\r\n    //   <Route path=\"blog\" element={<Blog />} />\r\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\r\n    // </Routes>\r\n    //\r\n    // function Blog() {\r\n    //   return (\r\n    //     <Routes>\r\n    //       <Route path=\"post/:id\" element={<Post />} />\r\n    //     </Routes>\r\n    //   );\r\n    // }\r\n    let parentPath = parentRoute && parentRoute.path || \"\";\r\n    warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + \"\\\">.\"));\r\n  }\r\n\r\n  let locationFromContext = useLocation();\r\n  let location;\r\n\r\n  if (locationArg) {\r\n    var _parsedLocationArg$pa;\r\n\r\n    let parsedLocationArg = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\r\n    !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + (\"matched by all parent routes. The current pathname base is \\\"\" + parentPathnameBase + \"\\\" \") + (\"but pathname \\\"\" + parsedLocationArg.pathname + \"\\\" was given in the `location` prop.\")) : invariant(false) : void 0;\r\n    location = parsedLocationArg;\r\n  } else {\r\n    location = locationFromContext;\r\n  }\r\n\r\n  let pathname = location.pathname || \"/\";\r\n  let remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\r\n  let matches = matchRoutes(routes, {\r\n    pathname: remainingPathname\r\n  });\r\n\r\n  if (process.env.NODE_ENV !== \"production\") {\r\n    process.env.NODE_ENV !== \"production\" ? warning(parentRoute || matches != null, \"No routes matched location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \") : void 0;\r\n    process.env.NODE_ENV !== \"production\" ? warning(matches == null || matches[matches.length - 1].route.element !== undefined, \"Matched leaf route at location \\\"\" + location.pathname + location.search + location.hash + \"\\\" does not have an element. \" + \"This means it will render an <Outlet /> with a null value by default resulting in an \\\"empty\\\" page.\") : void 0;\r\n  }\r\n\r\n  let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {\r\n    params: Object.assign({}, parentParams, match.params),\r\n    pathname: joinPaths([parentPathnameBase, // Re-encode pathnames that were decoded inside matchRoutes\r\n    navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),\r\n    pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : joinPaths([parentPathnameBase, // Re-encode pathnames that were decoded inside matchRoutes\r\n    navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])\r\n  })), parentMatches, dataRouterStateContext || undefined); // When a user passes in a `locationArg`, the associated routes need to\r\n  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\r\n  // to use the scoped location instead of the global location.\r\n\r\n\r\n  if (locationArg && renderedMatches) {\r\n    return /*#__PURE__*/React.createElement(LocationContext.Provider, {\r\n      value: {\r\n        location: _extends({\r\n          pathname: \"/\",\r\n          search: \"\",\r\n          hash: \"\",\r\n          state: null,\r\n          key: \"default\"\r\n        }, location),\r\n        navigationType: Action.Pop\r\n      }\r\n    }, renderedMatches);\r\n  }\r\n\r\n  return renderedMatches;\r\n}\r\n\r\nfunction DefaultErrorElement() {\r\n  let error = useRouteError();\r\n  let message = isRouteErrorResponse(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\r\n  let stack = error instanceof Error ? error.stack : null;\r\n  let lightgrey = \"rgba(200,200,200, 0.5)\";\r\n  let preStyles = {\r\n    padding: \"0.5rem\",\r\n    backgroundColor: lightgrey\r\n  };\r\n  let codeStyles = {\r\n    padding: \"2px 4px\",\r\n    backgroundColor: lightgrey\r\n  };\r\n  let devInfo = null;\r\n\r\n  if (process.env.NODE_ENV !== \"production\") {\r\n    devInfo = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/React.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own\\xA0\", /*#__PURE__*/React.createElement(\"code\", {\r\n      style: codeStyles\r\n    }, \"errorElement\"), \" props on\\xA0\", /*#__PURE__*/React.createElement(\"code\", {\r\n      style: codeStyles\r\n    }, \"<Route>\")));\r\n  }\r\n\r\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"h2\", null, \"Unexpected Application Error!\"), /*#__PURE__*/React.createElement(\"h3\", {\r\n    style: {\r\n      fontStyle: \"italic\"\r\n    }\r\n  }, message), stack ? /*#__PURE__*/React.createElement(\"pre\", {\r\n    style: preStyles\r\n  }, stack) : null, devInfo);\r\n}\r\n\r\nclass RenderErrorBoundary extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      location: props.location,\r\n      error: props.error\r\n    };\r\n  }\r\n\r\n  static getDerivedStateFromError(error) {\r\n    return {\r\n      error: error\r\n    };\r\n  }\r\n\r\n  static getDerivedStateFromProps(props, state) {\r\n    // When we get into an error state, the user will likely click \"back\" to the\r\n    // previous page that didn't have an error. Because this wraps the entire\r\n    // application, that will have no effect--the error page continues to display.\r\n    // This gives us a mechanism to recover from the error when the location changes.\r\n    //\r\n    // Whether we're in an error state or not, we update the location in state\r\n    // so that when we are in an error state, it gets reset when a new location\r\n    // comes in and the user recovers from the error.\r\n    if (state.location !== props.location) {\r\n      return {\r\n        error: props.error,\r\n        location: props.location\r\n      };\r\n    } // If we're not changing locations, preserve the location but still surface\r\n    // any new errors that may come through. We retain the existing error, we do\r\n    // this because the error provided from the app state may be cleared without\r\n    // the location changing.\r\n\r\n\r\n    return {\r\n      error: props.error || state.error,\r\n      location: state.location\r\n    };\r\n  }\r\n\r\n  componentDidCatch(error, errorInfo) {\r\n    console.error(\"React Router caught the following error during render\", error, errorInfo);\r\n  }\r\n\r\n  render() {\r\n    return this.state.error ? /*#__PURE__*/React.createElement(RouteContext.Provider, {\r\n      value: this.props.routeContext\r\n    }, /*#__PURE__*/React.createElement(RouteErrorContext.Provider, {\r\n      value: this.state.error,\r\n      children: this.props.component\r\n    })) : this.props.children;\r\n  }\r\n\r\n}\r\n\r\nfunction RenderedRoute(_ref) {\r\n  let {\r\n    routeContext,\r\n    match,\r\n    children\r\n  } = _ref;\r\n  let dataRouterContext = React.useContext(DataRouterContext); // Track how deep we got in our render pass to emulate SSR componentDidCatch\r\n  // in a DataStaticRouter\r\n\r\n  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && match.route.errorElement) {\r\n    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\r\n  }\r\n\r\n  return /*#__PURE__*/React.createElement(RouteContext.Provider, {\r\n    value: routeContext\r\n  }, children);\r\n}\r\n\r\nfunction _renderMatches(matches, parentMatches, dataRouterState) {\r\n  if (parentMatches === void 0) {\r\n    parentMatches = [];\r\n  }\r\n\r\n  if (matches == null) {\r\n    if (dataRouterState != null && dataRouterState.errors) {\r\n      // Don't bail if we have data router errors so we can render them in the\r\n      // boundary.  Use the pre-matched (or shimmed) matches\r\n      matches = dataRouterState.matches;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  let renderedMatches = matches; // If we have data errors, trim matches to the highest error boundary\r\n\r\n  let errors = dataRouterState == null ? void 0 : dataRouterState.errors;\r\n\r\n  if (errors != null) {\r\n    let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]));\r\n    !(errorIndex >= 0) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Could not find a matching route for the current errors: \" + errors) : invariant(false) : void 0;\r\n    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\r\n  }\r\n\r\n  return renderedMatches.reduceRight((outlet, match, index) => {\r\n    let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null; // Only data routers handle errors\r\n\r\n    let errorElement = dataRouterState ? match.route.errorElement || /*#__PURE__*/React.createElement(DefaultErrorElement, null) : null;\r\n    let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\r\n\r\n    let getChildren = () => /*#__PURE__*/React.createElement(RenderedRoute, {\r\n      match: match,\r\n      routeContext: {\r\n        outlet,\r\n        matches\r\n      }\r\n    }, error ? errorElement : match.route.element !== undefined ? match.route.element : outlet); // Only wrap in an error boundary within data router usages when we have an\r\n    // errorElement on this route.  Otherwise let it bubble up to an ancestor\r\n    // errorElement\r\n\r\n\r\n    return dataRouterState && (match.route.errorElement || index === 0) ? /*#__PURE__*/React.createElement(RenderErrorBoundary, {\r\n      location: dataRouterState.location,\r\n      component: errorElement,\r\n      error: error,\r\n      children: getChildren(),\r\n      routeContext: {\r\n        outlet: null,\r\n        matches\r\n      }\r\n    }) : getChildren();\r\n  }, null);\r\n}\r\nvar DataRouterHook;\r\n\r\n(function (DataRouterHook) {\r\n  DataRouterHook[\"UseBlocker\"] = \"useBlocker\";\r\n  DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\r\n})(DataRouterHook || (DataRouterHook = {}));\r\n\r\nvar DataRouterStateHook;\r\n\r\n(function (DataRouterStateHook) {\r\n  DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\r\n  DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\r\n  DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\r\n  DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\r\n  DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\r\n  DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\r\n  DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\r\n})(DataRouterStateHook || (DataRouterStateHook = {}));\r\n\r\nfunction getDataRouterConsoleError(hookName) {\r\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\r\n}\r\n\r\nfunction useDataRouterContext(hookName) {\r\n  let ctx = React.useContext(DataRouterContext);\r\n  !ctx ? process.env.NODE_ENV !== \"production\" ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\r\n  return ctx;\r\n}\r\n\r\nfunction useDataRouterState(hookName) {\r\n  let state = React.useContext(DataRouterStateContext);\r\n  !state ? process.env.NODE_ENV !== \"production\" ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\r\n  return state;\r\n}\r\n\r\nfunction useRouteContext(hookName) {\r\n  let route = React.useContext(RouteContext);\r\n  !route ? process.env.NODE_ENV !== \"production\" ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;\r\n  return route;\r\n}\r\n\r\nfunction useCurrentRouteId(hookName) {\r\n  let route = useRouteContext(hookName);\r\n  let thisRoute = route.matches[route.matches.length - 1];\r\n  !thisRoute.route.id ? process.env.NODE_ENV !== \"production\" ? invariant(false, hookName + \" can only be used on routes that contain a unique \\\"id\\\"\") : invariant(false) : void 0;\r\n  return thisRoute.route.id;\r\n}\r\n/**\r\n * Returns the current navigation, defaulting to an \"idle\" navigation when\r\n * no navigation is in progress\r\n */\r\n\r\n\r\nfunction useNavigation() {\r\n  let state = useDataRouterState(DataRouterStateHook.UseNavigation);\r\n  return state.navigation;\r\n}\r\n/**\r\n * Returns a revalidate function for manually triggering revalidation, as well\r\n * as the current state of any manual revalidations\r\n */\r\n\r\nfunction useRevalidator() {\r\n  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\r\n  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\r\n  return {\r\n    revalidate: dataRouterContext.router.revalidate,\r\n    state: state.revalidation\r\n  };\r\n}\r\n/**\r\n * Returns the active route matches, useful for accessing loaderData for\r\n * parent/child routes or the route \"handle\" property\r\n */\r\n\r\nfunction useMatches() {\r\n  let {\r\n    matches,\r\n    loaderData\r\n  } = useDataRouterState(DataRouterStateHook.UseMatches);\r\n  return React.useMemo(() => matches.map(match => {\r\n    let {\r\n      pathname,\r\n      params\r\n    } = match; // Note: This structure matches that created by createUseMatchesMatch\r\n    // in the @remix-run/router , so if you change this please also change\r\n    // that :)  Eventually we'll DRY this up\r\n\r\n    return {\r\n      id: match.route.id,\r\n      pathname,\r\n      params,\r\n      data: loaderData[match.route.id],\r\n      handle: match.route.handle\r\n    };\r\n  }), [matches, loaderData]);\r\n}\r\n/**\r\n * Returns the loader data for the nearest ancestor Route loader\r\n */\r\n\r\nfunction useLoaderData() {\r\n  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\r\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\r\n\r\n  if (state.errors && state.errors[routeId] != null) {\r\n    console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\r\n    return undefined;\r\n  }\r\n\r\n  return state.loaderData[routeId];\r\n}\r\n/**\r\n * Returns the loaderData for the given routeId\r\n */\r\n\r\nfunction useRouteLoaderData(routeId) {\r\n  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\r\n  return state.loaderData[routeId];\r\n}\r\n/**\r\n * Returns the action data for the nearest ancestor Route action\r\n */\r\n\r\nfunction useActionData() {\r\n  let state = useDataRouterState(DataRouterStateHook.UseActionData);\r\n  let route = React.useContext(RouteContext);\r\n  !route ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"useActionData must be used inside a RouteContext\") : invariant(false) : void 0;\r\n  return Object.values((state == null ? void 0 : state.actionData) || {})[0];\r\n}\r\n/**\r\n * Returns the nearest ancestor Route error, which could be a loader/action\r\n * error or a render error.  This is intended to be called from your\r\n * errorElement to display a proper error message.\r\n */\r\n\r\nfunction useRouteError() {\r\n  var _state$errors;\r\n\r\n  let error = React.useContext(RouteErrorContext);\r\n  let state = useDataRouterState(DataRouterStateHook.UseRouteError);\r\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError); // If this was a render error, we put it in a RouteError context inside\r\n  // of RenderErrorBoundary\r\n\r\n  if (error) {\r\n    return error;\r\n  } // Otherwise look for errors from our data router state\r\n\r\n\r\n  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\r\n}\r\n/**\r\n * Returns the happy-path data from the nearest ancestor <Await /> value\r\n */\r\n\r\nfunction useAsyncValue() {\r\n  let value = React.useContext(AwaitContext);\r\n  return value == null ? void 0 : value._data;\r\n}\r\n/**\r\n * Returns the error from the nearest ancestor <Await /> value\r\n */\r\n\r\nfunction useAsyncError() {\r\n  let value = React.useContext(AwaitContext);\r\n  return value == null ? void 0 : value._error;\r\n}\r\nlet blockerId = 0;\r\n/**\r\n * Allow the application to block navigations within the SPA and present the\r\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\r\n * using half-filled form data.  This does not handle hard-reloads or\r\n * cross-origin navigations.\r\n */\r\n\r\nfunction useBlocker(shouldBlock) {\r\n  let {\r\n    router\r\n  } = useDataRouterContext(DataRouterHook.UseBlocker);\r\n  let [blockerKey] = React.useState(() => String(++blockerId));\r\n  let blockerFunction = React.useCallback(args => {\r\n    return typeof shouldBlock === \"function\" ? !!shouldBlock(args) : !!shouldBlock;\r\n  }, [shouldBlock]);\r\n  let blocker = router.getBlocker(blockerKey, blockerFunction); // Cleanup on unmount\r\n\r\n  React.useEffect(() => () => router.deleteBlocker(blockerKey), [router, blockerKey]);\r\n  return blocker;\r\n}\r\nconst alreadyWarned = {};\r\n\r\nfunction warningOnce(key, cond, message) {\r\n  if (!cond && !alreadyWarned[key]) {\r\n    alreadyWarned[key] = true;\r\n    process.env.NODE_ENV !== \"production\" ? warning(false, message) : void 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Given a Remix Router instance, render the appropriate UI\r\n */\r\nfunction RouterProvider(_ref) {\r\n  let {\r\n    fallbackElement,\r\n    router\r\n  } = _ref;\r\n  // Sync router state to our component state to force re-renders\r\n  let state = useSyncExternalStore(router.subscribe, () => router.state, // We have to provide this so React@18 doesn't complain during hydration,\r\n  // but we pass our serialized hydration data into the router so state here\r\n  // is already synced with what the server saw\r\n  () => router.state);\r\n  let navigator = React.useMemo(() => {\r\n    return {\r\n      createHref: router.createHref,\r\n      encodeLocation: router.encodeLocation,\r\n      go: n => router.navigate(n),\r\n      push: (to, state, opts) => router.navigate(to, {\r\n        state,\r\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\r\n      }),\r\n      replace: (to, state, opts) => router.navigate(to, {\r\n        replace: true,\r\n        state,\r\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\r\n      })\r\n    };\r\n  }, [router]);\r\n  let basename = router.basename || \"/\"; // The fragment and {null} here are important!  We need them to keep React 18's\r\n  // useId happy when we are server-rendering since we may have a <script> here\r\n  // containing the hydrated server-side staticContext (from StaticRouterProvider).\r\n  // useId relies on the component tree structure to generate deterministic id's\r\n  // so we need to ensure it remains the same on the client even though\r\n  // we don't need the <script> tag\r\n\r\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(DataRouterContext.Provider, {\r\n    value: {\r\n      router,\r\n      navigator,\r\n      static: false,\r\n      // Do we need this?\r\n      basename\r\n    }\r\n  }, /*#__PURE__*/React.createElement(DataRouterStateContext.Provider, {\r\n    value: state\r\n  }, /*#__PURE__*/React.createElement(Router, {\r\n    basename: router.basename,\r\n    location: router.state.location,\r\n    navigationType: router.state.historyAction,\r\n    navigator: navigator\r\n  }, router.state.initialized ? /*#__PURE__*/React.createElement(Routes, null) : fallbackElement))), null);\r\n}\r\n\r\n/**\r\n * A <Router> that stores all entries in memory.\r\n *\r\n * @see https://reactrouter.com/router-components/memory-router\r\n */\r\nfunction MemoryRouter(_ref2) {\r\n  let {\r\n    basename,\r\n    children,\r\n    initialEntries,\r\n    initialIndex\r\n  } = _ref2;\r\n  let historyRef = React.useRef();\r\n\r\n  if (historyRef.current == null) {\r\n    historyRef.current = createMemoryHistory({\r\n      initialEntries,\r\n      initialIndex,\r\n      v5Compat: true\r\n    });\r\n  }\r\n\r\n  let history = historyRef.current;\r\n  let [state, setState] = React.useState({\r\n    action: history.action,\r\n    location: history.location\r\n  });\r\n  React.useLayoutEffect(() => history.listen(setState), [history]);\r\n  return /*#__PURE__*/React.createElement(Router, {\r\n    basename: basename,\r\n    children: children,\r\n    location: state.location,\r\n    navigationType: state.action,\r\n    navigator: history\r\n  });\r\n}\r\n\r\n/**\r\n * Changes the current location.\r\n *\r\n * Note: This API is mostly useful in React.Component subclasses that are not\r\n * able to use hooks. In functional components, we recommend you use the\r\n * `useNavigate` hook instead.\r\n *\r\n * @see https://reactrouter.com/components/navigate\r\n */\r\nfunction Navigate(_ref3) {\r\n  let {\r\n    to,\r\n    replace,\r\n    state,\r\n    relative\r\n  } = _ref3;\r\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of\r\n  // the router loaded. We can help them understand how to avoid that.\r\n  \"<Navigate> may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\r\n  process.env.NODE_ENV !== \"production\" ? warning(!React.useContext(NavigationContext).static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : void 0;\r\n  let dataRouterState = React.useContext(DataRouterStateContext);\r\n  let navigate = useNavigate();\r\n  React.useEffect(() => {\r\n    // Avoid kicking off multiple navigations if we're in the middle of a\r\n    // data-router navigation, since components get re-rendered when we enter\r\n    // a submitting/loading state\r\n    if (dataRouterState && dataRouterState.navigation.state !== \"idle\") {\r\n      return;\r\n    }\r\n\r\n    navigate(to, {\r\n      replace,\r\n      state,\r\n      relative\r\n    });\r\n  });\r\n  return null;\r\n}\r\n\r\n/**\r\n * Renders the child route's element, if there is one.\r\n *\r\n * @see https://reactrouter.com/components/outlet\r\n */\r\nfunction Outlet(props) {\r\n  return useOutlet(props.context);\r\n}\r\n\r\n/**\r\n * Declares an element that should be rendered at a certain URL path.\r\n *\r\n * @see https://reactrouter.com/components/route\r\n */\r\nfunction Route(_props) {\r\n  process.env.NODE_ENV !== \"production\" ? invariant(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : invariant(false) ;\r\n}\r\n\r\n/**\r\n * Provides location context for the rest of the app.\r\n *\r\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\r\n * router that is more specific to your environment such as a <BrowserRouter>\r\n * in web browsers or a <StaticRouter> for server rendering.\r\n *\r\n * @see https://reactrouter.com/router-components/router\r\n */\r\nfunction Router(_ref4) {\r\n  let {\r\n    basename: basenameProp = \"/\",\r\n    children = null,\r\n    location: locationProp,\r\n    navigationType = Action.Pop,\r\n    navigator,\r\n    static: staticProp = false\r\n  } = _ref4;\r\n  !!useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\") : invariant(false) : void 0; // Preserve trailing slashes on basename, so we can let the user control\r\n  // the enforcement of trailing slashes throughout the app\r\n\r\n  let basename = basenameProp.replace(/^\\/*/, \"/\");\r\n  let navigationContext = React.useMemo(() => ({\r\n    basename,\r\n    navigator,\r\n    static: staticProp\r\n  }), [basename, navigator, staticProp]);\r\n\r\n  if (typeof locationProp === \"string\") {\r\n    locationProp = parsePath(locationProp);\r\n  }\r\n\r\n  let {\r\n    pathname = \"/\",\r\n    search = \"\",\r\n    hash = \"\",\r\n    state = null,\r\n    key = \"default\"\r\n  } = locationProp;\r\n  let location = React.useMemo(() => {\r\n    let trailingPathname = stripBasename(pathname, basename);\r\n\r\n    if (trailingPathname == null) {\r\n      return null;\r\n    }\r\n\r\n    return {\r\n      pathname: trailingPathname,\r\n      search,\r\n      hash,\r\n      state,\r\n      key\r\n    };\r\n  }, [basename, pathname, search, hash, state, key]);\r\n  process.env.NODE_ENV !== \"production\" ? warning(location != null, \"<Router basename=\\\"\" + basename + \"\\\"> is not able to match the URL \" + (\"\\\"\" + pathname + search + hash + \"\\\" because it does not start with the \") + \"basename, so the <Router> won't render anything.\") : void 0;\r\n\r\n  if (location == null) {\r\n    return null;\r\n  }\r\n\r\n  return /*#__PURE__*/React.createElement(NavigationContext.Provider, {\r\n    value: navigationContext\r\n  }, /*#__PURE__*/React.createElement(LocationContext.Provider, {\r\n    children: children,\r\n    value: {\r\n      location,\r\n      navigationType\r\n    }\r\n  }));\r\n}\r\n\r\n/**\r\n * A container for a nested tree of <Route> elements that renders the branch\r\n * that best matches the current location.\r\n *\r\n * @see https://reactrouter.com/components/routes\r\n */\r\nfunction Routes(_ref5) {\r\n  let {\r\n    children,\r\n    location\r\n  } = _ref5;\r\n  let dataRouterContext = React.useContext(DataRouterContext); // When in a DataRouterContext _without_ children, we use the router routes\r\n  // directly.  If we have children, then we're in a descendant tree and we\r\n  // need to use child routes.\r\n\r\n  let routes = dataRouterContext && !children ? dataRouterContext.router.routes : createRoutesFromChildren(children);\r\n  return useRoutes(routes, location);\r\n}\r\n\r\n/**\r\n * Component to use for rendering lazily loaded data from returning defer()\r\n * in a loader function\r\n */\r\nfunction Await(_ref6) {\r\n  let {\r\n    children,\r\n    errorElement,\r\n    resolve\r\n  } = _ref6;\r\n  return /*#__PURE__*/React.createElement(AwaitErrorBoundary, {\r\n    resolve: resolve,\r\n    errorElement: errorElement\r\n  }, /*#__PURE__*/React.createElement(ResolveAwait, null, children));\r\n}\r\nvar AwaitRenderStatus;\r\n\r\n(function (AwaitRenderStatus) {\r\n  AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\r\n  AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\r\n  AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\r\n})(AwaitRenderStatus || (AwaitRenderStatus = {}));\r\n\r\nconst neverSettledPromise = new Promise(() => {});\r\n\r\nclass AwaitErrorBoundary extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      error: null\r\n    };\r\n  }\r\n\r\n  static getDerivedStateFromError(error) {\r\n    return {\r\n      error\r\n    };\r\n  }\r\n\r\n  componentDidCatch(error, errorInfo) {\r\n    console.error(\"<Await> caught the following error during render\", error, errorInfo);\r\n  }\r\n\r\n  render() {\r\n    let {\r\n      children,\r\n      errorElement,\r\n      resolve\r\n    } = this.props;\r\n    let promise = null;\r\n    let status = AwaitRenderStatus.pending;\r\n\r\n    if (!(resolve instanceof Promise)) {\r\n      // Didn't get a promise - provide as a resolved promise\r\n      status = AwaitRenderStatus.success;\r\n      promise = Promise.resolve();\r\n      Object.defineProperty(promise, \"_tracked\", {\r\n        get: () => true\r\n      });\r\n      Object.defineProperty(promise, \"_data\", {\r\n        get: () => resolve\r\n      });\r\n    } else if (this.state.error) {\r\n      // Caught a render error, provide it as a rejected promise\r\n      status = AwaitRenderStatus.error;\r\n      let renderError = this.state.error;\r\n      promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings\r\n\r\n      Object.defineProperty(promise, \"_tracked\", {\r\n        get: () => true\r\n      });\r\n      Object.defineProperty(promise, \"_error\", {\r\n        get: () => renderError\r\n      });\r\n    } else if (resolve._tracked) {\r\n      // Already tracked promise - check contents\r\n      promise = resolve;\r\n      status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\r\n    } else {\r\n      // Raw (untracked) promise - track it\r\n      status = AwaitRenderStatus.pending;\r\n      Object.defineProperty(resolve, \"_tracked\", {\r\n        get: () => true\r\n      });\r\n      promise = resolve.then(data => Object.defineProperty(resolve, \"_data\", {\r\n        get: () => data\r\n      }), error => Object.defineProperty(resolve, \"_error\", {\r\n        get: () => error\r\n      }));\r\n    }\r\n\r\n    if (status === AwaitRenderStatus.error && promise._error instanceof AbortedDeferredError) {\r\n      // Freeze the UI by throwing a never resolved promise\r\n      throw neverSettledPromise;\r\n    }\r\n\r\n    if (status === AwaitRenderStatus.error && !errorElement) {\r\n      // No errorElement, throw to the nearest route-level error boundary\r\n      throw promise._error;\r\n    }\r\n\r\n    if (status === AwaitRenderStatus.error) {\r\n      // Render via our errorElement\r\n      return /*#__PURE__*/React.createElement(AwaitContext.Provider, {\r\n        value: promise,\r\n        children: errorElement\r\n      });\r\n    }\r\n\r\n    if (status === AwaitRenderStatus.success) {\r\n      // Render children with resolved value\r\n      return /*#__PURE__*/React.createElement(AwaitContext.Provider, {\r\n        value: promise,\r\n        children: children\r\n      });\r\n    } // Throw to the suspense boundary\r\n\r\n\r\n    throw promise;\r\n  }\r\n\r\n}\r\n/**\r\n * @private\r\n * Indirection to leverage useAsyncValue for a render-prop API on <Await>\r\n */\r\n\r\n\r\nfunction ResolveAwait(_ref7) {\r\n  let {\r\n    children\r\n  } = _ref7;\r\n  let data = useAsyncValue();\r\n  let toRender = typeof children === \"function\" ? children(data) : children;\r\n  return /*#__PURE__*/React.createElement(React.Fragment, null, toRender);\r\n} ///////////////////////////////////////////////////////////////////////////////\r\n// UTILS\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\n/**\r\n * Creates a route config from a React \"children\" object, which is usually\r\n * either a `<Route>` element or an array of them. Used internally by\r\n * `<Routes>` to create a route config from its children.\r\n *\r\n * @see https://reactrouter.com/utils/create-routes-from-children\r\n */\r\n\r\n\r\nfunction createRoutesFromChildren(children, parentPath) {\r\n  if (parentPath === void 0) {\r\n    parentPath = [];\r\n  }\r\n\r\n  let routes = [];\r\n  React.Children.forEach(children, (element, index) => {\r\n    if (! /*#__PURE__*/React.isValidElement(element)) {\r\n      // Ignore non-elements. This allows people to more easily inline\r\n      // conditionals in their route config.\r\n      return;\r\n    }\r\n\r\n    if (element.type === React.Fragment) {\r\n      // Transparently support React.Fragment and its children.\r\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children, parentPath));\r\n      return;\r\n    }\r\n\r\n    !(element.type === Route) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : invariant(false) : void 0;\r\n    !(!element.props.index || !element.props.children) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"An index route cannot have child routes.\") : invariant(false) : void 0;\r\n    let treePath = [...parentPath, index];\r\n    let route = {\r\n      id: element.props.id || treePath.join(\"-\"),\r\n      caseSensitive: element.props.caseSensitive,\r\n      element: element.props.element,\r\n      index: element.props.index,\r\n      path: element.props.path,\r\n      loader: element.props.loader,\r\n      action: element.props.action,\r\n      errorElement: element.props.errorElement,\r\n      hasErrorBoundary: element.props.errorElement != null,\r\n      shouldRevalidate: element.props.shouldRevalidate,\r\n      handle: element.props.handle\r\n    };\r\n\r\n    if (element.props.children) {\r\n      route.children = createRoutesFromChildren(element.props.children, treePath);\r\n    }\r\n\r\n    routes.push(route);\r\n  });\r\n  return routes;\r\n}\r\n/**\r\n * Renders the result of `matchRoutes()` into a React element.\r\n */\r\n\r\nfunction renderMatches(matches) {\r\n  return _renderMatches(matches);\r\n}\r\n/**\r\n * @private\r\n * Walk the route tree and add hasErrorBoundary if it's not provided, so that\r\n * users providing manual route arrays can just specify errorElement\r\n */\r\n\r\nfunction enhanceManualRouteObjects(routes) {\r\n  return routes.map(route => {\r\n    let routeClone = _extends({}, route);\r\n\r\n    if (routeClone.hasErrorBoundary == null) {\r\n      routeClone.hasErrorBoundary = routeClone.errorElement != null;\r\n    }\r\n\r\n    if (routeClone.children) {\r\n      routeClone.children = enhanceManualRouteObjects(routeClone.children);\r\n    }\r\n\r\n    return routeClone;\r\n  });\r\n}\r\n\r\nfunction createMemoryRouter(routes, opts) {\r\n  return createRouter({\r\n    basename: opts == null ? void 0 : opts.basename,\r\n    history: createMemoryHistory({\r\n      initialEntries: opts == null ? void 0 : opts.initialEntries,\r\n      initialIndex: opts == null ? void 0 : opts.initialIndex\r\n    }),\r\n    hydrationData: opts == null ? void 0 : opts.hydrationData,\r\n    routes: enhanceManualRouteObjects(routes)\r\n  }).initialize();\r\n} ///////////////////////////////////////////////////////////////////////////////\r\n\r\nexport { Await, MemoryRouter, Navigate, Outlet, Route, Router, RouterProvider, Routes, DataRouterContext as UNSAFE_DataRouterContext, DataRouterStateContext as UNSAFE_DataRouterStateContext, LocationContext as UNSAFE_LocationContext, NavigationContext as UNSAFE_NavigationContext, RouteContext as UNSAFE_RouteContext, enhanceManualRouteObjects as UNSAFE_enhanceManualRouteObjects, createMemoryRouter, createRoutesFromChildren, createRoutesFromChildren as createRoutesFromElements, renderMatches, useBlocker as unstable_useBlocker, useActionData, useAsyncError, useAsyncValue, useHref, useInRouterContext, useLoaderData, useLocation, useMatch, useMatches, useNavigate, useNavigation, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRevalidator, useRouteError, useRouteLoaderData, useRoutes };\r\n//# sourceMappingURL=index.js.map\r\n"],"names":["_extends","target","i","source","key","isPolyfill","x","y","is","useState","useEffect","useLayoutEffect","useDebugValue","React","useSyncExternalStore$2","subscribe","getSnapshot","getServerSnapshot","value","inst","forceUpdate","checkIfSnapshotChanged","latestGetSnapshot","prevValue","nextValue","useSyncExternalStore$1","canUseDOM","isServerEnvironment","shim","module","DataRouterContext","React.createContext","DataRouterStateContext","NavigationContext","LocationContext","RouteContext","RouteErrorContext","useHref","to","_temp","relative","useInRouterContext","invariant","basename","navigator","React.useContext","hash","pathname","search","useResolvedPath","joinedPathname","joinPaths","useLocation","useNavigate","matches","locationPathname","routePathnamesJson","UNSAFE_getPathContributingMatches","match","activeRef","React.useRef","React.useEffect","React.useCallback","options","path","resolveTo","OutletContext","useOutlet","context","outlet","React.createElement","_temp2","React.useMemo","useRoutes","routes","locationArg","dataRouterStateContext","parentMatches","routeMatch","parentParams","parentPathnameBase","locationFromContext","location","_parsedLocationArg$pa","parsedLocationArg","parsePath","remainingPathname","matchRoutes","renderedMatches","_renderMatches","Action","DefaultErrorElement","error","useRouteError","message","isRouteErrorResponse","stack","preStyles","devInfo","React.Fragment","RenderErrorBoundary","React.Component","props","state","errorInfo","RenderedRoute","_ref","routeContext","children","dataRouterContext","dataRouterState","errors","errorIndex","m","index","errorElement","getChildren","DataRouterHook","DataRouterStateHook","useDataRouterState","hookName","useRouteContext","route","useCurrentRouteId","thisRoute","_state$errors","routeId","Outlet","Route","_props","Router","_ref4","basenameProp","locationProp","navigationType","staticProp","navigationContext","trailingPathname","stripBasename","Routes","_ref5","createRoutesFromChildren","AwaitRenderStatus","parentPath","React.Children","element","React.isValidElement","treePath"],"mappings":"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"}